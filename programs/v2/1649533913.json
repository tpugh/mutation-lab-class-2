{"config": {"Build Date": "17 Mar 2022", "Commit": "ac98382", "LLVM Version": "12.0.0", "Mull Version": "0.17.1", "URL": "https://github.com/mull-project/mull"}, "files": {"/home/tpugh_/new_programs/sed/versions.alt/versions.orig/v2/sed.c": {"language": "cpp", "mutants": [{"id": "cxx_ne_to_eq", "location": {"end": {"column": 5, "line": 407}, "start": {"column": 3, "line": 407}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 415}, "start": {"column": 18, "line": 415}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 48, "line": 417}, "start": {"column": 47, "line": 417}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 63, "line": 422}, "start": {"column": 62, "line": 422}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 81, "line": 422}, "start": {"column": 80, "line": 422}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 457}, "start": {"column": 18, "line": 457}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 36, "line": 459}, "start": {"column": 34, "line": 459}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 14, "line": 485}, "start": {"column": 12, "line": 485}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 14, "line": 485}, "start": {"column": 12, "line": 485}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 24, "line": 487}, "start": {"column": 22, "line": 487}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 491}, "start": {"column": 19, "line": 491}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 491}, "start": {"column": 19, "line": 491}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 493}, "start": {"column": 13, "line": 493}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 22, "line": 493}, "start": {"column": 21, "line": 493}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 21, "line": 494}, "start": {"column": 19, "line": 494}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 10, "line": 496}, "start": {"column": 8, "line": 496}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 511}, "start": {"column": 19, "line": 511}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 511}, "start": {"column": 19, "line": 511}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 34, "line": 511}, "start": {"column": 32, "line": 511}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 544}, "start": {"column": 14, "line": 544}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 544}, "start": {"column": 31, "line": 544}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 549}, "start": {"column": 10, "line": 549}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 552}, "start": {"column": 14, "line": 552}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 21, "line": 553}, "start": {"column": 19, "line": 553}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 554}, "start": {"column": 17, "line": 554}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 554}, "start": {"column": 30, "line": 554}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 557}, "start": {"column": 11, "line": 557}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 560}, "start": {"column": 7, "line": 560}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 562}, "start": {"column": 15, "line": 562}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 600}, "start": {"column": 13, "line": 600}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 600}, "start": {"column": 29, "line": 600}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 603}, "start": {"column": 17, "line": 603}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 603}, "start": {"column": 47, "line": 603}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 63, "line": 603}, "start": {"column": 61, "line": 603}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 604}, "start": {"column": 14, "line": 604}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 608}, "start": {"column": 28, "line": 608}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 612}, "start": {"column": 27, "line": 612}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 10, "line": 613}, "start": {"column": 9, "line": 613}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 25, "line": 617}, "start": {"column": 23, "line": 617}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 627}, "start": {"column": 11, "line": 627}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 631}, "start": {"column": 18, "line": 631}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 641}, "start": {"column": 33, "line": 641}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 642}, "start": {"column": 29, "line": 642}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 32, "line": 643}, "start": {"column": 31, "line": 643}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 32, "line": 643}, "start": {"column": 31, "line": 643}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 647}, "start": {"column": 14, "line": 647}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 653}, "start": {"column": 30, "line": 653}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 658}, "start": {"column": 15, "line": 658}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 661}, "start": {"column": 14, "line": 661}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 661}, "start": {"column": 27, "line": 661}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 670}, "start": {"column": 14, "line": 670}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 671}, "start": {"column": 11, "line": 671}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 679}, "start": {"column": 30, "line": 679}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 684}, "start": {"column": 18, "line": 684}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 41, "line": 684}, "start": {"column": 39, "line": 684}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 687}, "start": {"column": 28, "line": 687}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 687}, "start": {"column": 41, "line": 687}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 689}, "start": {"column": 15, "line": 689}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 693}, "start": {"column": 11, "line": 693}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 19, "line": 704}, "start": {"column": 17, "line": 704}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 49, "line": 714}, "start": {"column": 48, "line": 714}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 722}, "start": {"column": 30, "line": 722}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 724}, "start": {"column": 28, "line": 724}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 724}, "start": {"column": 41, "line": 724}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 57, "line": 724}, "start": {"column": 55, "line": 724}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 730}, "start": {"column": 30, "line": 730}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 759}, "start": {"column": 14, "line": 759}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 45, "line": 759}, "start": {"column": 43, "line": 759}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 59, "line": 759}, "start": {"column": 57, "line": 759}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 760}, "start": {"column": 11, "line": 760}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 760}, "start": {"column": 25, "line": 760}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 40, "line": 760}, "start": {"column": 38, "line": 760}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 765}, "start": {"column": 30, "line": 765}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 48, "line": 770}, "start": {"column": 46, "line": 770}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 782}, "start": {"column": 29, "line": 782}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 46, "line": 782}, "start": {"column": 44, "line": 782}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 63, "line": 782}, "start": {"column": 61, "line": 782}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 784}, "start": {"column": 15, "line": 784}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 14, "line": 789}, "start": {"column": 12, "line": 789}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 791}, "start": {"column": 16, "line": 791}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 799}, "start": {"column": 11, "line": 799}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 801}, "start": {"column": 15, "line": 801}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 37, "line": 801}, "start": {"column": 36, "line": 801}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 37, "line": 801}, "start": {"column": 36, "line": 801}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 813}, "start": {"column": 11, "line": 813}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 849}, "start": {"column": 53, "line": 849}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 854}, "start": {"column": 19, "line": 854}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 854}, "start": {"column": 24, "line": 854}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 854}, "start": {"column": 29, "line": 854}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 869}, "start": {"column": 14, "line": 869}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 869}, "start": {"column": 27, "line": 869}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 869}, "start": {"column": 41, "line": 869}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 870}, "start": {"column": 11, "line": 870}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 23, "line": 877}, "start": {"column": 22, "line": 877}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 23, "line": 877}, "start": {"column": 22, "line": 877}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 34, "line": 877}, "start": {"column": 32, "line": 877}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 881}, "start": {"column": 28, "line": 881}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 881}, "start": {"column": 41, "line": 881}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 888}, "start": {"column": 15, "line": 888}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 890}, "start": {"column": 15, "line": 890}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 895}, "start": {"column": 18, "line": 895}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 50, "line": 895}, "start": {"column": 48, "line": 895}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 63, "line": 895}, "start": {"column": 61, "line": 895}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 77, "line": 895}, "start": {"column": 75, "line": 895}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 916}, "start": {"column": 17, "line": 916}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 916}, "start": {"column": 17, "line": 916}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 942}, "start": {"column": 25, "line": 942}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 950}, "start": {"column": 11, "line": 950}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 951}, "start": {"column": 14, "line": 951}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 961}, "start": {"column": 10, "line": 961}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 963}, "start": {"column": 10, "line": 963}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 32, "line": 963}, "start": {"column": 31, "line": 963}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 32, "line": 963}, "start": {"column": 31, "line": 963}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 987}, "start": {"column": 16, "line": 987}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 988}, "start": {"column": 31, "line": 988}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 13, "line": 989}, "start": {"column": 12, "line": 989}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 18, "line": 989}, "start": {"column": 17, "line": 989}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 989}, "start": {"column": 22, "line": 989}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 990}, "start": {"column": 14, "line": 990}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 997}, "start": {"column": 15, "line": 997}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 998}, "start": {"column": 30, "line": 998}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 999}, "start": {"column": 18, "line": 999}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 24, "line": 999}, "start": {"column": 23, "line": 999}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 999}, "start": {"column": 28, "line": 999}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 1002}, "start": {"column": 33, "line": 1002}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1009}, "start": {"column": 17, "line": 1009}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 1014}, "start": {"column": 15, "line": 1014}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 1014}, "start": {"column": 28, "line": 1014}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1017}, "start": {"column": 14, "line": 1017}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1024}, "start": {"column": 17, "line": 1024}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 1028}, "start": {"column": 15, "line": 1028}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1033}, "start": {"column": 17, "line": 1033}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 1051}, "start": {"column": 27, "line": 1051}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 1051}, "start": {"column": 41, "line": 1051}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 71, "line": 1051}, "start": {"column": 69, "line": 1051}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 71, "line": 1051}, "start": {"column": 69, "line": 1051}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1053}, "start": {"column": 14, "line": 1053}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 1055}, "start": {"column": 24, "line": 1055}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 1064}, "start": {"column": 19, "line": 1064}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 1068}, "start": {"column": 11, "line": 1068}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 1077}, "start": {"column": 19, "line": 1077}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 24, "line": 1079}, "start": {"column": 23, "line": 1079}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 24, "line": 1079}, "start": {"column": 23, "line": 1079}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 1084}, "start": {"column": 19, "line": 1084}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 33, "line": 1089}, "start": {"column": 32, "line": 1089}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 33, "line": 1090}, "start": {"column": 31, "line": 1090}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 33, "line": 1090}, "start": {"column": 31, "line": 1090}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 1091}, "start": {"column": 17, "line": 1091}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 36, "line": 1091}, "start": {"column": 35, "line": 1091}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 1092}, "start": {"column": 21, "line": 1092}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 40, "line": 1092}, "start": {"column": 39, "line": 1092}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 1093}, "start": {"column": 32, "line": 1093}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 39, "line": 1093}, "start": {"column": 37, "line": 1093}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 1098}, "start": {"column": 19, "line": 1098}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 48, "line": 1098}, "start": {"column": 46, "line": 1098}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 48, "line": 1098}, "start": {"column": 46, "line": 1098}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 1131}, "start": {"column": 10, "line": 1131}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 24, "line": 1137}, "start": {"column": 23, "line": 1137}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 58, "line": 1139}, "start": {"column": 57, "line": 1139}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 1176}, "start": {"column": 27, "line": 1176}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 1179}, "start": {"column": 13, "line": 1179}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 28, "line": 1179}, "start": {"column": 26, "line": 1179}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 61, "line": 1179}, "start": {"column": 59, "line": 1179}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 74, "line": 1179}, "start": {"column": 72, "line": 1179}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 1188}, "start": {"column": 22, "line": 1188}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1207}, "start": {"column": 17, "line": 1207}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 1210}, "start": {"column": 27, "line": 1210}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 42, "line": 1210}, "start": {"column": 40, "line": 1210}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 1214}, "start": {"column": 17, "line": 1214}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 1214}, "start": {"column": 17, "line": 1214}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 1214}, "start": {"column": 29, "line": 1214}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 10, "line": 1219}, "start": {"column": 9, "line": 1219}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 10, "line": 1219}, "start": {"column": 9, "line": 1219}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 1247}, "start": {"column": 13, "line": 1247}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 1247}, "start": {"column": 31, "line": 1247}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 1252}, "start": {"column": 22, "line": 1252}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 15, "line": 1255}, "start": {"column": 13, "line": 1255}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 1283}, "start": {"column": 16, "line": 1283}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 1341}, "start": {"column": 30, "line": 1341}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 1342}, "start": {"column": 36, "line": 1342}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 33, "line": 1365}, "start": {"column": 32, "line": 1365}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 1377}, "start": {"column": 24, "line": 1377}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 41, "line": 1377}, "start": {"column": 40, "line": 1377}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 41, "line": 1377}, "start": {"column": 40, "line": 1377}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 17, "line": 1389}, "start": {"column": 15, "line": 1389}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 1394}, "start": {"column": 27, "line": 1394}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 15, "line": 1406}, "start": {"column": 13, "line": 1406}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 15, "line": 1411}, "start": {"column": 13, "line": 1411}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 1420}, "start": {"column": 30, "line": 1420}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 1420}, "start": {"column": 37, "line": 1420}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 51, "line": 1420}, "start": {"column": 50, "line": 1420}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 17, "line": 1428}, "start": {"column": 15, "line": 1428}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 1464}, "start": {"column": 19, "line": 1464}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 1466}, "start": {"column": 13, "line": 1466}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 1466}, "start": {"column": 13, "line": 1466}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 1471}, "start": {"column": 12, "line": 1471}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 14, "line": 1479}, "start": {"column": 12, "line": 1479}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 1558}, "start": {"column": 20, "line": 1558}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 1558}, "start": {"column": 32, "line": 1558}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 14, "line": 1565}, "start": {"column": 12, "line": 1565}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 15, "line": 1566}, "start": {"column": 13, "line": 1566}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 1579}, "start": {"column": 25, "line": 1579}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 1585}, "start": {"column": 24, "line": 1585}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 1588}, "start": {"column": 12, "line": 1588}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 1588}, "start": {"column": 12, "line": 1588}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 47, "line": 1597}, "start": {"column": 46, "line": 1597}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 53, "line": 1597}, "start": {"column": 51, "line": 1597}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 1605}, "start": {"column": 27, "line": 1605}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 1612}, "start": {"column": 18, "line": 1612}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 16, "line": 1615}, "start": {"column": 14, "line": 1615}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 16, "line": 1615}, "start": {"column": 14, "line": 1615}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 10, "line": 1617}, "start": {"column": 8, "line": 1617}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 1618}, "start": {"column": 14, "line": 1618}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 50, "line": 1619}, "start": {"column": 49, "line": 1619}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1623}, "start": {"column": 17, "line": 1623}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 1625}, "start": {"column": 30, "line": 1625}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 1628}, "start": {"column": 20, "line": 1628}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 16, "line": 1629}, "start": {"column": 15, "line": 1629}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 1630}, "start": {"column": 26, "line": 1630}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 41, "line": 1630}, "start": {"column": 40, "line": 1630}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 44, "line": 1635}, "start": {"column": 43, "line": 1635}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 44, "line": 1635}, "start": {"column": 43, "line": 1635}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 1637}, "start": {"column": 21, "line": 1637}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 18, "line": 1639}, "start": {"column": 17, "line": 1639}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 43, "line": 1640}, "start": {"column": 42, "line": 1640}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 62, "line": 1641}, "start": {"column": 61, "line": 1641}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 1644}, "start": {"column": 26, "line": 1644}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 18, "line": 1646}, "start": {"column": 17, "line": 1646}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 43, "line": 1647}, "start": {"column": 42, "line": 1647}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 1649}, "start": {"column": 17, "line": 1649}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 1653}, "start": {"column": 22, "line": 1653}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 1653}, "start": {"column": 22, "line": 1653}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 44, "line": 1653}, "start": {"column": 42, "line": 1653}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 44, "line": 1653}, "start": {"column": 42, "line": 1653}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 1655}, "start": {"column": 19, "line": 1655}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 63, "line": 1656}, "start": {"column": 62, "line": 1656}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 1664}, "start": {"column": 16, "line": 1664}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 1665}, "start": {"column": 41, "line": 1665}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1666}, "start": {"column": 14, "line": 1666}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 1669}, "start": {"column": 7, "line": 1669}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 1673}, "start": {"column": 25, "line": 1673}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 1673}, "start": {"column": 39, "line": 1673}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 1674}, "start": {"column": 14, "line": 1674}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 1674}, "start": {"column": 14, "line": 1674}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 51, "line": 1682}, "start": {"column": 50, "line": 1682}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 14, "line": 1706}, "start": {"column": 12, "line": 1706}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 1711}, "start": {"column": 24, "line": 1711}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 7, "line": 1742}, "start": {"column": 6, "line": 1742}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 7, "line": 1742}, "start": {"column": 6, "line": 1742}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 1768}, "start": {"column": 33, "line": 1768}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 34, "line": 1770}, "start": {"column": 33, "line": 1770}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 1770}, "start": {"column": 48, "line": 1770}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 43, "line": 1775}, "start": {"column": 42, "line": 1775}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 1775}, "start": {"column": 47, "line": 1775}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 1778}, "start": {"column": 19, "line": 1778}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 1780}, "start": {"column": 19, "line": 1780}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 36, "line": 1781}, "start": {"column": 34, "line": 1781}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 36, "line": 1781}, "start": {"column": 34, "line": 1781}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 1808}, "start": {"column": 20, "line": 1808}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 1812}, "start": {"column": 13, "line": 1812}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 51, "line": 1814}, "start": {"column": 50, "line": 1814}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1820}, "start": {"column": 14, "line": 1820}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 1822}, "start": {"column": 10, "line": 1822}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 1826}, "start": {"column": 29, "line": 1826}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 17, "line": 1828}, "start": {"column": 15, "line": 1828}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1833}, "start": {"column": 14, "line": 1833}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 1835}, "start": {"column": 29, "line": 1835}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 12, "line": 1840}, "start": {"column": 10, "line": 1840}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 1843}, "start": {"column": 14, "line": 1843}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 1857}, "start": {"column": 18, "line": 1857}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 1859}, "start": {"column": 20, "line": 1859}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1864}, "start": {"column": 14, "line": 1864}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 1866}, "start": {"column": 10, "line": 1866}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 1870}, "start": {"column": 29, "line": 1870}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 17, "line": 1872}, "start": {"column": 15, "line": 1872}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 1875}, "start": {"column": 13, "line": 1875}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 51, "line": 1877}, "start": {"column": 50, "line": 1877}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 1884}, "start": {"column": 14, "line": 1884}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 1886}, "start": {"column": 29, "line": 1886}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 12, "line": 1891}, "start": {"column": 10, "line": 1891}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 1894}, "start": {"column": 14, "line": 1894}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 1904}, "start": {"column": 20, "line": 1904}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 1904}, "start": {"column": 20, "line": 1904}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 1919}, "start": {"column": 20, "line": 1919}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 1919}, "start": {"column": 20, "line": 1919}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 34, "line": 1919}, "start": {"column": 33, "line": 1919}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 1937}, "start": {"column": 14, "line": 1937}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 1937}, "start": {"column": 14, "line": 1937}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 1937}, "start": {"column": 26, "line": 1937}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 2073}, "start": {"column": 11, "line": 2073}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 2073}, "start": {"column": 11, "line": 2073}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 2073}, "start": {"column": 20, "line": 2073}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 2074}, "start": {"column": 18, "line": 2074}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 10, "line": 2090}, "start": {"column": 8, "line": 2090}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 2092}, "start": {"column": 11, "line": 2092}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 2092}, "start": {"column": 11, "line": 2092}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 2092}, "start": {"column": 20, "line": 2092}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 2093}, "start": {"column": 9, "line": 2093}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 50, "line": 2095}, "start": {"column": 49, "line": 2095}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 8, "line": 2100}, "start": {"column": 6, "line": 2100}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 2101}, "start": {"column": 12, "line": 2101}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 2101}, "start": {"column": 12, "line": 2101}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 23, "line": 2101}, "start": {"column": 21, "line": 2101}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2102}, "start": {"column": 19, "line": 2102}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 9, "line": 2104}, "start": {"column": 7, "line": 2104}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 49, "line": 2107}, "start": {"column": 48, "line": 2107}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 2120}, "start": {"column": 34, "line": 2120}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 2129}, "start": {"column": 19, "line": 2129}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 9, "line": 2141}, "start": {"column": 7, "line": 2141}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 10, "line": 2143}, "start": {"column": 8, "line": 2143}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 10, "line": 2167}, "start": {"column": 8, "line": 2167}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 36, "line": 2179}, "start": {"column": 35, "line": 2179}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 2243}, "start": {"column": 14, "line": 2243}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 2243}, "start": {"column": 16, "line": 2243}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 2243}, "start": {"column": 16, "line": 2243}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 2244}, "start": {"column": 29, "line": 2244}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 35, "line": 2244}, "start": {"column": 34, "line": 2244}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 2263}, "start": {"column": 14, "line": 2263}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 2263}, "start": {"column": 16, "line": 2263}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 2263}, "start": {"column": 16, "line": 2263}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 13, "line": 2268}, "start": {"column": 11, "line": 2268}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 2605}, "start": {"column": 20, "line": 2605}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 2605}, "start": {"column": 20, "line": 2605}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 2605}, "start": {"column": 29, "line": 2605}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 2608}, "start": {"column": 20, "line": 2608}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 2608}, "start": {"column": 20, "line": 2608}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 2608}, "start": {"column": 29, "line": 2608}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 2611}, "start": {"column": 20, "line": 2611}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 2611}, "start": {"column": 20, "line": 2611}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 2611}, "start": {"column": 29, "line": 2611}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 41, "line": 2897}, "start": {"column": 40, "line": 2897}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 2898}, "start": {"column": 31, "line": 2898}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 2899}, "start": {"column": 12, "line": 2899}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 2985}, "start": {"column": 41, "line": 2985}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 50, "line": 2985}, "start": {"column": 48, "line": 2985}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 50, "line": 2985}, "start": {"column": 48, "line": 2985}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 3002}, "start": {"column": 41, "line": 3002}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 50, "line": 3002}, "start": {"column": 48, "line": 3002}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 50, "line": 3002}, "start": {"column": 48, "line": 3002}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 3020}, "start": {"column": 41, "line": 3020}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 50, "line": 3020}, "start": {"column": 48, "line": 3020}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 50, "line": 3020}, "start": {"column": 48, "line": 3020}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 3037}, "start": {"column": 41, "line": 3037}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 50, "line": 3037}, "start": {"column": 48, "line": 3037}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 50, "line": 3037}, "start": {"column": 48, "line": 3037}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 3187}, "start": {"column": 30, "line": 3187}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 3192}, "start": {"column": 7, "line": 3192}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 3194}, "start": {"column": 30, "line": 3194}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 3227}, "start": {"column": 30, "line": 3227}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 3233}, "start": {"column": 7, "line": 3233}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 3235}, "start": {"column": 30, "line": 3235}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 3236}, "start": {"column": 7, "line": 3236}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 3249}, "start": {"column": 19, "line": 3249}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 3249}, "start": {"column": 19, "line": 3249}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 36, "line": 3250}, "start": {"column": 34, "line": 3250}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 36, "line": 3250}, "start": {"column": 34, "line": 3250}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 49, "line": 3260}, "start": {"column": 48, "line": 3260}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 47, "line": 3264}, "start": {"column": 46, "line": 3264}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 3269}, "start": {"column": 8, "line": 3269}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 22, "line": 3270}, "start": {"column": 8, "line": 3270}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 32, "line": 3272}, "start": {"column": 31, "line": 3272}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 61, "line": 3272}, "start": {"column": 60, "line": 3272}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 3277}, "start": {"column": 30, "line": 3277}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 3292}, "start": {"column": 5, "line": 3292}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 3293}, "start": {"column": 5, "line": 3293}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 52, "line": 3319}, "start": {"column": 51, "line": 3319}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 3322}, "start": {"column": 19, "line": 3322}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 45, "line": 3333}, "start": {"column": 44, "line": 3333}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 3361}, "start": {"column": 17, "line": 3361}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 3361}, "start": {"column": 17, "line": 3361}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 3361}, "start": {"column": 23, "line": 3361}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 3844}, "start": {"column": 15, "line": 3844}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 27, "line": 4156}, "start": {"column": 25, "line": 4156}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 31, "line": 4173}, "start": {"column": 18, "line": 4173}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4202}, "start": {"column": 15, "line": 4202}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 4208}, "start": {"column": 19, "line": 4208}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 4208}, "start": {"column": 19, "line": 4208}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 4210}, "start": {"column": 22, "line": 4210}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 4210}, "start": {"column": 22, "line": 4210}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 4286}, "start": {"column": 18, "line": 4286}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4338}, "start": {"column": 15, "line": 4338}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 4344}, "start": {"column": 17, "line": 4344}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 4344}, "start": {"column": 17, "line": 4344}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 4346}, "start": {"column": 20, "line": 4346}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 4346}, "start": {"column": 20, "line": 4346}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 4399}, "start": {"column": 18, "line": 4399}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 4426}, "start": {"column": 25, "line": 4426}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 4426}, "start": {"column": 25, "line": 4426}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 4428}, "start": {"column": 17, "line": 4428}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 4434}, "start": {"column": 18, "line": 4434}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 18, "line": 4478}, "start": {"column": 16, "line": 4478}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 18, "line": 4478}, "start": {"column": 16, "line": 4478}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 14, "line": 4492}, "start": {"column": 12, "line": 4492}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 14, "line": 4492}, "start": {"column": 12, "line": 4492}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 4496}, "start": {"column": 24, "line": 4496}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 4496}, "start": {"column": 24, "line": 4496}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 22, "line": 4504}, "start": {"column": 20, "line": 4504}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 22, "line": 4504}, "start": {"column": 20, "line": 4504}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 4561}, "start": {"column": 20, "line": 4561}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 4641}, "start": {"column": 14, "line": 4641}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 4643}, "start": {"column": 17, "line": 4643}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 4643}, "start": {"column": 17, "line": 4643}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 4643}, "start": {"column": 22, "line": 4643}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 36, "line": 4643}, "start": {"column": 35, "line": 4643}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 36, "line": 4643}, "start": {"column": 35, "line": 4643}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 4644}, "start": {"column": 21, "line": 4644}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 4644}, "start": {"column": 21, "line": 4644}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 4645}, "start": {"column": 20, "line": 4645}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 4645}, "start": {"column": 20, "line": 4645}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 4660}, "start": {"column": 17, "line": 4660}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 4660}, "start": {"column": 17, "line": 4660}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 4660}, "start": {"column": 23, "line": 4660}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 4729}, "start": {"column": 7, "line": 4729}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 4732}, "start": {"column": 4, "line": 4732}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 4737}, "start": {"column": 4, "line": 4737}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 30, "line": 4743}, "start": {"column": 29, "line": 4743}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4744}, "start": {"column": 3, "line": 4744}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 12, "line": 4744}, "start": {"column": 11, "line": 4744}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4745}, "start": {"column": 3, "line": 4745}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 12, "line": 4745}, "start": {"column": 11, "line": 4745}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4746}, "start": {"column": 3, "line": 4746}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 15, "line": 4746}, "start": {"column": 14, "line": 4746}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4747}, "start": {"column": 3, "line": 4747}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 14, "line": 4747}, "start": {"column": 13, "line": 4747}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4748}, "start": {"column": 3, "line": 4748}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 4748}, "start": {"column": 19, "line": 4748}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 4749}, "start": {"column": 3, "line": 4749}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 4751}, "start": {"column": 18, "line": 4751}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 4751}, "start": {"column": 18, "line": 4751}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 38, "line": 4767}, "start": {"column": 37, "line": 4767}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 29, "line": 4770}, "start": {"column": 28, "line": 4770}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 4774}, "start": {"column": 18, "line": 4774}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 38, "line": 4777}, "start": {"column": 37, "line": 4777}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 41, "line": 4779}, "start": {"column": 40, "line": 4779}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 24, "line": 4783}, "start": {"column": 23, "line": 4783}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 24, "line": 4783}, "start": {"column": 23, "line": 4783}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 18, "line": 4797}, "start": {"column": 16, "line": 4797}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 4802}, "start": {"column": 19, "line": 4802}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 4802}, "start": {"column": 19, "line": 4802}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 37, "line": 4802}, "start": {"column": 34, "line": 4802}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 4809}, "start": {"column": 16, "line": 4809}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 32, "line": 4809}, "start": {"column": 31, "line": 4809}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 4816}, "start": {"column": 33, "line": 4816}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 4816}, "start": {"column": 33, "line": 4816}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 21, "line": 4817}, "start": {"column": 20, "line": 4817}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 29, "line": 4941}, "start": {"column": 28, "line": 4941}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 29, "line": 4941}, "start": {"column": 28, "line": 4941}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 4999}, "start": {"column": 21, "line": 4999}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 4999}, "start": {"column": 21, "line": 4999}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 19, "line": 5009}, "start": {"column": 18, "line": 5009}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 5010}, "start": {"column": 13, "line": 5010}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 5010}, "start": {"column": 13, "line": 5010}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 5014}, "start": {"column": 6, "line": 5014}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 5060}, "start": {"column": 20, "line": 5060}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 5065}, "start": {"column": 7, "line": 5065}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 5066}, "start": {"column": 24, "line": 5066}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 5073}, "start": {"column": 33, "line": 5073}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 5092}, "start": {"column": 7, "line": 5092}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 5107}, "start": {"column": 9, "line": 5107}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 7, "line": 5144}, "start": {"column": 5, "line": 5144}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 5151}, "start": {"column": 34, "line": 5151}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 60, "line": 5152}, "start": {"column": 58, "line": 5152}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 5186}, "start": {"column": 34, "line": 5186}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 5188}, "start": {"column": 23, "line": 5188}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 5269}, "start": {"column": 25, "line": 5269}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 43, "line": 5269}, "start": {"column": 42, "line": 5269}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 43, "line": 5269}, "start": {"column": 42, "line": 5269}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 5274}, "start": {"column": 25, "line": 5274}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 43, "line": 5274}, "start": {"column": 42, "line": 5274}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 3, "line": 5275}, "start": {"column": 2, "line": 5275}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 3, "line": 5275}, "start": {"column": 2, "line": 5275}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 27, "line": 5275}, "start": {"column": 26, "line": 5275}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 5285}, "start": {"column": 7, "line": 5285}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 5286}, "start": {"column": 30, "line": 5286}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 5295}, "start": {"column": 41, "line": 5295}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 24, "line": 5305}, "start": {"column": 4, "line": 5305}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 5306}, "start": {"column": 27, "line": 5306}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 5312}, "start": {"column": 36, "line": 5312}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 5347}, "start": {"column": 54, "line": 5347}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 5350}, "start": {"column": 36, "line": 5350}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 5363}, "start": {"column": 32, "line": 5363}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 10, "line": 5426}, "start": {"column": 9, "line": 5426}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 36, "line": 5426}, "start": {"column": 35, "line": 5426}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 31, "line": 5428}, "start": {"column": 30, "line": 5428}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 31, "line": 5428}, "start": {"column": 30, "line": 5428}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 24, "line": 5433}, "start": {"column": 4, "line": 5433}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 5442}, "start": {"column": 2, "line": 5442}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 23, "line": 5444}, "start": {"column": 3, "line": 5444}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 5457}, "start": {"column": 17, "line": 5457}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 5458}, "start": {"column": 26, "line": 5458}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 5458}, "start": {"column": 48, "line": 5458}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 5557}, "start": {"column": 20, "line": 5557}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 16, "line": 5558}, "start": {"column": 15, "line": 5558}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 6, "line": 5559}, "start": {"column": 5, "line": 5559}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 8, "line": 5560}, "start": {"column": 7, "line": 5560}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 8, "line": 5561}, "start": {"column": 7, "line": 5561}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 5, "line": 5562}, "start": {"column": 4, "line": 5562}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 17, "line": 5562}, "start": {"column": 16, "line": 5562}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 30, "line": 5574}, "start": {"column": 28, "line": 5574}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 30, "line": 5574}, "start": {"column": 28, "line": 5574}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 5585}, "start": {"column": 19, "line": 5585}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 5714}, "start": {"column": 16, "line": 5714}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 5721}, "start": {"column": 18, "line": 5721}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 5721}, "start": {"column": 18, "line": 5721}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 5780}, "start": {"column": 19, "line": 5780}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 17, "line": 5785}, "start": {"column": 16, "line": 5785}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 17, "line": 5785}, "start": {"column": 16, "line": 5785}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 5809}, "start": {"column": 27, "line": 5809}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 5856}, "start": {"column": 34, "line": 5856}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 5867}, "start": {"column": 34, "line": 5867}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 5870}, "start": {"column": 31, "line": 5870}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 5896}, "start": {"column": 3, "line": 5896}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 20, "line": 5902}, "start": {"column": 7, "line": 5902}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 5912}, "start": {"column": 3, "line": 5912}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 5954}, "start": {"column": 19, "line": 5954}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 5954}, "start": {"column": 19, "line": 5954}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 45, "line": 5954}, "start": {"column": 42, "line": 5954}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 6010}, "start": {"column": 24, "line": 6010}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6027}, "start": {"column": 16, "line": 6027}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 59, "line": 6123}, "start": {"column": 57, "line": 6123}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 41, "line": 6126}, "start": {"column": 39, "line": 6126}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 39, "line": 6176}, "start": {"column": 38, "line": 6176}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 20, "line": 6232}, "start": {"column": 19, "line": 6232}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 6236}, "start": {"column": 16, "line": 6236}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 6236}, "start": {"column": 16, "line": 6236}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 6241}, "start": {"column": 7, "line": 6241}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 21, "line": 6259}, "start": {"column": 20, "line": 6259}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 51, "line": 6266}, "start": {"column": 50, "line": 6266}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 56, "line": 6273}, "start": {"column": 54, "line": 6273}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 33, "line": 6279}, "start": {"column": 32, "line": 6279}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 46, "line": 6288}, "start": {"column": 45, "line": 6288}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 46, "line": 6288}, "start": {"column": 45, "line": 6288}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 56, "line": 6312}, "start": {"column": 54, "line": 6312}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 33, "line": 6319}, "start": {"column": 32, "line": 6319}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 53, "line": 6341}, "start": {"column": 51, "line": 6341}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 41, "line": 6343}, "start": {"column": 40, "line": 6343}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 41, "line": 6499}, "start": {"column": 40, "line": 6499}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 41, "line": 6499}, "start": {"column": 40, "line": 6499}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 66, "line": 6499}, "start": {"column": 64, "line": 6499}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6504}, "start": {"column": 16, "line": 6504}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6507}, "start": {"column": 16, "line": 6507}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 6527}, "start": {"column": 35, "line": 6527}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 35, "line": 6528}, "start": {"column": 34, "line": 6528}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 35, "line": 6528}, "start": {"column": 34, "line": 6528}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6534}, "start": {"column": 16, "line": 6534}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 6535}, "start": {"column": 53, "line": 6535}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6539}, "start": {"column": 16, "line": 6539}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 6540}, "start": {"column": 53, "line": 6540}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 6598}, "start": {"column": 17, "line": 6598}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 6605}, "start": {"column": 21, "line": 6605}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 6605}, "start": {"column": 21, "line": 6605}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 6605}, "start": {"column": 28, "line": 6605}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 6606}, "start": {"column": 19, "line": 6606}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 6633}, "start": {"column": 43, "line": 6633}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 23, "line": 6634}, "start": {"column": 21, "line": 6634}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 23, "line": 6634}, "start": {"column": 21, "line": 6634}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 6636}, "start": {"column": 50, "line": 6636}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 6682}, "start": {"column": 9, "line": 6682}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 6689}, "start": {"column": 19, "line": 6689}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 6689}, "start": {"column": 19, "line": 6689}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 45, "line": 6692}, "start": {"column": 43, "line": 6692}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 45, "line": 6692}, "start": {"column": 43, "line": 6692}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 68, "line": 6692}, "start": {"column": 66, "line": 6692}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 42, "line": 6739}, "start": {"column": 40, "line": 6739}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 42, "line": 6739}, "start": {"column": 40, "line": 6739}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 6740}, "start": {"column": 52, "line": 6740}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 4, "line": 6781}, "start": {"column": 3, "line": 6781}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 6823}, "start": {"column": 12, "line": 6823}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 6836}, "start": {"column": 41, "line": 6836}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 6885}, "start": {"column": 30, "line": 6885}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 6915}, "start": {"column": 15, "line": 6915}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 6915}, "start": {"column": 15, "line": 6915}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 6916}, "start": {"column": 52, "line": 6916}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 47, "line": 6917}, "start": {"column": 45, "line": 6917}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 29, "line": 6918}, "start": {"column": 28, "line": 6918}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 29, "line": 6918}, "start": {"column": 28, "line": 6918}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 47, "line": 6960}, "start": {"column": 46, "line": 6960}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 47, "line": 6960}, "start": {"column": 46, "line": 6960}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 7035}, "start": {"column": 15, "line": 7035}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 7035}, "start": {"column": 15, "line": 7035}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 29, "line": 7036}, "start": {"column": 28, "line": 7036}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 29, "line": 7036}, "start": {"column": 28, "line": 7036}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 7037}, "start": {"column": 52, "line": 7037}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 47, "line": 7038}, "start": {"column": 45, "line": 7038}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 35, "line": 7150}, "start": {"column": 34, "line": 7150}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 35, "line": 7150}, "start": {"column": 34, "line": 7150}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_minus_to_noop", "location": {"end": {"column": 51, "line": 7152}, "start": {"column": 21, "line": 7152}}, "mutatorName": "Replaced -x with x", "replacement": "", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 47, "line": 7203}, "start": {"column": 45, "line": 7203}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 47, "line": 7203}, "start": {"column": 45, "line": 7203}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7386}, "start": {"column": 27, "line": 7386}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 14, "line": 7411}, "start": {"column": 12, "line": 7411}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 7420}, "start": {"column": 22, "line": 7420}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 7442}, "start": {"column": 22, "line": 7442}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 7489}, "start": {"column": 36, "line": 7489}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 7490}, "start": {"column": 36, "line": 7490}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7492}, "start": {"column": 23, "line": 7492}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7497}, "start": {"column": 23, "line": 7497}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 59, "line": 7498}, "start": {"column": 57, "line": 7498}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 71, "line": 7498}, "start": {"column": 69, "line": 7498}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 58, "line": 7501}, "start": {"column": 56, "line": 7501}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7503}, "start": {"column": 27, "line": 7503}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 7506}, "start": {"column": 30, "line": 7506}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 7506}, "start": {"column": 43, "line": 7506}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 24, "line": 7597}, "start": {"column": 23, "line": 7597}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 7597}, "start": {"column": 28, "line": 7597}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 7602}, "start": {"column": 5, "line": 7602}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 7634}, "start": {"column": 10, "line": 7634}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7639}, "start": {"column": 27, "line": 7639}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7658}, "start": {"column": 23, "line": 7658}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 68, "line": 7663}, "start": {"column": 66, "line": 7663}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7665}, "start": {"column": 27, "line": 7665}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7682}, "start": {"column": 23, "line": 7682}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 7682}, "start": {"column": 35, "line": 7682}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 7687}, "start": {"column": 41, "line": 7687}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 56, "line": 7687}, "start": {"column": 54, "line": 7687}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 7694}, "start": {"column": 23, "line": 7694}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 34, "line": 7695}, "start": {"column": 32, "line": 7695}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 34, "line": 7695}, "start": {"column": 32, "line": 7695}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 7695}, "start": {"column": 52, "line": 7695}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 34, "line": 7696}, "start": {"column": 32, "line": 7696}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 34, "line": 7696}, "start": {"column": 32, "line": 7696}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 7696}, "start": {"column": 52, "line": 7696}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 70, "line": 7696}, "start": {"column": 68, "line": 7696}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 7697}, "start": {"column": 27, "line": 7697}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 7702}, "start": {"column": 29, "line": 7702}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 7705}, "start": {"column": 31, "line": 7705}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 48, "line": 7705}, "start": {"column": 46, "line": 7705}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 7714}, "start": {"column": 29, "line": 7714}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 7721}, "start": {"column": 11, "line": 7721}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 7721}, "start": {"column": 26, "line": 7721}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7729}, "start": {"column": 27, "line": 7729}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 7734}, "start": {"column": 31, "line": 7734}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 7734}, "start": {"column": 43, "line": 7734}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 57, "line": 7734}, "start": {"column": 55, "line": 7734}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 7735}, "start": {"column": 35, "line": 7735}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 33, "line": 7737}, "start": {"column": 31, "line": 7737}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 7744}, "start": {"column": 27, "line": 7744}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 7744}, "start": {"column": 40, "line": 7744}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 7766}, "start": {"column": 31, "line": 7766}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 42, "line": 7768}, "start": {"column": 41, "line": 7768}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 42, "line": 7768}, "start": {"column": 41, "line": 7768}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 63, "line": 7768}, "start": {"column": 61, "line": 7768}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 7797}, "start": {"column": 27, "line": 7797}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 7885}, "start": {"column": 17, "line": 7885}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 7899}, "start": {"column": 27, "line": 7899}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 23, "line": 7900}, "start": {"column": 21, "line": 7900}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 7905}, "start": {"column": 43, "line": 7905}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 36, "line": 7928}, "start": {"column": 34, "line": 7928}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 7961}, "start": {"column": 27, "line": 7961}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 7966}, "start": {"column": 14, "line": 7966}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 7966}, "start": {"column": 19, "line": 7966}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 15, "line": 8017}, "start": {"column": 14, "line": 8017}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 20, "line": 8017}, "start": {"column": 19, "line": 8017}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 8022}, "start": {"column": 5, "line": 8022}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 8049}, "start": {"column": 29, "line": 8049}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 8049}, "start": {"column": 47, "line": 8049}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 8061}, "start": {"column": 23, "line": 8061}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 8071}, "start": {"column": 23, "line": 8071}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 38, "line": 8074}, "start": {"column": 37, "line": 8074}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 38, "line": 8074}, "start": {"column": 37, "line": 8074}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 8080}, "start": {"column": 33, "line": 8080}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 8080}, "start": {"column": 33, "line": 8080}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 53, "line": 8080}, "start": {"column": 52, "line": 8080}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 53, "line": 8080}, "start": {"column": 52, "line": 8080}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 37, "line": 8081}, "start": {"column": 36, "line": 8081}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 37, "line": 8081}, "start": {"column": 36, "line": 8081}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 8091}, "start": {"column": 27, "line": 8091}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 8095}, "start": {"column": 23, "line": 8095}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 8118}, "start": {"column": 34, "line": 8118}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 8130}, "start": {"column": 27, "line": 8130}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 26, "line": 8134}, "start": {"column": 25, "line": 8134}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 31, "line": 8134}, "start": {"column": 30, "line": 8134}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 27, "line": 8199}, "start": {"column": 26, "line": 8199}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 27, "line": 8199}, "start": {"column": 26, "line": 8199}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 8199}, "start": {"column": 47, "line": 8199}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 8253}, "start": {"column": 9, "line": 8253}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 39, "line": 8257}, "start": {"column": 38, "line": 8257}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 46, "line": 8257}, "start": {"column": 45, "line": 8257}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 46, "line": 8257}, "start": {"column": 45, "line": 8257}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 8316}, "start": {"column": 22, "line": 8316}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 8318}, "start": {"column": 22, "line": 8318}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 8318}, "start": {"column": 22, "line": 8318}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 29, "line": 8330}, "start": {"column": 28, "line": 8330}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 34, "line": 8330}, "start": {"column": 33, "line": 8330}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 8335}, "start": {"column": 3, "line": 8335}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 24, "line": 8400}, "start": {"column": 23, "line": 8400}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 8400}, "start": {"column": 28, "line": 8400}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 13, "line": 8405}, "start": {"column": 5, "line": 8405}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 8456}, "start": {"column": 25, "line": 8456}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 8462}, "start": {"column": 18, "line": 8462}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 8462}, "start": {"column": 18, "line": 8462}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8462}, "start": {"column": 28, "line": 8462}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 8463}, "start": {"column": 28, "line": 8463}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 8464}, "start": {"column": 21, "line": 8464}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 30, "line": 8535}, "start": {"column": 29, "line": 8535}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 49, "line": 8558}, "start": {"column": 48, "line": 8558}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 6, "line": 8559}, "start": {"column": 5, "line": 8559}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 8575}, "start": {"column": 24, "line": 8575}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8706}, "start": {"column": 17, "line": 8706}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8706}, "start": {"column": 17, "line": 8706}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 27, "line": 8706}, "start": {"column": 24, "line": 8706}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 8861}, "start": {"column": 36, "line": 8861}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 8863}, "start": {"column": 26, "line": 8863}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8869}, "start": {"column": 17, "line": 8869}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8869}, "start": {"column": 17, "line": 8869}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 36, "line": 8869}, "start": {"column": 35, "line": 8869}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 36, "line": 8869}, "start": {"column": 35, "line": 8869}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 8876}, "start": {"column": 27, "line": 8876}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8877}, "start": {"column": 16, "line": 8877}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8877}, "start": {"column": 16, "line": 8877}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 8878}, "start": {"column": 19, "line": 8878}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 22, "line": 8879}, "start": {"column": 21, "line": 8879}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 22, "line": 8879}, "start": {"column": 21, "line": 8879}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 8880}, "start": {"column": 26, "line": 8880}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 35, "line": 8886}, "start": {"column": 34, "line": 8886}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 35, "line": 8886}, "start": {"column": 34, "line": 8886}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 8888}, "start": {"column": 20, "line": 8888}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 8888}, "start": {"column": 20, "line": 8888}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 8905}, "start": {"column": 31, "line": 8905}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 8912}, "start": {"column": 20, "line": 8912}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 8912}, "start": {"column": 38, "line": 8912}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 8916}, "start": {"column": 36, "line": 8916}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 24, "line": 8920}, "start": {"column": 23, "line": 8920}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 24, "line": 8920}, "start": {"column": 23, "line": 8920}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 8920}, "start": {"column": 34, "line": 8920}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 8922}, "start": {"column": 34, "line": 8922}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 8925}, "start": {"column": 24, "line": 8925}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 8925}, "start": {"column": 42, "line": 8925}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 8929}, "start": {"column": 36, "line": 8929}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 27, "line": 8932}, "start": {"column": 26, "line": 8932}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 27, "line": 8932}, "start": {"column": 26, "line": 8932}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 38, "line": 8932}, "start": {"column": 37, "line": 8932}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 9021}, "start": {"column": 18, "line": 9021}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 9034}, "start": {"column": 38, "line": 9034}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 9050}, "start": {"column": 42, "line": 9050}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 49, "line": 9070}, "start": {"column": 47, "line": 9070}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 49, "line": 9070}, "start": {"column": 47, "line": 9070}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 24, "line": 9072}, "start": {"column": 23, "line": 9072}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 9081}, "start": {"column": 15, "line": 9081}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 9081}, "start": {"column": 15, "line": 9081}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 54, "line": 9083}, "start": {"column": 53, "line": 9083}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 9093}, "start": {"column": 27, "line": 9093}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 9094}, "start": {"column": 14, "line": 9094}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 9094}, "start": {"column": 14, "line": 9094}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 9095}, "start": {"column": 14, "line": 9095}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 9095}, "start": {"column": 14, "line": 9095}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 32, "line": 9102}, "start": {"column": 31, "line": 9102}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 32, "line": 9102}, "start": {"column": 31, "line": 9102}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 52, "line": 9116}, "start": {"column": 51, "line": 9116}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 9141}, "start": {"column": 35, "line": 9141}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9162}, "start": {"column": 10, "line": 9162}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 9166}, "start": {"column": 27, "line": 9166}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 9183}, "start": {"column": 13, "line": 9183}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 9188}, "start": {"column": 16, "line": 9188}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 9212}, "start": {"column": 14, "line": 9212}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 9217}, "start": {"column": 16, "line": 9217}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 9230}, "start": {"column": 26, "line": 9230}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 9230}, "start": {"column": 52, "line": 9230}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 9243}, "start": {"column": 27, "line": 9243}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9244}, "start": {"column": 15, "line": 9244}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 9251}, "start": {"column": 25, "line": 9251}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 9260}, "start": {"column": 30, "line": 9260}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 18, "line": 9281}, "start": {"column": 17, "line": 9281}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 9281}, "start": {"column": 26, "line": 9281}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9282}, "start": {"column": 15, "line": 9282}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 8, "line": 9333}, "start": {"column": 7, "line": 9333}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 24, "line": 9334}, "start": {"column": 23, "line": 9334}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 36, "line": 9334}, "start": {"column": 35, "line": 9334}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 41, "line": 9334}, "start": {"column": 40, "line": 9334}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 45, "line": 9336}, "start": {"column": 44, "line": 9336}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 9439}, "start": {"column": 19, "line": 9439}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 9441}, "start": {"column": 20, "line": 9441}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 9443}, "start": {"column": 16, "line": 9443}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 9557}, "start": {"column": 15, "line": 9557}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 9557}, "start": {"column": 15, "line": 9557}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9664}, "start": {"column": 10, "line": 9664}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 9681}, "start": {"column": 36, "line": 9681}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 9683}, "start": {"column": 9, "line": 9683}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9689}, "start": {"column": 10, "line": 9689}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9707}, "start": {"column": 24, "line": 9707}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 9708}, "start": {"column": 10, "line": 9708}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9708}, "start": {"column": 23, "line": 9708}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9729}, "start": {"column": 24, "line": 9729}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 9730}, "start": {"column": 10, "line": 9730}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9730}, "start": {"column": 23, "line": 9730}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 9734}, "start": {"column": 19, "line": 9734}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9792}, "start": {"column": 24, "line": 9792}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 9793}, "start": {"column": 10, "line": 9793}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9793}, "start": {"column": 23, "line": 9793}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 28, "line": 9796}, "start": {"column": 27, "line": 9796}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 28, "line": 9796}, "start": {"column": 27, "line": 9796}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 23, "line": 9797}, "start": {"column": 22, "line": 9797}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 27, "line": 9797}, "start": {"column": 26, "line": 9797}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 27, "line": 9797}, "start": {"column": 26, "line": 9797}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 27, "line": 9803}, "start": {"column": 25, "line": 9803}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 27, "line": 9803}, "start": {"column": 25, "line": 9803}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 9803}, "start": {"column": 36, "line": 9803}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 27, "line": 9806}, "start": {"column": 25, "line": 9806}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 27, "line": 9806}, "start": {"column": 25, "line": 9806}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 9806}, "start": {"column": 36, "line": 9806}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 36, "line": 9808}, "start": {"column": 35, "line": 9808}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9825}, "start": {"column": 24, "line": 9825}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 9826}, "start": {"column": 10, "line": 9826}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9826}, "start": {"column": 23, "line": 9826}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 9833}, "start": {"column": 32, "line": 9833}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 23, "line": 9841}, "start": {"column": 22, "line": 9841}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 23, "line": 9841}, "start": {"column": 22, "line": 9841}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 9842}, "start": {"column": 13, "line": 9842}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 23, "line": 9842}, "start": {"column": 22, "line": 9842}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 23, "line": 9842}, "start": {"column": 22, "line": 9842}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 9851}, "start": {"column": 24, "line": 9851}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 9852}, "start": {"column": 10, "line": 9852}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9852}, "start": {"column": 23, "line": 9852}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 9854}, "start": {"column": 28, "line": 9854}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 9855}, "start": {"column": 18, "line": 9855}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 9855}, "start": {"column": 18, "line": 9855}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 9857}, "start": {"column": 18, "line": 9857}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 28, "line": 9857}, "start": {"column": 27, "line": 9857}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 28, "line": 9857}, "start": {"column": 27, "line": 9857}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 9866}, "start": {"column": 15, "line": 9866}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 9866}, "start": {"column": 15, "line": 9866}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 40, "line": 9866}, "start": {"column": 39, "line": 9866}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 40, "line": 9866}, "start": {"column": 39, "line": 9866}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 9876}, "start": {"column": 19, "line": 9876}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9878}, "start": {"column": 10, "line": 9878}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 9879}, "start": {"column": 23, "line": 9879}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 23, "line": 9885}, "start": {"column": 22, "line": 9885}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 23, "line": 9885}, "start": {"column": 22, "line": 9885}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 38, "line": 9885}, "start": {"column": 37, "line": 9885}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 38, "line": 9885}, "start": {"column": 37, "line": 9885}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 10, "line": 9887}, "start": {"column": 8, "line": 9887}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 9892}, "start": {"column": 18, "line": 9892}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 9894}, "start": {"column": 9, "line": 9894}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 9895}, "start": {"column": 29, "line": 9895}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 9902}, "start": {"column": 19, "line": 9902}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 9905}, "start": {"column": 19, "line": 9905}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 9921}, "start": {"column": 20, "line": 9921}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 19, "line": 9924}, "start": {"column": 9, "line": 9924}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 9932}, "start": {"column": 20, "line": 9932}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 9932}, "start": {"column": 20, "line": 9932}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 10040}, "start": {"column": 20, "line": 10040}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 10040}, "start": {"column": 20, "line": 10040}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 10040}, "start": {"column": 31, "line": 10040}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 10043}, "start": {"column": 20, "line": 10043}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 10043}, "start": {"column": 20, "line": 10043}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 10043}, "start": {"column": 31, "line": 10043}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 10072}, "start": {"column": 43, "line": 10072}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 10148}, "start": {"column": 36, "line": 10148}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 10163}, "start": {"column": 21, "line": 10163}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 29, "line": 10170}, "start": {"column": 28, "line": 10170}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 29, "line": 10170}, "start": {"column": 28, "line": 10170}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 10191}, "start": {"column": 18, "line": 10191}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 10191}, "start": {"column": 18, "line": 10191}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 10191}, "start": {"column": 29, "line": 10191}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 10194}, "start": {"column": 18, "line": 10194}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 10194}, "start": {"column": 18, "line": 10194}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 10194}, "start": {"column": 29, "line": 10194}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 10247}, "start": {"column": 18, "line": 10247}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 10247}, "start": {"column": 18, "line": 10247}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 10249}, "start": {"column": 31, "line": 10249}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 32, "line": 10259}, "start": {"column": 31, "line": 10259}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 32, "line": 10259}, "start": {"column": 31, "line": 10259}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 10264}, "start": {"column": 24, "line": 10264}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 33, "line": 10264}, "start": {"column": 32, "line": 10264}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 33, "line": 10264}, "start": {"column": 32, "line": 10264}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 44, "line": 10264}, "start": {"column": 41, "line": 10264}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 10276}, "start": {"column": 25, "line": 10276}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 10276}, "start": {"column": 25, "line": 10276}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 23, "line": 10283}, "start": {"column": 21, "line": 10283}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 23, "line": 10283}, "start": {"column": 21, "line": 10283}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 10391}, "start": {"column": 20, "line": 10391}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 10393}, "start": {"column": 12, "line": 10393}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 10393}, "start": {"column": 12, "line": 10393}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 32, "line": 10395}, "start": {"column": 31, "line": 10395}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 28, "line": 10509}, "start": {"column": 26, "line": 10509}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 28, "line": 10509}, "start": {"column": 26, "line": 10509}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 5, "line": 10510}, "start": {"column": 2, "line": 10510}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 10535}, "start": {"column": 16, "line": 10535}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 10537}, "start": {"column": 12, "line": 10537}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 10537}, "start": {"column": 12, "line": 10537}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 10555}, "start": {"column": 20, "line": 10555}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 30, "line": 10555}, "start": {"column": 28, "line": 10555}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 30, "line": 10555}, "start": {"column": 28, "line": 10555}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 10557}, "start": {"column": 24, "line": 10557}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 10557}, "start": {"column": 24, "line": 10557}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 10563}, "start": {"column": 20, "line": 10563}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 30, "line": 10563}, "start": {"column": 28, "line": 10563}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 30, "line": 10563}, "start": {"column": 28, "line": 10563}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 10565}, "start": {"column": 24, "line": 10565}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 10565}, "start": {"column": 24, "line": 10565}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 10575}, "start": {"column": 15, "line": 10575}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 7, "line": 10576}, "start": {"column": 4, "line": 10576}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 10577}, "start": {"column": 16, "line": 10577}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 10577}, "start": {"column": 16, "line": 10577}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 10803}, "start": {"column": 21, "line": 10803}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 10803}, "start": {"column": 21, "line": 10803}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 10803}, "start": {"column": 39, "line": 10803}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 10840}, "start": {"column": 11, "line": 10840}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 52, "line": 10879}, "start": {"column": 51, "line": 10879}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 52, "line": 10879}, "start": {"column": 51, "line": 10879}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 10897}, "start": {"column": 22, "line": 10897}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 41, "line": 10897}, "start": {"column": 39, "line": 10897}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 10911}, "start": {"column": 15, "line": 10911}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 10911}, "start": {"column": 15, "line": 10911}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 10915}, "start": {"column": 25, "line": 10915}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 10915}, "start": {"column": 25, "line": 10915}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 38, "line": 10915}, "start": {"column": 36, "line": 10915}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 16, "line": 10928}, "start": {"column": 14, "line": 10928}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 16, "line": 10928}, "start": {"column": 14, "line": 10928}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 10949}, "start": {"column": 29, "line": 10949}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 35, "line": 10950}, "start": {"column": 34, "line": 10950}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 10952}, "start": {"column": 19, "line": 10952}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 10954}, "start": {"column": 20, "line": 10954}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 10954}, "start": {"column": 20, "line": 10954}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 46, "line": 10956}, "start": {"column": 45, "line": 10956}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 10957}, "start": {"column": 30, "line": 10957}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 10978}, "start": {"column": 20, "line": 10978}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 10983}, "start": {"column": 21, "line": 10983}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 10988}, "start": {"column": 24, "line": 10988}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}], "source": "#define STDC_HEADERS 1\n#define HAVE_STRING_H 1\n#define HAVE_VPRINTF 1\n#define HAVE_BCOPY 1\n#define HAVE_MEMCPY 1\n#define HAVE_ALLOCA_H 1\n\n/*  GNU SED, a batch stream editor.\n    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2, or (at your option)\n    any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    \n/* All The occurences of argv[0] are changed to myname to remove nondeterminism\nby Amit Goel on August 30 2001 */\n\n#ifdef __STDC__\n#define VOID void\n#else\n#define VOID char\n#endif\n\n\n#define _GNU_SOURCE\n#include <ctype.h>\n#ifndef isblank\n#define isblank(c) ((c) == ' ' || (c) == '\\t')\n#endif\n#include <stdio.h>\n\n#undef stderr\n#define stderr stdout\n\n#include <sys/types.h>\n#include \"rx.h\"\n#include \"getopt.h\"\n#if defined(STDC_HEADERS)\n#include <stdlib.h>\n#endif\n#if HAVE_STRING_H || defined(STDC_HEADERS)\n#include <string.h>\n#ifndef bzero\n#define bzero(s, n)\tmemset ((s), 0, (n))\n#endif\n#if !defined(STDC_HEADERS)\n#include <memory.h>\n#endif\n#else\n#include <strings.h>\n#endif\n\n#ifdef RX_MEMDBUG\n#include <malloc.h>\n#endif\n\n#include <errno.h>\n\n#ifndef HAVE_BCOPY\n#ifdef HAVE_MEMCPY\n#define bcopy(FROM,TO,LEN)  memcpy(TO,FROM,LEN)\n#else\nvoid\nbcopy (from, to, len)\n     char *from;\n     char *to;\n     int len;\n{\n  if (from < to)\n    {\n      from += len - 1;\n      to += len - 1;\n      while (len--)\n\t*to-- = *from--;\n    }\n  else\n    while (len--)\n      *to++ = *from++;\n}\n\n#endif\n#endif\n\nchar *version_string = \"GNU sed version 2.05\";\n\n/* Struct vector is used to describe a chunk of a compiled sed program.  \n * There is one vector for the main program, and one for each { } pair,\n * and one for the entire program.  For {} blocks, RETURN_[VI] tells where\n * to continue execution after this VECTOR.\n */\n\nstruct vector\n{\n  struct sed_cmd *v;\n  int v_length;\n  int v_allocated;\n  struct vector *return_v;\n  int return_i;\n};\n\n\n/* Goto structure is used to hold both GOTO's and labels.  There are two\n * separate lists, one of goto's, called 'jumps', and one of labels, called\n * 'labels'.\n * the V element points to the descriptor for the program-chunk in which the\n * goto was encountered.\n * the v_index element counts which element of the vector actually IS the\n * goto/label.  The first element of the vector is zero.\n * the NAME element is the null-terminated name of the label.\n * next is the next goto/label in the list. \n */\n\nstruct sed_label\n{\n  struct vector *v;\n  int v_index;\n  char *name;\n  struct sed_label *next;\n};\n\n/* ADDR_TYPE is zero for a null address,\n *  one if addr_number is valid, or\n * two if addr_regex is valid,\n * three, if the address is '$'\n * Other values are undefined.\n */\n\nenum addr_types\n{\n  addr_is_null = 0,\n  addr_is_num = 1,\n  addr_is_regex = 2,\n  addr_is_last = 3,\n  addr_is_mod = 4\n};\n\nstruct addr\n{\n  int addr_type;\n  struct re_pattern_buffer *addr_regex;\n  int addr_number;\n  int modulo, offset;\n};\n\n\n/* Aflags:  If the low order bit is set, a1 has been\n * matched; apply this command until a2 matches.\n * If the next bit is set, apply this command to all\n * lines that DON'T match the address(es).\n */\n\n#define A1_MATCHED_BIT\t01\n#define ADDR_BANG_BIT\t02\n\nstruct sed_cmd\n{\n  struct addr a1, a2;\n  int aflags;\n  \n  char cmd;\n  \n  union\n    {\n      /* This structure is used for a, i, and c commands */\n      struct\n\t{\n\t  char *text;\n\t  int text_len;\n\t}\n      cmd_txt;\n      \n      /* This is used for b and t commands */\n      struct sed_cmd *label;\n      \n      /* This for r and w commands */\n      FILE *io_file;\n      \n      /* This for the hairy s command */\n      /* For the flags var:\n\t low order bit means the 'g' option was given,\n\t next bit means the 'p' option was given,\n\t and the next bit means a 'w' option was given,\n\t and wio_file contains the file to write to. */\n      \n#define S_GLOBAL_BIT\t01\n#define S_PRINT_BIT\t02\n#define S_WRITE_BIT\t04\n#define S_NUM_BIT\t010\n      \n      struct\n\t{\n\t  struct re_pattern_buffer *regx;\n\t  char *replacement;\n\t  int replace_length;\n\t  int flags;\n\t  int numb;\n\t  FILE *wio_file;\n\t}\n      cmd_regex;\n      \n      /* This for the y command */\n      unsigned char *translate;\n      \n      /* For { */\n      struct vector *sub;\n      \n      /* for t and b */\n      struct sed_label *jump;\n    } x;\n};\n\n/* Sed operates a line at a time. */\nstruct line\n{\n  char *text;\t\t\t/* Pointer to line allocated by malloc. */\n  int length;\t\t\t/* Length of text. */\n  int alloc;\t\t\t/* Allocated space for text. */\n};\n\n/* This structure holds information about files opend by the 'r', 'w',\n   and 's///w' commands.  In paticular, it holds the FILE pointers to\n   use, the file's name. */\n\n#define NUM_FPS\t32\nstruct\n  {\n    FILE *for_read;\n    FILE *for_write;\n    char *name;\n  }\n\nfile_ptrs[NUM_FPS];\n\n\n#if defined(__STDC__)\n# define P_(s) s\n#else\n# define P_(s) ()\n#endif\n\nvoid close_files ();\nvoid panic P_ ((char *str,...));\nchar *__fp_name P_ ((FILE * fp));\nFILE *ck_fopen P_ ((char *name, char *mode));\nvoid ck_fwrite P_ ((char *ptr, int size, int nmemb, FILE * stream));\nvoid ck_fclose P_ ((FILE * stream));\nVOID *ck_malloc P_ ((int size));\nVOID *ck_realloc P_ ((VOID * ptr, int size));\nchar *ck_strdup P_ ((char *str));\nVOID *init_buffer P_ ((void));\nvoid flush_buffer P_ ((VOID * bb));\nint size_buffer P_ ((VOID * b));\nvoid add_buffer P_ ((VOID * bb, char *p, int n));\nvoid add1_buffer P_ ((VOID * bb, int ch));\nchar *get_buffer P_ ((VOID * bb));\n\nvoid compile_string P_ ((char *str));\nvoid compile_file P_ ((char *str));\nstruct vector *compile_program P_ ((struct vector * vector, int));\nvoid bad_prog P_ ((char *why));\nint inchar P_ ((void));\nvoid savchar P_ ((int ch));\nint compile_address P_ ((struct addr * addr));\nchar * last_regex_string = 0;\nvoid buffer_regex  P_ ((int slash));\nvoid compile_regex P_ ((void));\nstruct sed_label *setup_jump P_ ((struct sed_label * list, struct sed_cmd * cmd, struct vector * vec));\nFILE *compile_filename P_ ((int readit));\nvoid read_file P_ ((char *name));\nvoid execute_program P_ ((struct vector * vec));\nint match_address P_ ((struct addr * addr));\nint read_pattern_space P_ ((void));\nvoid append_pattern_space P_ ((void));\nvoid line_copy P_ ((struct line * from, struct line * to));\nvoid line_append P_ ((struct line * from, struct line * to));\nvoid str_append P_ ((struct line * to, char *string, int length));\nvoid usage P_ ((int));\n\nextern char *myname;\n\n/* If set, don't write out the line unless explictly told to */\nint no_default_output = 0;\n\n/* Current input line # */\nint input_line_number = 0;\n\n/* Are we on the last input file? */\nint last_input_file = 0;\n\n/* Have we hit EOF on the last input file?  This is used to decide if we\n   have hit the '$' address yet. */\nint input_EOF = 0;\n\n/* non-zero if a quit command has been executed. */\nint quit_cmd = 0;\n\n/* Have we done any replacements lately?  This is used by the 't' command. */\nint replaced = 0;\n\n/* How many '{'s are we executing at the moment */\nint program_depth = 0;\n\n/* The complete compiled SED program that we are going to run */\nstruct vector *the_program = 0;\n\n/* information about labels and jumps-to-labels.  This is used to do\n   the required backpatching after we have compiled all the scripts. */\nstruct sed_label *jumps = 0;\nstruct sed_label *labels = 0;\n\n/* The 'current' input line. */\nstruct line line;\n\n/* An input line that's been stored by later use by the program */\nstruct line hold;\n\n/* A 'line' to append to the current line when it comes time to write it out */\nstruct line append;\n\n\n/* When we're reading a script command from a string, 'prog_start' and\n   'prog_end' point to the beginning and end of the string.  This\n   would allow us to compile script strings that contain nulls, except\n   that script strings are only read from the command line, which is\n   null-terminated */\nunsigned char *prog_start;\nunsigned char *prog_end;\n\n/* When we're reading a script command from a string, 'prog_cur' points\n   to the current character in the string */\nunsigned char *prog_cur;\n\n/* This is the name of the current script file.\n   It is used for error messages. */\nchar *prog_name;\n\n/* This is the current script file.  If it is zero, we are reading\n   from a string stored in 'prog_start' instead.  If both 'prog_file'\n   and 'prog_start' are zero, we're in trouble! */\nFILE *prog_file;\n\n/* this is the number of the current script line that we're compiling.  It is\n   used to give out useful and informative error messages. */\nint prog_line = 1;\n\n/* This is the file pointer that we're currently reading data from.  It may\n   be stdin */\nFILE *input_file;\n\n/* If this variable is non-zero at exit, one or more of the input\n   files couldn't be opened. */\n\nint bad_input = 0;\n\n/* 'an empty regular expression is equivalent to the last regular\n   expression read' so we have to keep track of the last regex used.\n   Here's where we store a pointer to it (it is only malloc()'d once) */\nstruct re_pattern_buffer *last_regex;\n\n/* Various error messages we may want to print */\nstatic char ONE_ADDR[] = \"Command only uses one address\";\nstatic char NO_ADDR[] = \"Command doesn't take any addresses\";\nstatic char LINE_JUNK[] = \"Extra characters after command\";\nstatic char BAD_EOF[] = \"Unexpected End-of-file\";\nstatic char NO_REGEX[] = \"No previous regular expression\";\nstatic char NO_COMMAND[] = \"Missing command\";\n\nstatic struct option longopts[] =\n{\n  {\"expression\", 1, NULL, 'e'},\n  {\"file\", 1, NULL, 'f'},\n  {\"quiet\", 0, NULL, 'n'},\n  {\"silent\", 0, NULL, 'n'},\n  {\"version\", 0, NULL, 'V'},\n  {\"help\", 0, NULL, 'h'},\n  {NULL, 0, NULL, 0}\n};\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int opt;\n  char *e_strings = NULL;\n  int compiled = 0;\n  struct sed_label *go, *lbl;\n\n  /* see regex.h */\n  re_set_syntax (RE_SYNTAX_POSIX_BASIC);\n  rx_cache_bound = 4096;\t/* Consume memory rampantly. */\n /* Commented by Amit Goel on 30th August 2001 to remove Nondeterminism */ \n /* myname = argv[0]; */\n /* Added By Amit Goel 30th August 2001 */\n myname = \"Executable\";\n  while ((opt = getopt_long (argc, argv, \"hne:f:V\", longopts, (int *) 0))\n\t != EOF)\n    {\n      switch (opt)\n\t{\n\tcase 'n':\n\t  no_default_output = 1;\n\t  break;\n\tcase 'e':\n\t  if (e_strings == NULL)\n\t    {\n\t      e_strings = ck_malloc (strlen (optarg) + 2);\n\t      strcpy (e_strings, optarg);\n\t    }\n\t  else\n\t    {\n\t      e_strings = ck_realloc (e_strings, strlen (e_strings) + strlen (optarg) + 2);\n\t      strcat (e_strings, optarg);\n\t    }\n\t  strcat (e_strings, \"\\n\");\n\t  compiled = 1;\n\t  break;\n\tcase 'f':\n\t  if (e_strings)\n\t    {\n\t      compile_string (e_strings);\n\t      free (e_strings);\n\t      e_strings = 0;\n\t    }\n\t  compile_file (optarg);\n\t  compiled = 1;\n\t  break;\n\tcase 'V':\n\t  fprintf (stderr, \"%s\\n\", version_string);\n\t  exit (0);\n\t  break;\n\tcase 'h':\n\t  usage (0);\n\t  break;\n\tdefault:\n\t  usage (4);\n\t  break;\n\t}\n    }\n  if (e_strings)\n    {\n      compile_string (e_strings);\n      free (e_strings);\n    }\n  if (!compiled)\n    {\n      if (optind == argc)\n\tusage (4);\n      compile_string (argv[optind++]);\n    }\n\n  for (go = jumps; go; go = go->next)\n    {\n      for (lbl = labels; lbl; lbl = lbl->next)\n\tif (!strcmp (lbl->name, go->name))\n\t  break;\n      if (*go->name && !lbl)\n\tpanic (\"Can't find label for jump to '%s'\", go->name);\n      go->v->v[go->v_index].x.jump = lbl;\n    }\n\n  line.length = 0;\n  line.alloc = 50;\n  line.text = ck_malloc (50);\n\n  append.length = 0;\n  append.alloc = 50;\n  append.text = ck_malloc (50);\n\n  hold.length = 1;\n  hold.alloc = 50;\n  hold.text = ck_malloc (50);\n  hold.text[0] = '\\n';\n\n  if (argc <= optind)\n    {\n      last_input_file++;\n      read_file (\"-\");\n    }\n  else\n    while (optind < argc)\n      {\n\tif (optind == argc - 1)\n\t  last_input_file++;\n\tread_file (argv[optind]);\n\toptind++;\n\tif (quit_cmd)\n\t  break;\n      }\n  close_files ();\n  if (bad_input)\n    exit (2);\n  exit (0);\n}\n\nvoid\nclose_files ()\n{\n  int nf;\n\n  for (nf = 0; nf < NUM_FPS; nf++)\n    {\n      if (file_ptrs[nf].for_write)\n\tfclose (file_ptrs[nf].for_write);\n      if (file_ptrs[nf].for_read)\n\tfclose (file_ptrs[nf].for_read);\n    }\n}\n\n/* 'str' is a string (from the command line) that contains a sed command.\n   Compile the command, and add it to the end of 'the_program' */\nvoid\ncompile_string (str)\n     char *str;\n{\n  prog_file = 0;\n  prog_line = 0;\n  prog_start = prog_cur = (unsigned char *)str;\n  prog_end = (unsigned char *)str + strlen (str);\n  the_program = compile_program (the_program, prog_line);\n}\n\n/* 'str' is the name of a file containing sed commands.  Read them in\n   and add them to the end of 'the_program' */\nvoid\ncompile_file (str)\n     char *str;\n{\n  int ch;\n\n  prog_start = prog_cur = prog_end = 0;\n  prog_name = str;\n  prog_line = 1;\n  if (str[0] == '-' && str[1] == '\\0')\n    prog_file = stdin;\n  else\n    prog_file = ck_fopen (str, \"r\");\n  ch = getc (prog_file);\n  if (ch == '#')\n    {\n      ch = getc (prog_file);\n      if (ch == 'n')\n\tno_default_output++;\n      while (ch != EOF && ch != '\\n')\n\t{\n\t  ch = getc (prog_file);\n\t  if (ch == '\\\\')\n\t    ch = getc (prog_file);\n\t}\n      ++prog_line;\n    }\n  else if (ch != EOF)\n    ungetc (ch, prog_file);\n  the_program = compile_program (the_program, prog_line);\n}\n\n#define MORE_CMDS 40\n\n/* Read a program (or a subprogram within '{' '}' pairs) in and store\n   the compiled form in *'vector'  Return a pointer to the new vector.  */\nstruct vector *\ncompile_program (vector, open_line)\n     struct vector *vector;\n     int open_line;\n{\n  struct sed_cmd *cur_cmd;\n  int ch = 0;\n  int pch;\n  int slash;\n  VOID *b;\n  unsigned char *string;\n  int num;\n\n  if (!vector)\n    {\n      vector = (struct vector *) ck_malloc (sizeof (struct vector));\n      vector->v = (struct sed_cmd *) ck_malloc (MORE_CMDS * sizeof (struct sed_cmd));\n      vector->v_allocated = MORE_CMDS;\n      vector->v_length = 0;\n      vector->return_v = 0;\n      vector->return_i = 0;\n    }\n  for (;;)\n    {\n    skip_comment:\n      do\n\t{\n\t  pch = ch;\n\t  ch = inchar ();\n\t  if ((pch == '\\\\') && (ch == '\\n'))\n\t    ch = inchar ();\n\t}\n      while (ch != EOF && (isblank (ch) || ch == '\\n' || ch == ';'));\n      if (ch == EOF)\n\tbreak;\n      savchar (ch);\n\n      if (vector->v_length == vector->v_allocated)\n\t{\n\t  vector->v = ((struct sed_cmd *)\n\t\t       ck_realloc ((VOID *) vector->v,\n\t\t\t\t   ((vector->v_length + MORE_CMDS)\n\t\t\t\t    * sizeof (struct sed_cmd))));\n\t  vector->v_allocated += MORE_CMDS;\n\t}\n      cur_cmd = vector->v + vector->v_length;\n      vector->v_length++;\n\n      cur_cmd->a1.addr_type = 0;\n      cur_cmd->a2.addr_type = 0;\n      cur_cmd->aflags = 0;\n      cur_cmd->cmd = 0;\n\n      if (compile_address (&(cur_cmd->a1)))\n\t{\n\t  ch = inchar ();\n\t  if (ch == ',')\n\t    {\n\t      do\n\t\tch = inchar ();\n\t      while (ch != EOF && isblank (ch));\n\t      savchar (ch);\n\t      if (compile_address (&(cur_cmd->a2)))\n\t\t;\n\t      else\n\t\tbad_prog (\"Unexpected ','\");\n\t    }\n\t  else\n\t    savchar (ch);\n\t}\n      if (cur_cmd->a1.addr_type == addr_is_num\n\t  && cur_cmd->a2.addr_type == addr_is_num\n\t  && cur_cmd->a2.addr_number < cur_cmd->a1.addr_number)\n\tcur_cmd->a2.addr_number = cur_cmd->a1.addr_number;\n\n      ch = inchar ();\n      if (ch == EOF)\n\tbad_prog (NO_COMMAND);\n    new_cmd:\n      switch (ch)\n\t{\n\tcase '#':\n\t  if (cur_cmd->a1.addr_type != 0)\n\t    bad_prog (NO_ADDR);\n\t  do\n\t    {\n\t      ch = inchar ();\n\t      if (ch == '\\\\')\n\t\tch = inchar ();\n\t    }\n\t  while (ch != EOF && ch != '\\n');\n\t  vector->v_length--;\n\t  goto skip_comment;\n\tcase '!':\n\t  if (cur_cmd->aflags & ADDR_BANG_BIT)\n\t    bad_prog (\"Multiple '!'s\");\n\t  cur_cmd->aflags |= ADDR_BANG_BIT;\n\t  do\n\t    ch = inchar ();\n\t  while (ch != EOF && isblank (ch));\n\t  if (ch == EOF)\n\t    bad_prog (NO_COMMAND);\n#if 0\n\t  savchar (ch);\n#endif\n\t  goto new_cmd;\n\tcase 'a':\n\tcase 'i':\n\t  if (cur_cmd->a2.addr_type != 0)\n\t    bad_prog (ONE_ADDR);\n\t  /* Fall Through */\n\tcase 'c':\n\t  cur_cmd->cmd = ch;\n\t  if (inchar () != '\\\\' || inchar () != '\\n')\n\t    bad_prog (LINE_JUNK);\n\t  b = init_buffer ();\n\t  while ((ch = inchar ()) != EOF && ch != '\\n')\n\t    {\n\t      if (ch == '\\\\')\n\t\tch = inchar ();\n\t      add1_buffer (b, ch);\n\t    }\n\t  if (ch != EOF)\n\t    add1_buffer (b, ch);\n\t  num = size_buffer (b);\n\t  string = (unsigned char *) ck_malloc (num);\n\t  bcopy (get_buffer (b), string, num);\n\t  flush_buffer (b);\n\t  cur_cmd->x.cmd_txt.text_len = num;\n\t  cur_cmd->x.cmd_txt.text = (char *) string;\n\t  break;\n\tcase '{':\n\t  cur_cmd->cmd = ch;\n\t  program_depth++;\n#if 0\n\t  while ((ch = inchar ()) != EOF && ch != '\\n')\n\t    if (!isblank (ch))\n\t      bad_prog (LINE_JUNK);\n#endif\n\t  cur_cmd->x.sub = compile_program ((struct vector *) 0, prog_line);\n\t  /* FOO JF is this the right thing to do?\n\t\t\t   almost.  don't forget a return addr.  -t */\n\t  cur_cmd->x.sub->return_v = vector;\n\t  cur_cmd->x.sub->return_i = vector->v_length - 1;\n\t  break;\n\tcase '}':\n\t  if (!program_depth)\n\t    bad_prog (\"Unexpected '}'\");\n\t  --program_depth;\n\t  /* a return insn for subprograms -t */\n\t  cur_cmd->cmd = ch;\n\t  if (cur_cmd->a1.addr_type != 0)\n\t    bad_prog (\"} doesn't want any addresses\");\n\t  while ((ch = inchar ()) != EOF && ch != '\\n' && ch != ';')\n\t    if (!isblank (ch))\n\t      bad_prog (LINE_JUNK);\n\t  return vector;\n\tcase ':':\n\t  cur_cmd->cmd = ch;\n\t  if (cur_cmd->a1.addr_type != 0)\n\t    bad_prog (\": doesn't want any addresses\");\n\t  labels = setup_jump (labels, cur_cmd, vector);\n\t  break;\n\tcase 'b':\n\tcase 't':\n\t  cur_cmd->cmd = ch;\n\t  jumps = setup_jump (jumps, cur_cmd, vector);\n\t  break;\n\tcase 'q':\n\tcase '=':\n\t  if (cur_cmd->a2.addr_type)\n\t    bad_prog (ONE_ADDR);\n\t  /* Fall Through */\n\tcase 'd':\n\tcase 'D':\n\tcase 'g':\n\tcase 'G':\n\tcase 'h':\n\tcase 'H':\n\tcase 'l':\n\tcase 'n':\n\tcase 'N':\n\tcase 'p':\n\tcase 'P':\n\tcase 'x':\n\t  cur_cmd->cmd = ch;\n\t  do\n\t    ch = inchar ();\n\t  while (ch != EOF && isblank (ch) && ch != '\\n' && ch != ';');\n\t  if (ch != '\\n' && ch != ';' && ch != EOF)\n\t    bad_prog (LINE_JUNK);\n\t  break;\n\n\tcase 'r':\n\t  if (cur_cmd->a2.addr_type != 0)\n\t    bad_prog (ONE_ADDR);\n\t  /* FALL THROUGH */\n\tcase 'w':\n\t  cur_cmd->cmd = ch;\n\t  cur_cmd->x.io_file = compile_filename (ch == 'r');\n\t  break;\n\n\tcase 's':\n\t  cur_cmd->cmd = ch;\n\t  slash = inchar ();\n\t  buffer_regex (slash);\n\t  compile_regex ();\n\n\t  cur_cmd->x.cmd_regex.regx = last_regex;\n\n\t  b = init_buffer ();\n\t  while (((ch = inchar ()) != EOF) && (ch != slash) && (ch != '\\n'))\n\t    {\n\t      if (ch == '\\\\')\n\t\t{\n\t\t  int ci;\n\n\t\t  ci = inchar ();\n\t\t  if (ci != EOF)\n\t\t    {\n\t\t      if (ci != '\\n')\n\t\t\tadd1_buffer (b, ch);\n\t\t      add1_buffer (b, ci);\n\t\t    }\n\t\t}\n\t      else\n\t\tadd1_buffer (b, ch);\n\t    }\n\t  if (ch != slash)\n\t    {\n\t      if (ch == '\\n' && prog_line > 1)\n\t\t--prog_line;\n\t      bad_prog (\"Unterminated `s' command\");\n\t    }\n\t  cur_cmd->x.cmd_regex.replace_length = size_buffer (b);\n\t  cur_cmd->x.cmd_regex.replacement = ck_malloc (cur_cmd->x.cmd_regex.replace_length);\n\t  bcopy (get_buffer (b), cur_cmd->x.cmd_regex.replacement, cur_cmd->x.cmd_regex.replace_length);\n\t  flush_buffer (b);\n\n\t  cur_cmd->x.cmd_regex.flags = 0;\n\t  cur_cmd->x.cmd_regex.numb = 0;\n\n\t  if (ch == EOF)\n\t    break;\n\t  do\n\t    {\n\t      ch = inchar ();\n\t      switch (ch)\n\t\t{\n\t\tcase 'p':\n\t\t  if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)\n\t\t    bad_prog (\"multiple 'p' options to 's' command\");\n\t\t  cur_cmd->x.cmd_regex.flags |= S_PRINT_BIT;\n\t\t  break;\n\t\tcase 'g':\n\t\t  if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)\n\t\t    cur_cmd->x.cmd_regex.flags &= ~S_NUM_BIT;\n\t\t  if (cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT)\n\t\t    bad_prog (\"multiple 'g' options to 's' command\");\n\t\t  cur_cmd->x.cmd_regex.flags |= S_GLOBAL_BIT;\n\t\t  break;\n\t\tcase 'w':\n\t\t  cur_cmd->x.cmd_regex.flags |= S_WRITE_BIT;\n\t\t  cur_cmd->x.cmd_regex.wio_file = compile_filename (0);\n\t\t  ch = '\\n';\n\t\t  break;\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t  if (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)\n\t\t    bad_prog (\"multiple number options to 's' command\");\n\t\t  if ((cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT) == 0)\n\t\t    cur_cmd->x.cmd_regex.flags |= S_NUM_BIT;\n\t\t  num = 0;\n\t\t  while (isdigit (ch))\n\t\t    {\n\t\t      num = num * 10 + ch - '0';\n\t\t      ch = inchar ();\n\t\t    }\n\t\t  savchar (ch);\n\t\t  cur_cmd->x.cmd_regex.numb = num;\n\t\t  break;\n\t\tcase '\\n':\n\t\tcase ';':\n\t\tcase EOF:\n\t\t  break;\n\t\tdefault:\n\t\t  bad_prog (\"Unknown option to 's'\");\n\t\t  break;\n\t\t}\n\t    }\n\t  while (ch != EOF && ch != '\\n' && ch != ';');\n\t  if (ch == EOF)\n\t    break;\n\t  break;\n\n\tcase 'y':\n\t  cur_cmd->cmd = ch;\n\t  string = (unsigned char *) ck_malloc (256);\n\t  for (num = 0; num < 256; num++)\n\t    string[num] = num;\n\t  b = init_buffer ();\n\t  slash = inchar ();\n\t  while ((ch = inchar ()) != EOF && ch != slash)\n\t    add1_buffer (b, ch);\n\t  cur_cmd->x.translate = string;\n\t  string = (unsigned char *) get_buffer (b);\n\t  for (num = size_buffer (b); num; --num)\n\t    {\n\t      ch = inchar ();\n\t      if (ch == EOF)\n\t\tbad_prog (BAD_EOF);\n\t      if (ch == slash)\n\t\tbad_prog (\"strings for y command are different lengths\");\n\t      cur_cmd->x.translate[*string++] = ch;\n\t    }\n\t  flush_buffer (b);\n\t  if (inchar () != slash || ((ch = inchar ()) != EOF && ch != '\\n' && ch != ';'))\n\t    bad_prog (LINE_JUNK);\n\t  break;\n\n\tdefault:\n\t  bad_prog (\"Unknown command\");\n\t}\n    }\n  if (program_depth)\n    {\n      prog_line = open_line;\n      bad_prog (\"Unmatched `{'\");\n    }\n  return vector;\n}\n\n/* Complain about a programming error and exit. */\nvoid\nbad_prog (why)\n     char *why;\n{\n  if (prog_line > 0)\n    fprintf (stderr, \"%s: file %s line %d: %s\\n\",\n\t     myname, prog_name, prog_line, why);\n  else\n    fprintf (stderr, \"%s: %s\\n\", myname, why);\n  exit (1);\n}\n\n/* Read the next character from the program.  Return EOF if there isn't\n   anything to read.  Keep prog_line up to date, so error messages can\n   be meaningful. */\nint\ninchar ()\n{\n  int ch;\n  if (prog_file)\n    {\n      if (feof (prog_file))\n\treturn EOF;\n      else\n\tch = getc (prog_file);\n    }\n  else\n    {\n      if (!prog_cur)\n\treturn EOF;\n      else if (prog_cur == prog_end)\n\t{\n\t  ch = EOF;\n\t  prog_cur = 0;\n\t}\n      else\n\tch = *prog_cur++;\n    }\n  if ((ch == '\\n') && prog_line)\n    prog_line++;\n  return ch;\n}\n\n/* unget 'ch' so the next call to inchar will return it.  'ch' must not be\n   EOF or anything nasty like that. */\nvoid\nsavchar (ch)\n     int ch;\n{\n  if (ch == EOF)\n    return;\n  if (ch == '\\n' && prog_line > 1)\n    --prog_line;\n  if (prog_file)\n    ungetc (ch, prog_file);\n  else\n    *--prog_cur = ch;\n}\n\n\n/* Try to read an address for a sed command.  If it succeeeds,\n   return non-zero and store the resulting address in *'addr'.\n   If the input doesn't look like an address read nothing\n   and return zero. */\nint\ncompile_address (addr)\n     struct addr *addr;\n{\n  int ch;\n  int num;\n\n  ch = inchar ();\n\n  if (isdigit (ch))\n    {\n      num = ch - '0';\n      while ((ch = inchar ()) != EOF && isdigit (ch))\n\tnum = num * 10 + ch - '0';\n      if (ch == '~')\n\t{\n\t  addr->addr_type = addr_is_mod;\n\t  addr->offset = num;\n\t  ch = inchar();\n\t  num=0;\n\t  if (isdigit(ch)) {\n\t    num = ch - '0';\n\t    while ((ch = inchar ()) != EOF && isdigit (ch))\n\t      num = num * 10 + ch - '0';\n\t    addr->modulo = num;\n\t  }\n\t  addr->modulo += (addr->modulo==0);\n\t}\n      else\n\t{\n\t  addr->addr_type = addr_is_num;\n\t  addr->addr_number = num;\n\t}\n      while (ch != EOF && isblank (ch))\n\tch = inchar ();\n      savchar (ch);\n      return 1;\n    }\n  else if (ch == '/' || ch == '\\\\')\n    {\n      addr->addr_type = addr_is_regex;\n      if (ch == '\\\\')\n\tch = inchar ();\n      buffer_regex (ch);\n      compile_regex ();\n      addr->addr_regex = last_regex;\n      do\n\tch = inchar ();\n      while (ch != EOF && isblank (ch));\n      savchar (ch);\n      return 1;\n    }\n  else if (ch == '$')\n    {\n      addr->addr_type = addr_is_last;\n      do\n\tch = inchar ();\n      while (ch != EOF && isblank (ch));\n      savchar (ch);\n      return 1;\n    }\n  else\n    savchar (ch);\n  return 0;\n}\n\nvoid\nbuffer_regex (slash)\n     int slash;\n{\n  VOID *b;\n  int ch;\n  int char_class_pos = -1;\n\n  b = init_buffer ();\n  while ((ch = inchar ()) != EOF && (ch != slash || (char_class_pos >= 0)))\n    {\n      if (ch == '^')\n\t{\n\t  if (size_buffer (b) == 0)\n\t    {\n\t      add1_buffer (b, '\\\\');\n\t      add1_buffer (b, '`');\n\t    }\n\t  else\n\t    add1_buffer (b, ch);\n\t  continue;\n\t}\n      else if (ch == '$')\n\t{\n\t  ch = inchar ();\n\t  savchar (ch);\n\t  if (ch == slash)\n\t    {\n\t      add1_buffer (b, '\\\\');\n\t      add1_buffer (b, '\\'');\n\t    }\n\t  else\n\t    add1_buffer (b, '$');\n\t  continue;\n\t}\n      else if (ch == '[')\n\t{\n\t  if (char_class_pos < 0)\n\t    char_class_pos = size_buffer (b);\n\t  add1_buffer (b, ch);\n\t  continue;\n\t}\n      else if (ch == ']')\n\t{\n\t  add1_buffer (b, ch);\n\t  {\n\t    char * regexp = get_buffer (b);\n\t    int pos = size_buffer (b) - 1;\n\t    if (!(   (char_class_pos >= 0)\n\t\t  && (   (pos == char_class_pos + 1)\n\t\t      || (   (pos == char_class_pos + 2)\n\t\t\t  && (regexp[char_class_pos + 1] == '^')))))\n\t      char_class_pos = -1;\n\t    continue;\n\t  }\n\t}\n      else if (ch != '\\\\' || (char_class_pos >= 0))\n\t{\n\t  add1_buffer (b, ch);\n\t  continue;\n\t}\n      ch = inchar ();\n      switch (ch)\n\t{\n\tcase 'n':\n\t  add1_buffer (b, '\\n');\n\t  break;\n#if 0\n\tcase 'b':\n\t  add1_buffer (b, '\\b');\n\t  break;\n\tcase 'f':\n\t  add1_buffer (b, '\\f');\n\t  break;\n\tcase 'r':\n\t  add1_buffer (b, '\\r');\n\t  break;\n\tcase 't':\n\t  add1_buffer (b, '\\t');\n\t  break;\n#endif /* 0 */\n\tcase EOF:\n\t  break;\n\tdefault:\n\t  add1_buffer (b, '\\\\');\n\t  add1_buffer (b, ch);\n\t  break;\n\t}\n    }\n  if (ch == EOF)\n    bad_prog (BAD_EOF);\n  if (size_buffer (b))\n    {\n      if (last_regex_string)\n\tlast_regex_string = (char *)ck_realloc (last_regex_string,\n\t\t\t\t\t\tsize_buffer (b) + 1);\n      else\n\tlast_regex_string = (char *)ck_malloc (size_buffer (b) + 1);\n      bcopy (get_buffer (b), last_regex_string, size_buffer (b));\n      last_regex_string [size_buffer (b)] = 0;\n    }\n  else if (!last_regex)\n    bad_prog (NO_REGEX);\n  flush_buffer (b);\n}\n\nvoid\ncompile_regex ()\n{\n  const char * error;\n  last_regex = ((struct re_pattern_buffer *)\n\t\tck_malloc (sizeof (struct re_pattern_buffer)));\n  bzero (last_regex, sizeof (*last_regex));\n  last_regex->fastmap = ck_malloc (256);\n  error = re_compile_pattern (last_regex_string,\n\t\t\t      strlen (last_regex_string), last_regex);\n  if (error)\n    bad_prog ((char *)error);\n}\n\n/* Store a label (or label reference) created by a ':', 'b', or 't'\n   comand so that the jump to/from the lable can be backpatched after\n   compilation is complete */\nstruct sed_label *\nsetup_jump (list, cmd, vec)\n     struct sed_label *list;\n     struct sed_cmd *cmd;\n     struct vector *vec;\n{\n  struct sed_label *tmp;\n  VOID *b;\n  int ch;\n\n  b = init_buffer ();\n  while ((ch = inchar ()) != EOF && isblank (ch))\n    ;\n  /* Possible non posixicity. */\n  while (ch != EOF && ch != '\\n' && (!isblank (ch)) && ch != ';' && ch != '}')\n    {\n      add1_buffer (b, ch);\n      ch = inchar ();\n    }\n  savchar (ch);\n  add1_buffer (b, '\\0');\n  tmp = (struct sed_label *) ck_malloc (sizeof (struct sed_label));\n  tmp->v = vec;\n  tmp->v_index = cmd - vec->v;\n  tmp->name = ck_strdup (get_buffer (b));\n  tmp->next = list;\n  flush_buffer (b);\n  return tmp;\n}\n\n/* read in a filename for a 'r', 'w', or 's///w' command, and\n   update the internal structure about files.  The file is\n   opened if it isn't already open. */\nFILE *\ncompile_filename (readit)\n     int readit;\n{\n  char *file_name;\n  int n;\n  VOID *b;\n  int ch;\n\n  if (inchar () != ' ')\n    bad_prog (\"missing ' ' before filename\");\n  b = init_buffer ();\n  while ((ch = inchar ()) != EOF && ch != '\\n')\n    add1_buffer (b, ch);\n  add1_buffer (b, '\\0');\n  file_name = get_buffer (b);\n  for (n = 0; n < NUM_FPS; n++)\n    {\n      if (!file_ptrs[n].name)\n\tbreak;\n    }\n  if (n < NUM_FPS)\n    {\n      file_ptrs[n].name = ck_strdup (file_name);\n      if (!readit)\n\t{\n\t  if (!file_ptrs[n].for_write)\n\t    file_ptrs[n].for_write = ck_fopen (file_name, \"w\");\n\t}\n      else\n\t{\n\t  if (!file_ptrs[n].for_read)\n\t    file_ptrs[n].for_read = fopen (file_name, \"r\");\n\t}\n      flush_buffer (b);\n      return readit ? file_ptrs[n].for_read : file_ptrs[n].for_write;\n    }\n  else\n    {\n      bad_prog (\"Hopelessely evil compiled in limit on number of open files.  re-compile sed\");\n      return 0;\n    }\n}\n\n/* Read a file and apply the compiled script to it. */\nvoid\nread_file (name)\n     char *name;\n{\n  if (*name == '-' && name[1] == '\\0')\n    input_file = stdin;\n  else\n    {\n      input_file = fopen (name, \"r\");\n      if (input_file == 0)\n\t{\n\t  char *ptr = strerror(errno);\n\t  bad_input++;\n\t  fprintf (stderr, \"%s: can't read %s: %s\\n\", myname, name, ptr);\n\t  return;\n\t}\n    }\n  \n  while (read_pattern_space ())\n    {\n      execute_program (the_program);\n      if (!no_default_output)\n\tck_fwrite (line.text, 1, line.length, stdout);\n      if (append.length)\n\t{\n\t  ck_fwrite (append.text, 1, append.length, stdout);\n\t  append.length = 0;\n\t}\n      if (quit_cmd)\n\tbreak;\n    }\n  ck_fclose (input_file);\n}\n\nstatic char *\neol_pos (str, len)\n     char *str;\n     int len;\n{\n  while (len--)\n    if (*str++ == '\\n')\n      return --str;\n  return --str;\n}\n\nstatic void\nchr_copy (dest, src, len)\n     char *dest;\n     char *src;\n     int len;\n{\n  while (len--)\n    *dest++ = *src++;\n}\n\n/* Execute the program 'vec' on the current input line. */\nstatic struct re_registers regs =\n{0, 0, 0};\n\nvoid\nexecute_program (vec)\n     struct vector *vec;\n{\n  struct sed_cmd *cur_cmd;\n  int n;\n  int addr_matched;\n  static int end_cycle;\n\n  int start;\n  int remain;\n  int offset;\n\n  static struct line tmp;\n  struct line t;\n  char *rep, *rep_end, *rep_next, *rep_cur;\n\n  int count;\n  struct vector *restart_vec = vec;\n\nrestart:\n  vec = restart_vec;\n  count = 0;\n\n  end_cycle = 0;\n\n  for (cur_cmd = vec->v, n = vec->v_length; n; cur_cmd++, n--)\n    {\n    exe_loop:\n      addr_matched = 0;\n      if (cur_cmd->aflags & A1_MATCHED_BIT)\n\t{\n\t  addr_matched = 1;\n\t  if (match_address (&(cur_cmd->a2)))\n\t    cur_cmd->aflags &= ~A1_MATCHED_BIT;\n\t}\n      else if (match_address (&(cur_cmd->a1)))\n\t{\n\t  addr_matched = 1;\n\t  if (cur_cmd->a2.addr_type != addr_is_null)\n\t    if (   (cur_cmd->a2.addr_type == addr_is_regex)\n\t\t|| !match_address (&(cur_cmd->a2)))\n\t      cur_cmd->aflags |= A1_MATCHED_BIT;\n\n\t}\n      if (cur_cmd->aflags & ADDR_BANG_BIT)\n\taddr_matched = !addr_matched;\n      if (!addr_matched)\n\tcontinue;\n      switch (cur_cmd->cmd)\n\t{\n\tcase '{':\t\t/* Execute sub-program */\n\t  if (cur_cmd->x.sub->v_length)\n\t    {\n\t      vec = cur_cmd->x.sub;\n\t      cur_cmd = vec->v;\n\t      n = vec->v_length;\n\t      goto exe_loop;\n\t    }\n\t  break;\n\n\tcase '}':\n\t  cur_cmd = vec->return_v->v + vec->return_i;\n\t  n = vec->return_v->v_length - vec->return_i;\n\t  vec = vec->return_v;\n\t  break;\n\n\tcase ':':\t\t/* Executing labels is easy. */\n\t  break;\n\n\tcase '=':\n\t  printf (\"%d\\n\", input_line_number);\n\t  break;\n\n\tcase 'a':\n\t  while (append.alloc - append.length < cur_cmd->x.cmd_txt.text_len)\n\t    {\n\t      append.alloc *= 2;\n\t      append.text = ck_realloc (append.text, append.alloc);\n\t    }\n\t  bcopy (cur_cmd->x.cmd_txt.text,\n\t\t append.text + append.length, cur_cmd->x.cmd_txt.text_len);\n\t  append.length += cur_cmd->x.cmd_txt.text_len;\n\t  break;\n\n\tcase 'b':\n\t  if (!cur_cmd->x.jump)\n\t    end_cycle++;\n\t  else\n\t    {\n\t      struct sed_label *j = cur_cmd->x.jump;\n\n\t      n = j->v->v_length - j->v_index;\n\t      cur_cmd = j->v->v + j->v_index;\n\t      vec = j->v;\n\t      goto exe_loop;\n\t    }\n\t  break;\n\n\tcase 'c':\n\t  line.length = 0;\n\t  if (!((cur_cmd->aflags & A1_MATCHED_BIT)))\n\t    ck_fwrite (cur_cmd->x.cmd_txt.text,\n\t\t       1, cur_cmd->x.cmd_txt.text_len, stdout);\n\t  end_cycle++;\n\t  break;\n\n\tcase 'd':\n\t  line.length = 0;\n\t  end_cycle++;\n\t  break;\n\n\tcase 'D':\n\t  {\n\t    char *tmp;\n\t    int newlength;\n\n\t    tmp = eol_pos (line.text, line.length);\n\t    newlength = line.length - (tmp - line.text) - 1;\n\t    if (newlength)\n\t      {\n\t\tchr_copy (line.text, tmp + 1, newlength);\n\t\tline.length = newlength;\n\t\tgoto restart;\n\t      }\n\t    line.length = 0;\n\t    end_cycle++;\n\t  }\n\t  break;\n\n\tcase 'g':\n\t  line_copy (&hold, &line);\n\t  break;\n\n\tcase 'G':\n\t  line_append (&hold, &line);\n\t  break;\n\n\tcase 'h':\n\t  line_copy (&line, &hold);\n\t  break;\n\n\tcase 'H':\n\t  line_append (&line, &hold);\n\t  break;\n\n\tcase 'i':\n\t  ck_fwrite (cur_cmd->x.cmd_txt.text, 1,\n\t\t     cur_cmd->x.cmd_txt.text_len, stdout);\n\t  break;\n\n\tcase 'l':\n\t  {\n\t    char *tmp;\n\t    int n;\n\t    int width = 0;\n\n\t    n = line.length;\n\t    tmp = line.text;\n\t    while (n--)\n\t      {\n\t\t/* Skip the trailing newline, if there is one */\n\t\tif (!n && (*tmp == '\\n'))\n\t\t  break;\n\t\tif (width > 77)\n\t\t  {\n\t\t    width = 0;\n\t\t    putchar ('\\n');\n\t\t  }\n\t\tif (*tmp == '\\\\')\n\t\t  {\n\t\t    printf (\"\\\\\\\\\");\n\t\t    width += 2;\n\t\t  }\n\t\telse if (isprint (*tmp))\n\t\t  {\n\t\t    putchar (*tmp);\n\t\t    width++;\n\t\t  }\n\t\telse\n\t\t  switch (*tmp)\n\t\t    {\n#if 0\n\t\t      /* Should print \\00 instead of \\0 because (a) POSIX */\n\t\t      /* requires it, and (b) this way \\01 is unambiguous.  */\n\t\t    case '\\0':\n\t\t      printf (\"\\\\0\");\n\t\t      width += 2;\n\t\t      break;\n#endif\n\t\t    case 007:\n\t\t      printf (\"\\\\a\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\b':\n\t\t      printf (\"\\\\b\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\f':\n\t\t      printf (\"\\\\f\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\n':\n\t\t      printf (\"\\\\n\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\r':\n\t\t      printf (\"\\\\r\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\t':\n\t\t      printf (\"\\\\t\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    case '\\v':\n\t\t      printf (\"\\\\v\");\n\t\t      width += 2;\n\t\t      break;\n\t\t    default:\n\t\t      printf (\"\\\\%02x\", (*tmp) & 0xFF);\n\t\t      width += 2;\n\t\t      break;\n\t\t    }\n\t\ttmp++;\n\t      }\n\t    putchar ('\\n');\n\t  }\n\t  break;\n\n\tcase 'n':\n\t  if (feof (input_file))\n\t    goto quit;\n\t  if (!no_default_output)\n\t    ck_fwrite (line.text, 1, line.length, stdout);\n\t  read_pattern_space ();\n\t  break;\n\n\tcase 'N':\n\t  if (feof (input_file))\n\t    {\n\t      line.length = 0;\n\t      goto quit;\n\t    }\n\t  append_pattern_space ();\n\t  break;\n\n\tcase 'p':\n\t  ck_fwrite (line.text, 1, line.length, stdout);\n\t  break;\n\n\tcase 'P':\n\t  {\n\t    char *tmp;\n\n\t    tmp = eol_pos (line.text, line.length);\n\t    ck_fwrite (line.text, 1,\n\t\t       tmp ? tmp - line.text + 1\n\t\t       : line.length, stdout);\n\t  }\n\t  break;\n\n\tcase 'q':\n\tquit:\n\t  quit_cmd++;\n\t  end_cycle++;\n\t  break;\n\n\tcase 'r':\n\t  {\n\t    int n = 0;\n\n\t    if (cur_cmd->x.io_file)\n\t      {\n\t\trewind (cur_cmd->x.io_file);\n\t\tdo\n\t\t  {\n\t\t    append.length += n;\n\t\t    if (append.length == append.alloc)\n\t\t      {\n\t\t\tappend.alloc *= 2;\n\t\t\tappend.text = ck_realloc (append.text, append.alloc);\n\t\t      }\n\t\t    n = fread (append.text + append.length, sizeof (char),\n\t\t\t       append.alloc - append.length,\n\t\t\t       cur_cmd->x.io_file);\n\t\t  }\n\t\twhile (n > 0);\n\t\tif (ferror (cur_cmd->x.io_file))\n\t\t  panic (\"Read error on input file to 'r' command\");\n\t      }\n\t  }\n\t  break;\n\n\tcase 's':\n\t  {\n\t    int trail_nl_p = line.text [line.length - 1] == '\\n';\n\t    if (!tmp.alloc)\n\t      {\n\t\ttmp.alloc = 50;\n\t\ttmp.text = ck_malloc (50);\n\t      }\n\t    count = 0;\n\t    start = 0;\n\t    remain = line.length - trail_nl_p;\n\t    tmp.length = 0;\n\t    rep = cur_cmd->x.cmd_regex.replacement;\n\t    rep_end = rep + cur_cmd->x.cmd_regex.replace_length;\n\t    \n\t    while ((offset = re_search (cur_cmd->x.cmd_regex.regx,\n\t\t\t\t\tline.text,\n\t\t\t\t\tline.length - trail_nl_p,\n\t\t\t\t\tstart,\n\t\t\t\t\tremain,\n\t\t\t\t\t&regs)) >= 0)\n\t      {\n\t\tcount++;\n\t\tif (offset - start)\n\t\t  str_append (&tmp, line.text + start, offset - start);\n\t\t\n\t\tif (cur_cmd->x.cmd_regex.flags & S_NUM_BIT)\n\t\t  {\n\t\t    if (count != cur_cmd->x.cmd_regex.numb)\n\t\t      {\n\t\t\tint matched = regs.end[0] - regs.start[0];\n\t\t\tif (!matched) matched = 1;\n\t\t\tstr_append (&tmp, line.text + regs.start[0], matched);\n\t\t\tstart = (offset == regs.end[0]\n\t\t\t\t ? offset + 1 : regs.end[0]);\n\t\t\tremain = (line.length - trail_nl_p) - start;\n\t\t\tcontinue;\n\t\t      }\n\t\t  }\n\t\t\n\t\tfor (rep_next = rep_cur = rep; rep_next < rep_end; rep_next++)\n\t\t  {\n\t\t    if (*rep_next == '&')\n\t\t      {\n\t\t\tif (rep_next - rep_cur)\n\t\t\t  str_append (&tmp, rep_cur, rep_next - rep_cur);\n\t\t\tstr_append (&tmp, line.text + regs.start[0], regs.end[0] - regs.start[0]);\n\t\t\trep_cur = rep_next + 1;\n\t\t      }\n\t\t    else if (*rep_next == '\\\\')\n\t\t      {\n\t\t\tif (rep_next - rep_cur)\n\t\t\t  str_append (&tmp, rep_cur, rep_next - rep_cur);\n\t\t\trep_next++;\n\t\t\tif (rep_next != rep_end)\n\t\t\t  {\n\t\t\t    int n;\n\t\t\t    \n\t\t\t    if (*rep_next >= '0' && *rep_next <= '9')\n\t\t\t      {\n\t\t\t\tn = *rep_next - '0';\n\t\t\t\tstr_append (&tmp, line.text + regs.start[n], regs.end[n] - regs.start[n]);\n\t\t\t      }\n\t\t\t    else\n\t\t\t      str_append (&tmp, rep_next, 1);\n\t\t\t  }\n\t\t\trep_cur = rep_next + 1;\n\t\t      }\n\t\t  }\n\t\tif (rep_next - rep_cur)\n\t\t  str_append (&tmp, rep_cur, rep_next - rep_cur);\n\t\tif (offset == regs.end[0])\n\t\t  {\n\t\t    str_append (&tmp, line.text + offset, 1);\n\t\t    ++regs.end[0];\n\t\t  }\n\t\tstart = regs.end[0];\n\t\t\n\t\tremain = (line.length - trail_nl_p) - start;\n\t\tif (remain < 0)\n\t\t  break;\n\t\tif (!(cur_cmd->x.cmd_regex.flags & S_GLOBAL_BIT))\n\t\t  break;\n\t      }\n\t    if (!count)\n\t      break;\n\t    replaced = 1;\n\t    str_append (&tmp, line.text + start, remain + trail_nl_p);\n\t    t.text = line.text;\n\t    t.length = line.length;\n\t    t.alloc = line.alloc;\n\t    line.text = tmp.text;\n\t    line.length = tmp.length;\n\t    line.alloc = tmp.alloc;\n\t    tmp.text = t.text;\n\t    tmp.length = t.length;\n\t    tmp.alloc = t.alloc;\n\t    if ((cur_cmd->x.cmd_regex.flags & S_WRITE_BIT)\n\t\t&& cur_cmd->x.cmd_regex.wio_file)\n\t      ck_fwrite (line.text, 1, line.length,\n\t\t\t cur_cmd->x.cmd_regex.wio_file);\n\t    if (cur_cmd->x.cmd_regex.flags & S_PRINT_BIT)\n\t      ck_fwrite (line.text, 1, line.length, stdout);\n\t    break;\n\t  }\n\t    \n\tcase 't':\n\t  if (replaced)\n\t    {\n\t      replaced = 0;\n\t      if (!cur_cmd->x.jump)\n\t\tend_cycle++;\n\t      else\n\t\t{\n\t\t  struct sed_label *j = cur_cmd->x.jump;\n\n\t\t  n = j->v->v_length - j->v_index;\n\t\t  cur_cmd = j->v->v + j->v_index;\n\t\t  vec = j->v;\n\t\t  goto exe_loop;\n\t\t}\n\t    }\n\t  break;\n\n\tcase 'w':\n\t  if (cur_cmd->x.io_file)\n\t    {\n\t      ck_fwrite (line.text, 1, line.length, cur_cmd->x.io_file);\n\t      fflush (cur_cmd->x.io_file);\n\t    }\n\t  break;\n\n\tcase 'x':\n\t  {\n\t    struct line tmp;\n\n\t    tmp = line;\n\t    line = hold;\n\t    hold = tmp;\n\t  }\n\t  break;\n\n\tcase 'y':\n\t  {\n\t    unsigned char *p, *e;\n\n\t    for (p = (unsigned char *) (line.text), e = p + line.length;\n\t\t p < e;\n\t\t p++)\n\t      *p = cur_cmd->x.translate[*p];\n\t  }\n\t  break;\n\n\tdefault:\n\t  panic (\"INTERNAL ERROR: Bad cmd %c\", cur_cmd->cmd);\n\t}\n      if (end_cycle)\n\tbreak;\n    }\n}\n\n\n/* Return non-zero if the current line matches the address\n   pointed to by 'addr'. */\nint\nmatch_address (addr)\n     struct addr *addr;\n{\n  switch (addr->addr_type)\n    {\n    case addr_is_null:\n      return 1;\n    case addr_is_num:\n      return (input_line_number == addr->addr_number);\n    case addr_is_mod:\n      return ((input_line_number%addr->modulo) == addr->offset);\n\n\n    case addr_is_regex:\n      {\n\tint trail_nl_p = line.text [line.length - 1] == '\\n';\n\treturn (re_search (addr->addr_regex,\n\t\t\t   line.text,\n\t\t\t   line.length - trail_nl_p,\n\t\t\t   0,\n\t\t\t   line.length - trail_nl_p,\n\t\t\t   (struct re_registers *) 0) >= 0) ? 1 : 0;\n      }\n    case addr_is_last:\n      return (input_EOF) ? 1 : 0;\n\n    default:\n      panic (\"INTERNAL ERROR: bad address type\");\n      break;\n    }\n  return -1;\n}\n\n/* Read in the next line of input, and store it in the\n   pattern space.  Return non-zero if this is the last line of input */\n\nint\nread_pattern_space ()\n{\n  int n;\n  char *p;\n  int ch;\n\n  p = line.text;\n  n = line.alloc;\n\n  if (feof (input_file))\n    return 0;\n  input_line_number++;\n  replaced = 0;\n  for (;;)\n    {\n      if (n == 0)\n\t{\n\t  line.text = ck_realloc (line.text, line.alloc * 2);\n\t  p = line.text + line.alloc;\n\t  n = line.alloc;\n\t  line.alloc *= 2;\n\t}\n      ch = getc (input_file);\n      if (ch == EOF)\n\t{\n\t  if (n == line.alloc)\n\t    return 0;\n\t  /* *p++ = '\\n'; */\n\t  /* --n; */\n\t  line.length = line.alloc - n;\n\t  if (last_input_file)\n\t    input_EOF++;\n\t  return 1;\n\t}\n      *p++ = ch;\n      --n;\n      if (ch == '\\n')\n\t{\n\t  line.length = line.alloc - n;\n\t  break;\n\t}\n    }\n  ch = getc (input_file);\n  if (ch != EOF)\n    ungetc (ch, input_file);\n  else if (last_input_file)\n    input_EOF++;\n  return 1;\n}\n\n/* Inplement the 'N' command, which appends the next line of input to\n   the pattern space. */\nvoid\nappend_pattern_space ()\n{\n  char *p;\n  int n;\n  int ch;\n\n  p = line.text + line.length;\n  n = line.alloc - line.length;\n\n  input_line_number++;\n  replaced = 0;\n  for (;;)\n    {\n      ch = getc (input_file);\n      if (ch == EOF)\n\t{\n\t  if (n == line.alloc)\n\t    return;\n\t  /* *p++ = '\\n'; */\n\t  /* --n; */\n\t  line.length = line.alloc - n;\n\t  if (last_input_file)\n\t    input_EOF++;\n\t  return;\n\t}\n      if (n == 0)\n\t{\n\t  line.text = ck_realloc (line.text, line.alloc * 2);\n\t  p = line.text + line.alloc;\n\t  n = line.alloc;\n\t  line.alloc *= 2;\n\t}\n      *p++ = ch;\n      --n;\n      if (ch == '\\n')\n\t{\n\t  line.length = line.alloc - n;\n\t  break;\n\t}\n    }\n  ch = getc (input_file);\n  if (ch != EOF)\n    ungetc (ch, input_file);\n  else if (last_input_file)\n    input_EOF++;\n}\n\n/* Copy the contents of the line 'from' into the line 'to'.\n   This destroys the old contents of 'to'.  It will still work\n   if the line 'from' contains nulls. */\nvoid\nline_copy (from, to)\n     struct line *from, *to;\n{\n  if (from->length > to->alloc)\n    {\n      to->alloc = from->length;\n      to->text = ck_realloc (to->text, to->alloc);\n    }\n  bcopy (from->text, to->text, from->length);\n  to->length = from->length;\n}\n\n/* Append the contents of the line 'from' to the line 'to'.\n   This routine will work even if the line 'from' contains nulls */\nvoid\nline_append (from, to)\n     struct line *from, *to;\n{\n  if (from->length > (to->alloc - to->length))\n    {\n      to->alloc += from->length;\n      to->text = ck_realloc (to->text, to->alloc);\n    }\n  bcopy (from->text, to->text + to->length, from->length);\n  to->length += from->length;\n}\n\n/* Append 'length' bytes from 'string' to the line 'to'\n   This routine *will* append bytes with nulls in them, without\n   failing. */\nvoid\nstr_append (to, string, length)\n     struct line *to;\n     char *string;\n     int length;\n{\n  if (length > to->alloc - to->length)\n    {\n      to->alloc += length;\n      to->text = ck_realloc (to->text, to->alloc);\n    }\n  bcopy (string, to->text + to->length, length);\n  to->length += length;\n}\n\nvoid\nusage (status)\n     int status;\n{\n  fprintf (status ? stderr : stdout, \"\\\nUsage: %s [-nV] [--quiet] [--silent] [--version] [-e script]\\n\\\n        [-f script-file] [--expression=script] [--file=script-file] [file...]\\n\",\n\t   myname);\n  exit (status);\n}\n/*  Functions from hack's utils library.\n    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2, or (at your option)\n    any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n/* These routines were written as part of a library (by hack), but since most\n   people don't have the library, here they are.  */\n\n#ifdef __STDC__\n#define VOID void\n#else\n#define VOID char\n#endif\n\n#include <stdio.h>\n#if HAVE_STRING_H || defined(STDC_HEADERS)\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#if defined(STDC_HEADERS)\n#include <stdlib.h>\n#else\n#ifdef RX_MEMDBUG\n#include <sys/types.h>\n#include <malloc.h>\n#else\nVOID *malloc();\nVOID *realloc();\n#endif /* ndef RX_MEMDBUG  */\n#endif\n\nVOID *ck_malloc();\n\nchar *myname;\n\n\n#ifdef __STDC__\n#include <stdarg.h>\n\n/* Print an error message and exit */\nvoid\npanic(char *str, ...)\n{\n\tva_list iggy;\n\n\tfprintf(stderr,\"%s: \",myname);\n\tva_start(iggy,str);\n#ifdef HAVE_VPRINTF\n\tvfprintf(stderr,str,iggy);\n#else\n#ifdef HAVE_DOPRNT\n\t_doprnt(str,&iggy,stderr);\n#endif\n#endif\n\tva_end(iggy);\n\tputc('\\n',stderr);\n\texit(4);\n}\n\n#else\n#include <varargs.h>\n\nvoid\npanic(str,va_alist)\nchar *str;\nva_dcl\n{\n\tva_list iggy;\n\n\tfprintf(stderr,\"%s: \",myname);\n\tva_start(iggy);\n#ifdef HAVE_VPRINTF\n\tvfprintf(stderr,str,iggy);\n#else\n#ifdef HAVE_DOPRNT\n\t_doprnt(str,&iggy,stderr);\n#endif\n#endif\n\tva_end(iggy);\n\tputc('\\n',stderr);\n\texit(4);\n}\n\n#endif\n\n/* Store information about files opened with ck_fopen\n   so that error messages from ck_fread, etc can print the\n   name of the file that had the error */\n#define N_FILE 32\n\nstruct id {\n\tFILE *fp;\n\tchar *name;\n};\n\nstatic struct id __id_s[N_FILE];\n\n/* Internal routine to get a filename from __id_s */\nchar *\n__fp_name(fp)\nFILE *fp;\n{\n\tint n;\n\n\tfor(n=0;n<N_FILE;n++) {\n\t\tif(__id_s[n].fp==fp)\n\t\t\treturn __id_s[n].name;\n\t}\n\treturn \"{Unknown file pointer}\";\n}\n\n/* Panic on failing fopen */\nFILE *\nck_fopen(name,mode)\nchar *name;\nchar *mode;\n{\n\tFILE\t*ret;\n\tint\tn;\n\n\tret=fopen(name,mode);\n\tif(ret==(FILE *)0)\n\t\tpanic(\"Couldn't open file %s\",name);\n\tfor(n=0;n<N_FILE;n++) {\n\t\tif(ret==__id_s[n].fp) {\n\t\t\tfree((VOID *)__id_s[n].name);\n\t\t\t__id_s[n].name=(char *)ck_malloc(strlen(name)+1);\n\t\t\tstrcpy(__id_s[n].name,name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(n==N_FILE) {\n\t\tfor(n=0;n<N_FILE;n++)\n\t\t\tif(__id_s[n].fp==(FILE *)0)\n\t\t\t\tbreak;\n\t\tif(n==N_FILE)\n\t\t\tpanic(\"Internal error: too many files open\");\n\t\t__id_s[n].fp=ret;\n\t\t__id_s[n].name=(char *)ck_malloc(strlen(name)+1);\n\t\tstrcpy(__id_s[n].name,name);\n\t}\n\treturn ret;\n}\n\n/* Panic on failing fwrite */\nvoid\nck_fwrite(ptr,size,nmemb,stream)\nchar *ptr;\nint size,nmemb;\nFILE *stream;\n{\n\tif(fwrite(ptr,size,nmemb,stream)!=nmemb)\n\t\tpanic(\"couldn't write %d items to %s\",nmemb,__fp_name(stream));\n}\n\n/* Panic on failing fclose */\nvoid\nck_fclose(stream)\nFILE *stream;\n{\n\tif(fclose(stream)==EOF)\n\t\tpanic(\"Couldn't close %s\",__fp_name(stream));\n}\n\n/* Panic on failing malloc */\nVOID *\nck_malloc(size)\nint size;\n{\n\tVOID *ret;\n\n\tif(!size)\n\t\tsize++;\n\tret=malloc(size);\n\tif(ret==(VOID *)0)\n\t\tpanic(\"Couldn't allocate memory\");\n\treturn ret;\n}\n\n/* Panic on failing malloc */\nVOID *\nxmalloc(size)\nint size;\n{\n  return ck_malloc (size);\n}\n\n/* Panic on failing realloc */\nVOID *\nck_realloc(ptr,size)\nVOID *ptr;\nint size;\n{\n\tVOID *ret;\n\n\tif (!ptr)\n\t  return ck_malloc (size);\n\tret=realloc(ptr,size);\n\tif(ret==(VOID *)0)\n\t\tpanic(\"Couldn't re-allocate memory\");\n\treturn ret;\n}\n\n/* Return a malloc()'d copy of a string */\nchar *\nck_strdup(str)\nchar *str;\n{\n\tchar *ret;\n\n\tret=(char *)ck_malloc(strlen(str)+2);\n\tstrcpy(ret,str);\n\treturn ret;\n}\n\n\n/* Implement a variable sized buffer of 'stuff'.  We don't know what it is,\n   nor do we care, as long as it doesn't mind being aligned by malloc. */\n\nstruct buffer {\n\tint\tallocated;\n\tint\tlength;\n\tchar\t*b;\n};\n\n#define MIN_ALLOCATE 50\n\nVOID *\ninit_buffer()\n{\n\tstruct buffer *b;\n\n\tb=(struct buffer *)ck_malloc(sizeof(struct buffer));\n\tb->allocated=MIN_ALLOCATE;\n\tb->b=(char *)ck_malloc(MIN_ALLOCATE);\n\tb->length=0;\n\treturn (VOID *)b;\n}\n\nvoid\nflush_buffer(bb)\nVOID *bb;\n{\n\tstruct buffer *b;\n\n\tb=(struct buffer *)bb;\n\tfree(b->b);\n\tb->b=0;\n\tb->allocated=0;\n\tb->length=0;\n\tfree(b);\n}\n\nint\nsize_buffer(b)\nVOID *b;\n{\n\tstruct buffer *bb;\n\n\tbb=(struct buffer *)b;\n\treturn bb->length;\n}\n\nvoid\nadd_buffer(bb,p,n)\nVOID *bb;\nchar *p;\nint n;\n{\n\tstruct buffer *b;\n\tint x;\n\tchar * cp;\n\n\tb=(struct buffer *)bb;\n\tif(b->length+n>b->allocated) {\n\t\tb->allocated = (b->length + n) * 2;\n\t\tb->b=(char *)ck_realloc(b->b,b->allocated);\n\t}\n\t\n\tx = n;\n\tcp = b->b + b->length;\n\twhile (x--)\n\t  *cp++ = *p++;\n\tb->length+=n;\n}\n\nvoid\nadd1_buffer(bb,ch)\nVOID *bb;\nint ch;\n{\n\tstruct buffer *b;\n\n\tb=(struct buffer *)bb;\n\tif(b->length+1>b->allocated) {\n\t\tb->allocated*=2;\n\t\tb->b=(char *)ck_realloc(b->b,b->allocated);\n\t}\n\tb->b[b->length]=ch;\n\tb->length++;\n}\n\nchar *\nget_buffer(bb)\nVOID *bb;\n{\n\tstruct buffer *b;\n\n\tb=(struct buffer *)bb;\n\treturn b->b;\n}\n/*\tCopyright (C) 1992, 1993 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this software; see the file COPYING.  If not, write to\nthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n/* NOTE!!!  AIX requires this to be the first thing in the file.\n * Do not put ANYTHING before it!  \n */\n#if !defined (__GNUC__) && defined (_AIX)\n #pragma alloca\n#endif\n\f\nstatic char rx_version_string[] = \"GNU Rx version 0.03\";\n\n\t\t\t/* ``Too hard!''\n\t\t\t *\t    -- anon.\n\t\t\t */\n\n/* N.B.:\n *\n * I think Joe Keane thought of the clever name `superstate'.\n */\n\n\f\n#include <stdio.h>\n#include <ctype.h>\n#ifndef isgraph\n#define isgraph(c) (isprint (c) && !isspace (c))\n#endif\n#ifndef isblank\n#define isblank(c) ((c) == ' ' || (c) == '\\t')\n#endif\n\n#include <sys/types.h>\n#include <stdio.h>\n#include \"rx.h\"\n\n#undef MAX\n#undef MIN\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef char boolean;\n#define false 0\n#define true 1\n\f\n\n/* This page is decls to the interesting subsystems and lower layers\n * of rx.  Everything which doesn't have a public counterpart in \n * regex.c is declared here.\n * \n * A useful (i hope) system is obtained by removing all or part of the regex.c\n * reimplementation and making these all extern.  I think this package\n * could be used to implement on-line lexers and parsers and who knows what \n * else.\n */\n/* In the definitions, these functions are qualified by `RX_DECL' */\n#define RX_DECL static\n\n#ifdef __STDC__\n\nRX_DECL int rx_bitset_is_subset (int size, rx_Bitset a, rx_Bitset b);\nRX_DECL void rx_bitset_null (int size, rx_Bitset b);\nRX_DECL void rx_bitset_universe (int size, rx_Bitset b);\nRX_DECL void rx_bitset_complement (int size, rx_Bitset b);\nRX_DECL void rx_bitset_assign (int size, rx_Bitset a, rx_Bitset b);\nRX_DECL void rx_bitset_union (int size, rx_Bitset a, rx_Bitset b);\nRX_DECL void rx_bitset_intersection (int size,\n\t\t\t\t     rx_Bitset a, rx_Bitset b);\nRX_DECL void rx_bitset_difference (int size, rx_Bitset a, rx_Bitset b);\nRX_DECL unsigned long rx_bitset_hash (int size, rx_Bitset b);\nRX_DECL struct rx_hash_item * rx_hash_find (struct rx_hash * table,\n\t\t\t\t\t    unsigned long hash,\n\t\t\t\t\t    void * value,\n\t\t\t\t\t    struct rx_hash_rules * rules);\nRX_DECL struct rx_hash_item * rx_hash_store (struct rx_hash * table,\n\t\t\t\t\t     unsigned long hash,\n\t\t\t\t\t     void * value,\n\t\t\t\t\t     struct rx_hash_rules * rules);\nRX_DECL void rx_hash_free (struct rx_hash_item * it,\n\t\t\t   struct rx_hash_rules * rules);\nRX_DECL rx_Bitset rx_cset (struct rx *rx);\nRX_DECL rx_Bitset rx_copy_cset (struct rx *rx, rx_Bitset a);\nRX_DECL void rx_free_cset (struct rx * rx, rx_Bitset c);\nRX_DECL struct rexp_node * rexp_node (struct rx *rx,\n\t\t\t\t      enum rexp_node_type type);\nRX_DECL struct rexp_node * rx_mk_r_cset (struct rx * rx,\n\t\t\t\t\t rx_Bitset b);\nRX_DECL struct rexp_node * rx_mk_r_concat (struct rx * rx,\n\t\t\t\t\t   struct rexp_node * a,\n\t\t\t\t\t   struct rexp_node * b);\nRX_DECL struct rexp_node * rx_mk_r_alternate (struct rx * rx,\n\t\t\t\t\t      struct rexp_node * a,\n\t\t\t\t\t      struct rexp_node * b);\nRX_DECL struct rexp_node * rx_mk_r_opt (struct rx * rx,\n\t\t\t\t\tstruct rexp_node * a);\nRX_DECL struct rexp_node * rx_mk_r_star (struct rx * rx,\n\t\t\t\t\t struct rexp_node * a);\nRX_DECL struct rexp_node * rx_mk_r_2phase_star (struct rx * rx,\n\t\t\t\t\t\tstruct rexp_node * a,\n\t\t\t\t\t\tstruct rexp_node * b);\nRX_DECL struct rexp_node * rx_mk_r_side_effect (struct rx * rx,\n\t\t\t\t\t\trx_side_effect a);\nRX_DECL struct rexp_node * rx_mk_r_data  (struct rx * rx,\n\t\t\t\t\t  void * a);\nRX_DECL void rx_free_rexp (struct rx * rx, struct rexp_node * node);\nRX_DECL struct rexp_node * rx_copy_rexp (struct rx *rx,\n\t\t\t\t\t struct rexp_node *node);\nRX_DECL struct rx_nfa_state * rx_nfa_state (struct rx *rx);\nRX_DECL void rx_free_nfa_state (struct rx_nfa_state * n);\nRX_DECL struct rx_nfa_state * rx_id_to_nfa_state (struct rx * rx,\n\t\t\t\t\t\t  int id);\nRX_DECL struct rx_nfa_edge * rx_nfa_edge (struct rx *rx,\n\t\t\t\t\t  enum rx_nfa_etype type,\n\t\t\t\t\t  struct rx_nfa_state *start,\n\t\t\t\t\t  struct rx_nfa_state *dest);\nRX_DECL void rx_free_nfa_edge (struct rx_nfa_edge * e);\nRX_DECL void rx_free_nfa (struct rx *rx);\nRX_DECL int rx_build_nfa (struct rx *rx,\n\t\t\t  struct rexp_node *rexp,\n\t\t\t  struct rx_nfa_state **start,\n\t\t\t  struct rx_nfa_state **end);\nRX_DECL void rx_name_nfa_states (struct rx *rx);\nRX_DECL int rx_eclose_nfa (struct rx *rx);\nRX_DECL void rx_delete_epsilon_transitions (struct rx *rx);\nRX_DECL int rx_compactify_nfa (struct rx *rx,\n\t\t\t       void **mem, unsigned long *size);\nRX_DECL struct rx_superset * rx_superstate_eclosure_union\n  (struct rx * rx, struct rx_superset *set, struct rx_nfa_state_set *ecl) ;\nRX_DECL void rx_release_superset (struct rx *rx,\n\t\t\t\t  struct rx_superset *set);\nRX_DECL struct rx_superstate * rx_superstate (struct rx *rx,\n\t\t\t\t\t      struct rx_superset *set);\nRX_DECL struct rx_inx * rx_handle_cache_miss\n  (struct rx *rx, struct rx_superstate *super, unsigned char chr, void *data) ;\n\n#else /* ndef __STDC__ */\nRX_DECL int rx_bitset_is_subset ();\nRX_DECL void rx_bitset_null ();\nRX_DECL void rx_bitset_universe ();\nRX_DECL void rx_bitset_complement ();\nRX_DECL void rx_bitset_assign ();\nRX_DECL void rx_bitset_union ();\nRX_DECL void rx_bitset_intersection ();\nRX_DECL void rx_bitset_difference ();\nRX_DECL unsigned long rx_bitset_hash ();\nRX_DECL struct rx_hash_item * rx_hash_find ();\nRX_DECL struct rx_hash_item * rx_hash_store ();\nRX_DECL void rx_hash_free ();\nRX_DECL rx_Bitset rx_cset ();\nRX_DECL rx_Bitset rx_copy_cset ();\nRX_DECL void rx_free_cset ();\nRX_DECL struct rexp_node * rexp_node ();\nRX_DECL struct rexp_node * rx_mk_r_cset ();\nRX_DECL struct rexp_node * rx_mk_r_concat ();\nRX_DECL struct rexp_node * rx_mk_r_alternate ();\nRX_DECL struct rexp_node * rx_mk_r_opt ();\nRX_DECL struct rexp_node * rx_mk_r_star ();\nRX_DECL struct rexp_node * rx_mk_r_2phase_star ();\nRX_DECL struct rexp_node * rx_mk_r_side_effect ();\nRX_DECL struct rexp_node * rx_mk_r_data  ();\nRX_DECL void rx_free_rexp ();\nRX_DECL struct rexp_node * rx_copy_rexp ();\nRX_DECL struct rx_nfa_state * rx_nfa_state ();\nRX_DECL void rx_free_nfa_state ();\nRX_DECL struct rx_nfa_state * rx_id_to_nfa_state ();\nRX_DECL struct rx_nfa_edge * rx_nfa_edge ();\nRX_DECL void rx_free_nfa_edge ();\nRX_DECL void rx_free_nfa ();\nRX_DECL int rx_build_nfa ();\nRX_DECL void rx_name_nfa_states ();\nRX_DECL int rx_eclose_nfa ();\nRX_DECL void rx_delete_epsilon_transitions ();\nRX_DECL int rx_compactify_nfa ();\nRX_DECL struct rx_superset * rx_superstate_eclosure_union ();\nRX_DECL void rx_release_superset ();\nRX_DECL struct rx_superstate * rx_superstate ();\nRX_DECL struct rx_inx * rx_handle_cache_miss ();\n  \n#endif /* ndef __STDC__ */\n\f\n\n\n/* Emacs already defines alloca, sometimes.  */\n#ifndef alloca\n\n/* Make alloca work the best possible way.  */\n#ifdef __GNUC__\n#define alloca __builtin_alloca\n#else /* not __GNUC__ */\n#if HAVE_ALLOCA_H\n#include <alloca.h>\n#else /* not __GNUC__ or HAVE_ALLOCA_H */\n#ifndef _AIX /* Already did AIX, up at the top.  */\nchar *alloca ();\n#endif /* not _AIX */\n#endif /* not HAVE_ALLOCA_H */ \n#endif /* not __GNUC__ */\n\n#endif /* not alloca */\n\n\n/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we\n * use `alloca' instead of `malloc' for the backtracking stack.\n *\n * Emacs will die miserably if we don't do this.\n */\n\n#ifdef REGEX_MALLOC\n\n#define REGEX_ALLOCATE malloc\n\n#else /* not REGEX_MALLOC  */\n\n#define REGEX_ALLOCATE alloca\n\n#endif /* not REGEX_MALLOC */\n\n\n\f\n\n/* Memory management and stuff for emacs. */\n\n#define BYTEWIDTH 8 /* In bits.  */\n\n/* (Re)Allocate N items of type T using malloc.  */\n#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))\n#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))\n\n#define remalloc(M, S) (M ? realloc (M, S) : malloc (S))\n\n#ifdef emacs\n/* The `emacs' switch turns on certain matching commands\n * that make sense only in Emacs. \n */\n\n#include \"config.h\"\n#include \"lisp.h\"\n#include \"buffer.h\"\n#include \"syntax.h\"\n\n/* Emacs uses `NULL' as a predicate.  */\n#undef NULL\n#else  /* not emacs */\n\n/* Setting RX_MEMDBUG is useful if you have dbmalloc.  Maybe with similar\n * packages too.\n */\n#ifdef RX_MEMDBUG\n#include <malloc.h>\n#else /* not RX_RX_MEMDBUG */\n\n/* We used to test for `BSTRING' here, but only GCC and Emacs define\n * `BSTRING', as far as I know, and neither of them use this code.  \n */\n#if HAVE_STRING_H || STDC_HEADERS\n#include <string.h>\n#ifndef bcmp\n#define bcmp(s1, s2, n)\tmemcmp ((s1), (s2), (n))\n#endif\n#ifndef bcopy\n#define bcopy(s, d, n)\tmemcpy ((d), (s), (n))\n#endif\n#ifndef bzero\n#define bzero(s, n)\tmemset ((s), 0, (n))\n#endif\n#else\n#include <strings.h>\n#endif\n\n#ifdef STDC_HEADERS\n#include <stdlib.h>\n#else /* not STDC_HEADERS */\n\nchar *malloc ();\nchar *realloc ();\n#endif /* not STDC_HEADERS */\n\n#endif /* not RX_RX_MEMDBUG */\n\n\f\n\n/* Define the syntax basics for \\<, \\>, etc.\n * This must be nonzero for the wordchar and notwordchar pattern\n * commands in re_match_2.\n */\n#ifndef Sword \n#define Sword 1\n#endif\n\n#ifdef SYNTAX_TABLE\nextern char *re_syntax_table;\n#else /* not SYNTAX_TABLE */\n\n/* How many characters in the character set.  */\n#define CHAR_SET_SIZE (1 << BYTEWIDTH)\nstatic char re_syntax_table[CHAR_SET_SIZE];\n\n#ifdef __STDC__\nstatic void\ninit_syntax_once (void)\n#else\nstatic void\ninit_syntax_once ()\n#endif\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}\n#endif /* not SYNTAX_TABLE */\n\n#define SYNTAX(c) re_syntax_table[c]\n\n#endif /* not emacs */\n\n\f\n/* Compile with `-DRX_DEBUG' and use the following flags.\n *\n * Debugging flags:\n *   \trx_debug - print information as a regexp is compiled\n * \trx_debug_trace - print information as a regexp is executed\n */\n\n#ifdef RX_DEBUG\n\nint rx_debug_compile = 0;\nint rx_debug_trace = 0;\nstatic struct re_pattern_buffer * dbug_rxb = 0;\n\n#ifdef __STDC__\ntypedef void (*side_effect_printer) (struct rx *, void *, FILE *);\n#else\ntypedef void (*side_effect_printer) ();\n#endif\n\n#ifdef __STDC__\nstatic void print_cset (struct rx *rx, rx_Bitset cset, FILE * fp);\n#else\nstatic void print_cset ();\n#endif\n\n#ifdef __STDC__\nstatic void\nprint_rexp (struct rx *rx,\n\t    struct rexp_node *node, int depth,\n\t    side_effect_printer seprint, FILE * fp)\n#else\nstatic void\nprint_rexp (rx, node, depth, seprint, fp)\n     struct rx *rx;\n     struct rexp_node *node;\n     int depth;\n     side_effect_printer seprint;\n     FILE * fp;\n#endif\n{\n  if (!node)\n    return;\n  else\n    {\n      switch (node->type)\n\t{\n\tcase r_cset:\n\t  {\n\t    fprintf (fp, \"%*s\", depth, \"\");\n\t    print_cset (rx, node->params.cset, fp);\n\t    fputc ('\\n', fp);\n\t    break;\n\t  }\n\n \tcase r_opt:\n\tcase r_star:\n\t  fprintf (fp, \"%*s%s\\n\", depth, \"\",\n\t\t   node->type == r_opt ? \"opt\" : \"star\");\n\t  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);\n\t  break;\n\n\tcase r_2phase_star:\n\t  fprintf (fp, \"%*s2phase star\\n\", depth, \"\");\n\t  print_rexp (rx, node->params.pair.right, depth + 3, seprint, fp);\n\t  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);\n\t  break;\n\n\n\tcase r_alternate:\n\tcase r_concat:\n\t  fprintf (fp, \"%*s%s\\n\", depth, \"\",\n\t\t   node->type == r_alternate ? \"alt\" : \"concat\");\n\t  print_rexp (rx, node->params.pair.left, depth + 3, seprint, fp);\n\t  print_rexp (rx, node->params.pair.right, depth + 3, seprint, fp);\n\t  break;\n\tcase r_side_effect:\n\t  fprintf (fp, \"%*sSide effect: \", depth, \"\");\n\t  seprint (rx, node->params.side_effect, fp);\n\t  fputc ('\\n', fp);\n\t}\n    }\n}\n\n\n#ifdef __STDC__\nstatic void\nprint_nfa (struct rx * rx,\n\t   struct rx_nfa_state * n,\n\t   side_effect_printer seprint, FILE * fp)\n#else\nstatic void\nprint_nfa (rx, n, seprint, fp)\n     struct rx * rx;\n     struct rx_nfa_state * n;\n     side_effect_printer seprint;\n     FILE * fp;\n#endif\n{\n  while (n)\n    {\n      struct rx_nfa_edge *e = n->edges;\n      struct rx_possible_future *ec = n->futures;\n      fprintf (fp, \"node %d %s\\n\", n->id,\n\t       n->is_final ? \"final\" : (n->is_start ? \"start\" : \"\"));\n      while (e)\n\t{\n\t  fprintf (fp, \"   edge to %d, \", e->dest->id);\n\t  switch (e->type)\n\t    {\n\t    case ne_epsilon:\n\t      fprintf (fp, \"epsilon\\n\");\n\t      break;\n\t    case ne_side_effect:\n\t      fprintf (fp, \"side effect \");\n\t      seprint (rx, e->params.side_effect, fp);\n\t      fputc ('\\n', fp);\n\t      break;\n\t    case ne_cset:\n\t      fprintf (fp, \"cset \");\n\t      print_cset (rx, e->params.cset, fp);\n\t      fputc ('\\n', fp);\n\t      break;\n\t    }\n\t  e = e->next;\n\t}\n\n      while (ec)\n\t{\n\t  int x;\n\t  struct rx_nfa_state_set * s;\n\t  struct rx_se_list * l;\n\t  fprintf (fp, \"   eclosure to {\");\n\t  for (s = ec->destset; s; s = s->cdr)\n\t    fprintf (fp, \"%d \", s->car->id);\n\t  fprintf (fp, \"} (\");\n\t  for (l = ec->effects; l; l = l->cdr)\n\t    {\n\t      seprint (rx, l->car, fp);\n\t      fputc (' ', fp);\n\t    }\n\t  fprintf (fp, \")\\n\");\n\t  ec = ec->next;\n\t}\n      n = n->next;\n    }\n}\n\nstatic char * efnames [] =\n{\n  \"bogon\",\n  \"re_se_try\",\n  \"re_se_pushback\",\n  \"re_se_push0\",\n  \"re_se_pushpos\",\n  \"re_se_chkpos\",\n  \"re_se_poppos\",\n  \"re_se_at_dot\",\n  \"re_se_syntax\",\n  \"re_se_not_syntax\",\n  \"re_se_begbuf\",\n  \"re_se_hat\",\n  \"re_se_wordbeg\",\n  \"re_se_wordbound\",\n  \"re_se_notwordbound\",\n  \"re_se_wordend\",\n  \"re_se_endbuf\",\n  \"re_se_dollar\",\n  \"re_se_fail\",\n};\n\nstatic char * efnames2[] =\n{\n  \"re_se_win\"\n  \"re_se_lparen\",\n  \"re_se_rparen\",\n  \"re_se_backref\",\n  \"re_se_iter\",\n  \"re_se_end_iter\",\n  \"re_se_tv\"\n};\n\nstatic char * inx_names[] = \n{\n  \"rx_backtrack_point\",\n  \"rx_do_side_effects\",\n  \"rx_cache_miss\",\n  \"rx_next_char\",\n  \"rx_backtrack\",\n  \"rx_error_inx\",\n  \"rx_num_instructions\"\n};\n\n\n#ifdef __STDC__\nstatic void\nre_seprint (struct rx * rx, void * effect, FILE * fp)\n#else\nstatic void\nre_seprint (rx, effect, fp)\n     struct rx * rx;\n     void * effect;\n     FILE * fp;\n#endif\n{\n  if ((int)effect < 0)\n    fputs (efnames[-(int)effect], fp);\n  else if (dbug_rxb)\n    {\n      struct re_se_params * p = &dbug_rxb->se_params[(int)effect];\n      fprintf (fp, \"%s(%d,%d)\", efnames2[p->se], p->op1, p->op2);\n    }\n  else\n    fprintf (fp, \"[complex op # %d]\", (int)effect);\n}\n\n\n/* These are for so the regex.c regression tests will compile. */\nvoid\nprint_compiled_pattern (rxb)\n     struct re_pattern_buffer * rxb;\n{\n}\n\nvoid\nprint_fastmap (fm)\n     char * fm;\n{\n}\n\n\n\n#endif /* RX_DEBUG */\n\n\f\n\n/* This page: Bitsets.  Completely unintersting. */\n\n#if 0\n#ifdef __STDC__\nRX_DECL int\nrx_bitset_is_equal (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL int\nrx_bitset_is_equal (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  RX_subset s = b[0];\n  b[0] = ~a[0];\n\n  for (x = rx_bitset_numb_subsets(size) - 1; a[x] == b[x]; --x)\n    ;\n\n  b[0] = s;\n  return !x && s == a[0];\n}\n#endif\n\n#ifdef __STDC__\nRX_DECL int\nrx_bitset_is_subset (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL int\nrx_bitset_is_subset (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x = rx_bitset_numb_subsets(size) - 1;\n  while (x-- && (a[x] & b[x]) == a[x]);\n  return x == -1;\n}\n\n\n#if 0\n#ifdef __STDC__\nRX_DECL int\nrx_bitset_empty (int size, rx_Bitset set)\n#else\nRX_DECL int\nrx_bitset_empty (size, set)\n     int size;\n     rx_Bitset set;\n#endif\n{\n  int x;\n  RX_subset s = set[0];\n  set[0] = 1;\n  for (x = rx_bitset_numb_subsets(size) - 1; !set[x]; --x)\n    ;\n  set[0] = s;\n  return !s;\n}\n#endif\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_null (int size, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_null (size, b)\n     int size;\n     rx_Bitset b;\n#endif\n{\n  bzero (b, rx_sizeof_bitset(size));\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_universe (int size, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_universe (size, b)\n     int size;\n     rx_Bitset b;\n#endif\n{\n  int x = rx_bitset_numb_subsets (size);\n  while (x--)\n    *b++ = ~(RX_subset)0;\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_complement (int size, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_complement (size, b)\n     int size;\n     rx_Bitset b;\n#endif\n{\n  int x = rx_bitset_numb_subsets (size);\n  while (x--)\n    {\n      *b = ~*b;\n      ++b;\n    }\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_assign (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_assign (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] = b[x];\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_union (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_union (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] |= b[x];\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_intersection (int size,\n\t\t\trx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_intersection (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] &= b[x];\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_difference (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_difference (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] &=  ~ b[x];\n}\n\n\n#if 0\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_revdifference (int size,\n\t\t\t rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_revdifference (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] = ~a[x] & b[x];\n}\n\n#ifdef __STDC__\nRX_DECL void\nrx_bitset_xor (int size, rx_Bitset a, rx_Bitset b)\n#else\nRX_DECL void\nrx_bitset_xor (size, a, b)\n     int size;\n     rx_Bitset a;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  for (x = rx_bitset_numb_subsets(size) - 1; x >=0; --x)\n    a[x] ^= b[x];\n}\n#endif\n\n\n#ifdef __STDC__\nRX_DECL unsigned long\nrx_bitset_hash (int size, rx_Bitset b)\n#else\nRX_DECL unsigned long\nrx_bitset_hash (size, b)\n     int size;\n     rx_Bitset b;\n#endif\n{\n  int x;\n  unsigned long hash = (unsigned long)rx_bitset_hash;\n\n  for (x = rx_bitset_numb_subsets(size) - 1; x >= 0; --x)\n    hash ^= rx_bitset_subset_val(b, x);\n\n  return hash;\n}\n\n\nRX_DECL RX_subset rx_subset_singletons [RX_subset_bits] = \n{\n  0x1,\n  0x2,\n  0x4,\n  0x8,\n  0x10,\n  0x20,\n  0x40,\n  0x80,\n  0x100,\n  0x200,\n  0x400,\n  0x800,\n  0x1000,\n  0x2000,\n  0x4000,\n  0x8000,\n  0x10000,\n  0x20000,\n  0x40000,\n  0x80000,\n  0x100000,\n  0x200000,\n  0x400000,\n  0x800000,\n  0x1000000,\n  0x2000000,\n  0x4000000,\n  0x8000000,\n  0x10000000,\n  0x20000000,\n  0x40000000,\n  0x80000000\n};\n\n#ifdef RX_DEBUG\n\n#ifdef __STDC__\nstatic void\nprint_cset (struct rx *rx, rx_Bitset cset, FILE * fp)\n#else\nstatic void\nprint_cset (rx, cset, fp)\n     struct rx *rx;\n     rx_Bitset cset;\n     FILE * fp;\n#endif\n{\n  int x;\n  fputc ('[', fp);\n  for (x = 0; x < rx->local_cset_size; ++x)\n    if (isprint(x) && RX_bitset_member (cset, x))\n      fputc (x, fp);\n  fputc (']', fp);\n}\n\n#endif /*  RX_DEBUG */\n\n\f\n\nstatic unsigned long rx_hash_masks[4] =\n{\n  0x12488421,\n  0x96699669,\n  0xbe7dd7eb,\n  0xffffffff\n};\n\n\n/* Hash tables */\n#ifdef __STDC__\nRX_DECL struct rx_hash_item * \nrx_hash_find (struct rx_hash * table,\n\t      unsigned long hash,\n\t      void * value,\n\t      struct rx_hash_rules * rules)\n#else\nRX_DECL struct rx_hash_item * \nrx_hash_find (table, hash, value, rules)\n     struct rx_hash * table;\n     unsigned long hash;\n     void * value;\n     struct rx_hash_rules * rules;\n#endif\n{\n  rx_hash_eq eq = rules->eq;\n  int maskc = 0;\n  int mask = rx_hash_masks [0];\n  int bucket = (hash & mask) % 13;\n\n  while (table->children [bucket])\n    {\n      table = table->children [bucket];\n      ++maskc;\n      mask = rx_hash_masks[maskc];\n      bucket = (hash & mask) % 13;\n    }\n\n  {\n    struct rx_hash_item * it = table->buckets[bucket];\n    while (it)\n      if (eq (it->data, value))\n\treturn it;\n      else\n\tit = it->next_same_hash;\n  }\n\n  return 0;\n}\n\n#ifdef __STDC__\nRX_DECL struct rx_hash_item *\nrx_hash_store (struct rx_hash * table,\n\t       unsigned long hash,\n\t       void * value,\n\t       struct rx_hash_rules * rules)\n#else\nRX_DECL struct rx_hash_item *\nrx_hash_store (table, hash, value, rules)\n     struct rx_hash * table;\n     unsigned long hash;\n     void * value;\n     struct rx_hash_rules * rules;\n#endif\n{\n  rx_hash_eq eq = rules->eq;\n  int maskc = 0;\n  int mask = rx_hash_masks[0];\n  int bucket = (hash & mask) % 13;\n  int depth = 0;\n  \n  while (table->children [bucket])\n    {\n      table = table->children [bucket];\n      ++maskc;\n      mask = rx_hash_masks[maskc];\n      bucket = (hash & mask) % 13;\n      ++depth;\n    }\n  \n  {\n    struct rx_hash_item * it = table->buckets[bucket];\n    while (it)\n      if (eq (it->data, value))\n\treturn it;\n      else\n\tit = it->next_same_hash;\n  }\n  \n  {\n    if (   (depth < 3)\n\t&& (table->bucket_size [bucket] >= 4))\n      {\n\tstruct rx_hash * newtab = ((struct rx_hash *)\n\t\t\t\t   rules->hash_alloc (rules));\n\tif (!newtab)\n\t  goto add_to_bucket;\n\tbzero (newtab, sizeof (*newtab));\n\tnewtab->parent = table;\n\t{\n\t  struct rx_hash_item * them = table->buckets[bucket];\n\t  unsigned long newmask = rx_hash_masks[maskc + 1];\n\t  while (them)\n\t    {\n\t      struct rx_hash_item * save = them->next_same_hash;\n\t      int new_buck = (them->hash & newmask) % 13;\n\t      them->next_same_hash = newtab->buckets[new_buck];\n\t      newtab->buckets[new_buck] = them;\n\t      them->table = newtab;\n\t      them = save;\n\t      ++newtab->bucket_size[new_buck];\n\t      ++newtab->refs;\n\t    }\n\t  table->refs = (table->refs - table->bucket_size[bucket] + 1);\n\t  table->bucket_size[bucket] = 0;\n\t  table->buckets[bucket] = 0;\n\t  table->children[bucket] = newtab;\n\t  table = newtab;\n\t  bucket = (hash & newmask) % 13;\n\t}\n      }\n  }\n add_to_bucket:\n  {\n    struct rx_hash_item  * it = ((struct rx_hash_item *)\n\t\t\t\t rules->hash_item_alloc (rules, value));\n    if (!it)\n      return 0;\n    it->hash = hash;\n    it->table = table;\n    /* DATA and BINDING are to be set in hash_item_alloc */\n    it->next_same_hash = table->buckets [bucket];\n    table->buckets[bucket] = it;\n    ++table->bucket_size [bucket];\n    ++table->refs;\n    return it;\n  }\n}\n\n#ifdef __STDC__\nRX_DECL void\nrx_hash_free (struct rx_hash_item * it, struct rx_hash_rules * rules)\n#else\nRX_DECL void\nrx_hash_free (it, rules)\n     struct rx_hash_item * it;\n     struct rx_hash_rules * rules;\n#endif\n{\n  if (it)\n    {\n      struct rx_hash * table = it->table;\n      unsigned long hash = it->hash;\n      int depth = (table->parent\n\t\t   ? (table->parent->parent\n\t\t      ? (table->parent->parent->parent\n\t\t\t ? 3\n\t\t\t : 2)\n\t\t      : 1)\n\t\t   : 0);\n      int bucket = (hash & rx_hash_masks [depth]) % 13;\n      struct rx_hash_item ** pos = &table->buckets [bucket];\n      \n      while (*pos != it)\n\tpos = &(*pos)->next_same_hash;\n      *pos = it->next_same_hash;\n     /* rules->free_hash_item (it, rules); */ free(it);\n      --table->bucket_size[bucket];\n      --table->refs;\n      while (!table->refs && depth)\n\t{\n\t  struct rx_hash * save = table;\n\t  table = table->parent;\n\t  --depth;\n\t  bucket = (hash & rx_hash_masks [depth]) % 13;\n\t  --table->refs;\n\t  table->children[bucket] = 0;\n\t /*  rules->free_hash (save, rules); */ free(save);\n\t}\n    }\n}\n\n#ifdef __STDC__\ntypedef void (*rx_hash_freefn) (struct rx_hash_item * it);\n#else /* ndef __STDC__ */\ntypedef void (*rx_hash_freefn) ();\n#endif /* ndef __STDC__ */\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_hash_table (struct rx_hash * tab, rx_hash_freefn freefn,\n\t\t    struct rx_hash_rules * rules)\n#else\nRX_DECL void\nrx_free_hash_table (tab, freefn, rules)\n     struct rx_hash * tab;\n     rx_hash_freefn freefn;\n     struct rx_hash_rules * rules;\n#endif\n{\n  int x;\n\n  for (x = 0; x < 13; ++x)\n    if (tab->children[x])\n      {\n\trx_free_hash_table (tab->children[x], freefn, rules);\n/* \trules->free_hash (tab->children[x], rules); */ free(tab->children[x]);\n      }\n    else\n      {\n\tstruct rx_hash_item * them = tab->buckets[x];\n\twhile (them)\n\t  {\n\t    struct rx_hash_item * that = them;\n\t    them = that->next_same_hash;\n\t    freefn (that);\n/* \t    rules->free_hash_item (that, rules); */ free(that);\n\t  }\n      }\n}\n\n\n\f\n/* Utilities for manipulating bitset represntations of characters sets. */\n\n#ifdef __STDC__\nRX_DECL rx_Bitset\nrx_cset (struct rx *rx)\n#else\nRX_DECL rx_Bitset\nrx_cset (rx)\n     struct rx *rx;\n#endif\n{\n  rx_Bitset b = (rx_Bitset) malloc (rx_sizeof_bitset (rx->local_cset_size));\n  if (b)\n    rx_bitset_null (rx->local_cset_size, b);\n  return b;\n}\n\n\n#ifdef __STDC__\nRX_DECL rx_Bitset\nrx_copy_cset (struct rx *rx, rx_Bitset a)\n#else\nRX_DECL rx_Bitset\nrx_copy_cset (rx, a)\n     struct rx *rx;\n     rx_Bitset a;\n#endif\n{\n  rx_Bitset cs = rx_cset (rx);\n\n  if (cs)\n    rx_bitset_union (rx->local_cset_size, cs, a);\n\n  return cs;\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_cset (struct rx * rx, rx_Bitset c)\n#else\nRX_DECL void\nrx_free_cset (rx, c)\n     struct rx * rx;\n     rx_Bitset c;\n#endif\n{\n  if (c)\n    free ((char *)c);\n}\n\n\f\n/* Hash table memory allocation policy for the regexp compiler */\n\n#ifdef __STDC__\nstruct rx_hash *\ncompiler_hash_alloc (struct rx_hash_rules * rules)\n#else\nstruct rx_hash *\ncompiler_hash_alloc (rules)\n     struct rx_hash_rules * rules;\n#endif\n{\n  return (struct rx_hash *)malloc (sizeof (struct rx_hash));\n}\n\n#ifdef __STDC__\nstruct rx_hash_item *\ncompiler_hash_item_alloc (struct rx_hash_rules * rules, void * value)\n#else\nstruct rx_hash_item *\ncompiler_hash_item_alloc (rules, value)\n     struct rx_hash_rules * rules;\n     void * value;\n#endif\n{\n  struct rx_hash_item * it;\n  it = (struct rx_hash_item *)malloc (sizeof (*it));\n  if (it)\n    {\n      it->data = value;\n      it->binding = 0;\n    }\n  return it;\n}\n\n#ifdef __STDC__\nvoid\ncompiler_free_hash (struct rx_hash * tab,\n\t\t    struct rx_hash_rules * rules)\n#else\nvoid\ncompiler_free_hash (tab, rules)\n     struct rx_hash * tab;\n     struct rx_hash_rules * rules;\n#endif\n{\n  free ((char *)tab);\n}\n\n#ifdef __STDC__\nvoid\ncompiler_free_hash_item (struct rx_hash_item * item,\n\t\t\t struct rx_hash_rules * rules)\n#else\nvoid\ncompiler_free_hash_item (item, rules)\n     struct rx_hash_item * item;\n     struct rx_hash_rules * rules;\n#endif\n{\n  free ((char *)item);\n}\n\n\f\n/* This page: REXP_NODE (expression tree) structures. */\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrexp_node (struct rx *rx,\n\t   enum rexp_node_type type)\n#else\nRX_DECL struct rexp_node *\nrexp_node (rx, type)\n     struct rx *rx;\n     enum rexp_node_type type;\n#endif\n{\n  struct rexp_node *n;\n\n  n = (struct rexp_node *)malloc (sizeof (*n));\n  bzero (n, sizeof (*n));\n  if (n)\n    n->type = type;\n  return n;\n}\n\n\n/* free_rexp_node assumes that the bitset passed to rx_mk_r_cset\n * can be freed using rx_free_cset.\n */\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_cset (struct rx * rx,\n\t      rx_Bitset b)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_cset (rx, b)\n     struct rx * rx;\n     rx_Bitset b;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_cset);\n  if (n)\n    n->params.cset = b;\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_concat (struct rx * rx,\n\t\tstruct rexp_node * a,\n\t\tstruct rexp_node * b)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_concat (rx, a, b)\n     struct rx * rx;\n     struct rexp_node * a;\n     struct rexp_node * b;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_concat);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = b;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_alternate (struct rx * rx,\n\t\t   struct rexp_node * a,\n\t\t   struct rexp_node * b)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_alternate (rx, a, b)\n     struct rx * rx;\n     struct rexp_node * a;\n     struct rexp_node * b;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_alternate);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = b;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_opt (struct rx * rx,\n\t     struct rexp_node * a)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_opt (rx, a)\n     struct rx * rx;\n     struct rexp_node * a;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_opt);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = 0;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_star (struct rx * rx,\n\t      struct rexp_node * a)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_star (rx, a)\n     struct rx * rx;\n     struct rexp_node * a;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_star);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = 0;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_2phase_star (struct rx * rx,\n\t\t     struct rexp_node * a,\n\t\t     struct rexp_node * b)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_2phase_star (rx, a, b)\n     struct rx * rx;\n     struct rexp_node * a;\n     struct rexp_node * b;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_2phase_star);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = b;\n    }\n  return n;\n}\n\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_side_effect (struct rx * rx,\n\t\t     rx_side_effect a)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_side_effect (rx, a)\n     struct rx * rx;\n     rx_side_effect a;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_side_effect);\n  if (n)\n    {\n      n->params.side_effect = a;\n      n->params.pair.right = 0;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node *\nrx_mk_r_data  (struct rx * rx,\n\t       void * a)\n#else\nRX_DECL struct rexp_node *\nrx_mk_r_data  (rx, a)\n     struct rx * rx;\n     void * a;\n#endif\n{\n  struct rexp_node * n = rexp_node (rx, r_data);\n  if (n)\n    {\n      n->params.pair.left = a;\n      n->params.pair.right = 0;\n    }\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_rexp (struct rx * rx, struct rexp_node * node)\n#else\nRX_DECL void\nrx_free_rexp (rx, node)\n     struct rx * rx;\n     struct rexp_node * node;\n#endif\n{\n  if (node)\n    {\n      switch (node->type)\n\t{\n\tcase r_cset:\n\t  if (node->params.cset)\n\t    rx_free_cset (rx, node->params.cset);\n\n\tcase r_side_effect:\n\t  break;\n\t  \n\tcase r_concat:\n\tcase r_alternate:\n\tcase r_2phase_star:\n\tcase r_opt:\n\tcase r_star:\n\t  rx_free_rexp (rx, node->params.pair.left);\n\t  rx_free_rexp (rx, node->params.pair.right);\n\t  break;\n\n\tcase r_data:\n\t  /* This shouldn't occur. */\n\t  break;\n\t}\n      free ((char *)node);\n    }\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rexp_node * \nrx_copy_rexp (struct rx *rx,\n\t   struct rexp_node *node)\n#else\nRX_DECL struct rexp_node * \nrx_copy_rexp (rx, node)\n     struct rx *rx;\n     struct rexp_node *node;\n#endif\n{\n  if (!node)\n    return 0;\n  else\n    {\n      struct rexp_node *n = rexp_node (rx, node->type);\n      if (!n)\n\treturn 0;\n      switch (node->type)\n\t{\n\tcase r_cset:\n\t  n->params.cset = rx_copy_cset (rx, node->params.cset);\n\t  if (!n->params.cset)\n\t    {\n\t      rx_free_rexp (rx, n);\n\t      return 0;\n\t    }\n\t  break;\n\n\tcase r_side_effect:\n\t  n->params.side_effect = node->params.side_effect;\n\t  break;\n\n\tcase r_concat:\n\tcase r_alternate:\n\tcase r_opt:\n\tcase r_2phase_star:\n\tcase r_star:\n\t  n->params.pair.left =\n\t    rx_copy_rexp (rx, node->params.pair.left);\n\t  n->params.pair.right =\n\t    rx_copy_rexp (rx, node->params.pair.right);\n\t  if (   (node->params.pair.left && !n->params.pair.left)\n\t      || (node->params.pair.right && !n->params.pair.right))\n\t    {\n\t      rx_free_rexp  (rx, n);\n\t      return 0;\n\t    }\n\t  break;\n\tcase r_data:\n\t  /* shouldn't happen */\n\t  break;\n\t}\n      return n;\n    }\n}\n\n\n\f\n/* This page: functions to build and destroy graphs that describe nfa's */\n\n/* Constructs a new nfa node. */\n#ifdef __STDC__\nRX_DECL struct rx_nfa_state *\nrx_nfa_state (struct rx *rx)\n#else\nRX_DECL struct rx_nfa_state *\nrx_nfa_state (rx)\n     struct rx *rx;\n#endif\n{\n  struct rx_nfa_state * n = (struct rx_nfa_state *)malloc (sizeof (*n));\n  if (!n)\n    return 0;\n  bzero (n, sizeof (*n));\n  n->next = rx->nfa_states;\n  rx->nfa_states = n;\n  return n;\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_nfa_state (struct rx_nfa_state * n)\n#else\nRX_DECL void\nrx_free_nfa_state (n)\n  struct rx_nfa_state * n;\n#endif\n{\n  free ((char *)n);\n}\n\n\n/* This looks up an nfa node, given a numeric id.  Numeric id's are\n * assigned after the nfa has been built.\n */\n#ifdef __STDC__\nRX_DECL struct rx_nfa_state * \nrx_id_to_nfa_state (struct rx * rx,\n\t\t    int id)\n#else\nRX_DECL struct rx_nfa_state * \nrx_id_to_nfa_state (rx, id)\n     struct rx * rx;\n     int id;\n#endif\n{\n  struct rx_nfa_state * n;\n  for (n = rx->nfa_states; n; n = n->next)\n    if (n->id == id)\n      return n;\n  return 0;\n}\n\n\n/* This adds an edge between two nodes, but doesn't initialize the \n * edge label.\n */\n\n#ifdef __STDC__\nRX_DECL struct rx_nfa_edge * \nrx_nfa_edge (struct rx *rx,\n\t     enum rx_nfa_etype type,\n\t     struct rx_nfa_state *start,\n\t     struct rx_nfa_state *dest)\n#else\nRX_DECL struct rx_nfa_edge * \nrx_nfa_edge (rx, type, start, dest)\n     struct rx *rx;\n     enum rx_nfa_etype type;\n     struct rx_nfa_state *start;\n     struct rx_nfa_state *dest;\n#endif\n{\n  struct rx_nfa_edge *e;\n  e = (struct rx_nfa_edge *)malloc (sizeof (*e));\n  if (!e)\n    return 0;\n  e->next = start->edges;\n  start->edges = e;\n  e->type = type;\n  e->dest = dest;\n  return e;\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_nfa_edge (struct rx_nfa_edge * e)\n#else\nRX_DECL void\nrx_free_nfa_edge (e)\n     struct rx_nfa_edge * e;\n#endif\n{\n  free ((char *)e);\n}\n\n\n/* This constructs a POSSIBLE_FUTURE, which is a kind epsilon-closure\n * of an NFA.  These are added to an nfa automaticly by eclose_nfa.\n */  \n\n#ifdef __STDC__\nstatic struct rx_possible_future * \nrx_possible_future (struct rx * rx,\n\t\t struct rx_se_list * effects)\n#else\nstatic struct rx_possible_future * \nrx_possible_future (rx, effects)\n     struct rx * rx;\n     struct rx_se_list * effects;\n#endif\n{\n  struct rx_possible_future *ec;\n  ec = (struct rx_possible_future *) malloc (sizeof (*ec));\n  if (!ec)\n    return 0;\n  ec->destset = 0;\n  ec->next = 0;\n  ec->effects = effects;\n  return ec;\n}\n\n\n#ifdef __STDC__\nstatic void\nrx_free_possible_future (struct rx_possible_future * pf)\n#else\nstatic void\nrx_free_possible_future (pf)\n     struct rx_possible_future * pf;\n#endif\n{\n  free ((char *)pf);\n}\n\n\n#ifdef __STDC__\nRX_DECL void\nrx_free_nfa (struct rx *rx)\n#else\nRX_DECL void\nrx_free_nfa (rx)\n     struct rx *rx;\n#endif\n{\n  while (rx->nfa_states)\n    {\n      while (rx->nfa_states->edges)\n\t{\n\t  switch (rx->nfa_states->edges->type)\n\t    {\n\t    case ne_cset:\n\t      rx_free_cset (rx, rx->nfa_states->edges->params.cset);\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  {\n\t    struct rx_nfa_edge * e;\n\t    e = rx->nfa_states->edges;\n\t    rx->nfa_states->edges = rx->nfa_states->edges->next;\n\t    rx_free_nfa_edge (e);\n\t  }\n\t} /* while (rx->nfa_states->edges) */\n      {\n\t/* Iterate over the partial epsilon closures of rx->nfa_states */\n\tstruct rx_possible_future * pf = rx->nfa_states->futures;\n\twhile (pf)\n\t  {\n\t    struct rx_possible_future * pft = pf;\n\t    pf = pf->next;\n\t    rx_free_possible_future (pft);\n\t  }\n      }\n      {\n\tstruct rx_nfa_state *n;\n\tn = rx->nfa_states;\n\trx->nfa_states = rx->nfa_states->next;\n\trx_free_nfa_state (n);\n      }\n    }\n}\n\n\n\f\n/* This page: translating a pattern expression in to an nfa and doing the \n * static part of the nfa->super-nfa translation.\n */\n\n/* This is the thompson regexp->nfa algorithm. */\n#ifdef __STDC__\nRX_DECL int\nrx_build_nfa (struct rx *rx,\n\t      struct rexp_node *rexp,\n\t      struct rx_nfa_state **start,\n\t      struct rx_nfa_state **end)\n#else\nRX_DECL int\nrx_build_nfa (rx, rexp, start, end)\n     struct rx *rx;\n     struct rexp_node *rexp;\n     struct rx_nfa_state **start;\n     struct rx_nfa_state **end;\n#endif\n{\n  struct rx_nfa_edge *edge;\n\n  /* Start & end nodes may have been allocated by the caller. */\n  *start = *start ? *start : rx_nfa_state (rx);\n\n  if (!*start)\n    return 0;\n\n  if (!rexp)\n    {\n      *end = *start;\n      return 1;\n    }\n\n  *end = *end ? *end : rx_nfa_state (rx);\n\n  if (!*end)\n    {\n      rx_free_nfa_state (*start);\n      return 0;\n    }\n\n  switch (rexp->type)\n    {\n    case r_data:\n      return 0;\n\n    case r_cset:\n      edge = rx_nfa_edge (rx, ne_cset, *start, *end);\n      if (!edge)\n\treturn 0;\n      edge->params.cset = rx_copy_cset (rx, rexp->params.cset);\n      if (!edge->params.cset)\n\t{\n\t  rx_free_nfa_edge (edge);\n\t  return 0;\n\t}\n      return 1;\n \n    case r_opt:\n      return (rx_build_nfa (rx, rexp->params.pair.left, start, end)\n\t      && rx_nfa_edge (rx, ne_epsilon, *start, *end));\n\n    case r_star:\n      {\n\tstruct rx_nfa_state * star_start = 0;\n\tstruct rx_nfa_state * star_end = 0;\n\treturn (rx_build_nfa (rx, rexp->params.pair.left,\n\t\t\t      &star_start, &star_end)\n\t\t&& star_start\n\t\t&& star_end\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_start, star_end)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, *start, star_start)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_end, *end)\n\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_end, star_start));\n      }\n\n    case r_2phase_star:\n      {\n\tstruct rx_nfa_state * star_start = 0;\n\tstruct rx_nfa_state * star_end = 0;\n\tstruct rx_nfa_state * loop_exp_start = 0;\n\tstruct rx_nfa_state * loop_exp_end = 0;\n\n\treturn (rx_build_nfa (rx, rexp->params.pair.left,\n\t\t\t      &star_start, &star_end)\n\t\t&& rx_build_nfa (rx, rexp->params.pair.right,\n\t\t\t\t &loop_exp_start, &loop_exp_end)\n\t\t&& star_start\n\t\t&& star_end\n\t\t&& loop_exp_end\n\t\t&& loop_exp_start\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_start, *end)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, *start, star_start)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_end, *end)\n\n\t\t&& rx_nfa_edge (rx, ne_epsilon, star_end, loop_exp_start)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, loop_exp_end, star_start));\n      }\n\n\n    case r_concat:\n      {\n\tstruct rx_nfa_state *shared = 0;\n\treturn\n\t  (rx_build_nfa (rx, rexp->params.pair.left, start, &shared)\n\t   && rx_build_nfa (rx, rexp->params.pair.right, &shared, end));\n      }\n\n    case r_alternate:\n      {\n\tstruct rx_nfa_state *ls = 0;\n\tstruct rx_nfa_state *le = 0;\n\tstruct rx_nfa_state *rs = 0;\n\tstruct rx_nfa_state *re = 0;\n\treturn (rx_build_nfa (rx, rexp->params.pair.left, &ls, &le)\n\t\t&& rx_build_nfa (rx, rexp->params.pair.right, &rs, &re)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, *start, ls)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, *start, rs)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, le, *end)\n\t\t&& rx_nfa_edge (rx, ne_epsilon, re, *end));\n      }\n\n    case r_side_effect:\n      edge = rx_nfa_edge (rx, ne_side_effect, *start, *end);\n      if (!edge)\n\treturn 0;\n      edge->params.side_effect = rexp->params.side_effect;\n      return 1;\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\n\n/* NAME_RX->NFA_STATES identifies all nodes with non-epsilon transitions.\n * These nodes can occur in super-states.  All nodes are given an integer id.\n * The id is non-negative if the node has non-epsilon out-transitions, negative\n * otherwise (this is because we want the non-negative ids to be used as \n * array indexes in a few places).\n */\n\n#ifdef __STDC__\nRX_DECL void\nrx_name_nfa_states (struct rx *rx)\n#else\nRX_DECL void\nrx_name_nfa_states (rx)\n     struct rx *rx;\n#endif\n{\n  struct rx_nfa_state *n = rx->nfa_states;\n\n  rx->nodec = 0;\n  rx->epsnodec = -1;\n\n  while (n)\n    {\n      struct rx_nfa_edge *e = n->edges;\n\n      if (n->is_start)\n\tn->eclosure_needed = 1;\n\n      while (e)\n\t{\n\t  switch (e->type)\n\t    {\n\t    case ne_epsilon:\n\t    case ne_side_effect:\n\t      break;\n\n\t    case ne_cset:\n\t      n->id = rx->nodec++;\n\t      {\n\t\tstruct rx_nfa_edge *from_n = n->edges;\n\t\twhile (from_n)\n\t\t  {\n\t\t    from_n->dest->eclosure_needed = 1;\n\t\t    from_n = from_n->next;\n\t\t  }\n\t      }\n\t      goto cont;\n\t    }\n\t  e = e->next;\n\t}\n      n->id = rx->epsnodec--;\n    cont:\n      n = n->next;\n    }\n  rx->epsnodec = -rx->epsnodec;\n}\n\n\f\n/* This page: data structures for the static part of the nfa->supernfa\n * translation.\n */\n\n/* The next several functions compare, construct, etc. lists of side\n * effects.  See ECLOSE_NFA (below) for details.\n */\n\n/* Ordering of rx_se_list\n * (-1, 0, 1 return value convention).\n */\n\n#ifdef __STDC__\nstatic int \nse_list_cmp (void * va, void * vb)\n#else\nstatic int \nse_list_cmp (va, vb)\n     void * va;\n     void * vb;\n#endif\n{\n  struct rx_se_list * a = (struct rx_se_list *)va;\n  struct rx_se_list * b = (struct rx_se_list *)vb;\n\n  return ((va == vb)\n\t  ? 0\n\t  : (!va\n\t     ? -1\n\t     : (!vb\n\t\t? 1\n\t\t: ((long)a->car < (long)b->car\n\t\t   ? 1\n\t\t   : ((long)a->car > (long)b->car\n\t\t      ? -1\n\t\t      : se_list_cmp ((void *)a->cdr, (void *)b->cdr))))));\n}\n\n\n#ifdef __STDC__\nstatic int \nse_list_equal (void * va, void * vb)\n#else\nstatic int \nse_list_equal (va, vb)\n     void * va;\n     void * vb;\n#endif\n{\n  return !(se_list_cmp (va, vb));\n}\n\nstatic struct rx_hash_rules se_list_hash_rules =\n{\n  se_list_equal,\n  compiler_hash_alloc,\n  compiler_free_hash,\n  compiler_hash_item_alloc,\n  compiler_free_hash_item\n};\n\n\n#ifdef __STDC__\nstatic struct rx_se_list * \nside_effect_cons (struct rx * rx,\n\t\t  void * se, struct rx_se_list * list)\n#else\nstatic struct rx_se_list * \nside_effect_cons (rx, se, list)\n     struct rx * rx;\n     void * se;\n     struct rx_se_list * list;\n#endif\n{\n  struct rx_se_list * l;\n  l = ((struct rx_se_list *) malloc (sizeof (*l)));\n  if (!l)\n    return 0;\n  l->car = se;\n  l->cdr = list;\n  return l;\n}\n\n\n#ifdef __STDC__\nstatic struct rx_se_list *\nhash_cons_se_prog (struct rx * rx,\n\t\t   struct rx_hash * memo,\n\t\t   void * car, struct rx_se_list * cdr)\n#else\nstatic struct rx_se_list *\nhash_cons_se_prog (rx, memo, car, cdr)\n     struct rx * rx;\n     struct rx_hash * memo;\n     void * car;\n     struct rx_se_list * cdr;\n#endif\n{\n  long hash = (long)car ^ (long)cdr;\n  struct rx_se_list template;\n\n  template.car = car;\n  template.cdr = cdr;\n  {\n    struct rx_hash_item * it = rx_hash_store (memo, hash,\n\t\t\t\t\t      (void *)&template,\n\t\t\t\t\t      &se_list_hash_rules);\n    if (!it)\n      return 0;\n    if (it->data == (void *)&template)\n      {\n\tstruct rx_se_list * consed;\n\tconsed = (struct rx_se_list *) malloc (sizeof (*consed));\n\t*consed = template;\n\tit->data = (void *)consed;\n      }\n    return (struct rx_se_list *)it->data;\n  }\n}\n     \n\n#ifdef __STDC__\nstatic struct rx_se_list *\nhash_se_prog (struct rx * rx, struct rx_hash * memo, struct rx_se_list * prog)\n#else\nstatic struct rx_se_list *\nhash_se_prog (rx, memo, prog)\n     struct rx * rx;\n     struct rx_hash * memo;\n     struct rx_se_list * prog;\n#endif\n{\n  struct rx_se_list * answer = 0;\n  while (prog)\n    {\n      answer = hash_cons_se_prog (rx, memo, prog->car, answer);\n      if (!answer)\n\treturn 0;\n      prog = prog->cdr;\n    }\n  return answer;\n}\n\n\f\n/* This page: more data structures for nfa->supernfa.  Specificly,\n * sets of nfa states.\n */\n\n#ifdef __STDC__\nstatic int \nnfa_set_cmp (void * va, void * vb)\n#else\nstatic int \nnfa_set_cmp (va, vb)\n     void * va;\n     void * vb;\n#endif\n{\n  struct rx_nfa_state_set * a = (struct rx_nfa_state_set *)va;\n  struct rx_nfa_state_set * b = (struct rx_nfa_state_set *)vb;\n\n  return ((va == vb)\n\t  ? 0\n\t  : (!va\n\t     ? -1\n\t     : (!vb\n\t\t? 1\n\t\t: (a->car->id < b->car->id\n\t\t   ? 1\n\t\t   : (a->car->id > b->car->id\n\t\t      ? -1\n\t\t      : nfa_set_cmp ((void *)a->cdr, (void *)b->cdr))))));\n}\n\n#ifdef __STDC__\nstatic int \nnfa_set_equal (void * va, void * vb)\n#else\nstatic int \nnfa_set_equal (va, vb)\n     void * va;\n     void * vb;\n#endif\n{\n  return !nfa_set_cmp (va, vb);\n}\n\nstatic struct rx_hash_rules nfa_set_hash_rules =\n{\n  nfa_set_equal,\n  compiler_hash_alloc,\n  compiler_free_hash,\n  compiler_hash_item_alloc,\n  compiler_free_hash_item\n};\n\n\n/* CONS -- again, sets with == elements are ==. */\n\n#ifdef __STDC__\nstatic struct rx_nfa_state_set * \nnfa_set_cons (struct rx * rx,\n\t      struct rx_hash * memo, struct rx_nfa_state * state,\n\t      struct rx_nfa_state_set * set)\n#else\nstatic struct rx_nfa_state_set * \nnfa_set_cons (rx, memo, state, set)\n     struct rx * rx;\n     struct rx_hash * memo;\n     struct rx_nfa_state * state;\n     struct rx_nfa_state_set * set;\n#endif\n{\n  struct rx_nfa_state_set template;\n  struct rx_hash_item * node;\n  template.car = state;\n  template.cdr = set;\n  node = rx_hash_store (memo,\n\t\t\t(((long)state) >> 8) ^ (long)set,\n\t\t\t&template, &nfa_set_hash_rules);\n  if (!node)\n    return 0;\n  if (node->data == &template)\n    {\n      struct rx_nfa_state_set * l;\n      l = (struct rx_nfa_state_set *) malloc (sizeof (*l));\n      node->data = (void *) l;\n      if (!l)\n\treturn 0;\n      *l = template;\n    }\n  return (struct rx_nfa_state_set *)node->data;\n}\n\n\n#ifdef __STDC__\nstatic struct rx_nfa_state_set * \nnfa_set_enjoin (struct rx * rx,\n\t\tstruct rx_hash * memo, struct rx_nfa_state * state,\n\t\tstruct rx_nfa_state_set * set)\n#else\nstatic struct rx_nfa_state_set * \nnfa_set_enjoin (rx, memo, state, set)\n     struct rx * rx;\n     struct rx_hash * memo;\n     struct rx_nfa_state * state;\n     struct rx_nfa_state_set * set;\n#endif\n{\n  if (!set || state->id < set->car->id)\n    return nfa_set_cons (rx, memo, state, set);\n  if (state->id == set->car->id)\n    return set;\n  else\n    {\n      struct rx_nfa_state_set * newcdr\n\t= nfa_set_enjoin (rx, memo, state, set->cdr);\n      if (newcdr != set->cdr)\n\tset = nfa_set_cons (rx, memo, set->car, newcdr);\n      return set;\n    }\n}\n\n\n\f\n/* This page: computing epsilon closures.  The closures aren't total.\n * Each node's closures are partitioned according to the side effects entailed\n * along the epsilon edges.  Return true on success.\n */ \n\nstruct eclose_frame\n{\n  struct rx_se_list *prog_backwards;\n};\n\n\n#ifdef __STDC__\nstatic int \neclose_node (struct rx *rx, struct rx_nfa_state *outnode,\n\t     struct rx_nfa_state *node, struct eclose_frame *frame)\n#else\nstatic int \neclose_node (rx, outnode, node, frame)\n     struct rx *rx;\n     struct rx_nfa_state *outnode;\n     struct rx_nfa_state *node;\n     struct eclose_frame *frame;\n#endif\n{\n  struct rx_nfa_edge *e = node->edges;\n\n  /* For each node, we follow all epsilon paths to build the closure.\n   * The closure omits nodes that have only epsilon edges.\n   * The closure is split into partial closures -- all the states in\n   * a partial closure are reached by crossing the same list of\n   * of side effects (though not necessarily the same path).\n   */\n  if (node->mark)\n    return 1;\n  node->mark = 1;\n\n  if (node->id >= 0 || node->is_final)\n    {\n      struct rx_possible_future **ec;\n      struct rx_se_list * prog_in_order\n\t= ((struct rx_se_list *)hash_se_prog (rx,\n\t\t\t\t\t      &rx->se_list_memo,\n\t\t\t\t\t      frame->prog_backwards));\n      int cmp;\n\n      ec = &outnode->futures;\n\n      while (*ec)\n\t{\n\t  cmp = se_list_cmp ((void *)(*ec)->effects, (void *)prog_in_order);\n\t  if (cmp <= 0)\n\t    break;\n\t  ec = &(*ec)->next;\n\t}\n      if (!*ec || (cmp < 0))\n\t{\n\t  struct rx_possible_future * saved = *ec;\n\t  *ec = rx_possible_future (rx, prog_in_order);\n\t  (*ec)->next = saved;\n\t  if (!*ec)\n\t    return 0;\n\t}\n      if (node->id >= 0)\n\t{\n\t  (*ec)->destset = nfa_set_enjoin (rx, &rx->set_list_memo,\n\t\t\t\t\t   node, (*ec)->destset);\n\t  if (!(*ec)->destset)\n\t    return 0;\n\t}\n    }\n\n  while (e)\n    {\n      switch (e->type)\n\t{\n\tcase ne_epsilon:\n\t  if (!eclose_node (rx, outnode, e->dest, frame))\n\t    return 0;\n\t  break;\n\tcase ne_side_effect:\n\t  {\n\t    frame->prog_backwards = side_effect_cons (rx, \n\t\t\t\t\t\t      e->params.side_effect,\n\t\t\t\t\t\t      frame->prog_backwards);\n\t    if (!frame->prog_backwards)\n\t      return 0;\n\t    if (!eclose_node (rx, outnode, e->dest, frame))\n\t      return 0;\n\t    {\n\t      struct rx_se_list * dying = frame->prog_backwards;\n\t      frame->prog_backwards = frame->prog_backwards->cdr;\n\t      free ((char *)dying);\n\t    }\n\t    break;\n\t  }\n\tdefault:\n\t  break;\n\t}\n      e = e->next;\n    }\n  node->mark = 0;\n  return 1;\n}\n\n\n#ifdef __STDC__\nRX_DECL int \nrx_eclose_nfa (struct rx *rx)\n#else\nRX_DECL int \nrx_eclose_nfa (rx)\n     struct rx *rx;\n#endif\n{\n  struct rx_nfa_state *n = rx->nfa_states;\n  struct eclose_frame frame;\n  static int rx_id = 0;\n  \n  frame.prog_backwards = 0;\n  rx->rx_id = rx_id++;\n  bzero (&rx->se_list_memo, sizeof (rx->se_list_memo));\n  bzero (&rx->set_list_memo, sizeof (rx->set_list_memo));\n  while (n)\n    {\n      n->futures = 0;\n      if (n->eclosure_needed && !eclose_node (rx, n, n, &frame))\n\treturn 0;\n      /* clear_marks (rx); */\n      n = n->next;\n    }\n  return 1;\n}\n\n\n/* This deletes epsilon edges from an NFA.  After running eclose_node,\n * we have no more need for these edges.  They are removed to simplify\n * further operations on the NFA.\n */\n\n#ifdef __STDC__\nRX_DECL void \nrx_delete_epsilon_transitions (struct rx *rx)\n#else\nRX_DECL void \nrx_delete_epsilon_transitions (rx)\n     struct rx *rx;\n#endif\n{\n  struct rx_nfa_state *n = rx->nfa_states;\n  struct rx_nfa_edge **e;\n\n  while (n)\n    {\n      e = &n->edges;\n      while (*e)\n\t{\n\t  struct rx_nfa_edge *t;\n\t  switch ((*e)->type)\n\t    {\n\t    case ne_epsilon:\n\t    case ne_side_effect:\n\t      t = *e;\n\t      *e = t->next;\n\t      rx_free_nfa_edge (t);\n\t      break;\n\n\t    default:\n\t      e = &(*e)->next;\n\t      break;\n\t    }\n\t}\n      n = n->next;\n    }\n}\n\n\f\n/* This page: storing the nfa in a contiguous region of memory for\n * subsequent conversion to a super-nfa.\n */\n\n\n/* This is for qsort on an array of nfa_states. The order\n * is based on state ids and goes \n *\t\t[0...MAX][MIN..-1] where (MAX>=0) and (MIN<0)\n * This way, positive ids double as array indices.\n */\n\n#ifdef __STDC__\nstatic int \nnfacmp (void * va, void * vb)\n#else\nstatic int \nnfacmp (va, vb)\n     void * va;\n     void * vb;\n#endif\n{\n  struct rx_nfa_state **a = (struct rx_nfa_state **)va;\n  struct rx_nfa_state **b = (struct rx_nfa_state **)vb;\n  return (*a == *b\t\t/* &&&& 3.18 */\n\t  ? 0\n\t  : (((*a)->id < 0) == ((*b)->id < 0)\n\t     ? (((*a)->id  < (*b)->id) ? -1 : 1)\n\t     : (((*a)->id < 0)\n\t\t? 1 : -1)));\n}\n\n#ifdef __STDC__\nstatic int \ncount_hash_nodes (struct rx_hash * st)\n#else\nstatic int \ncount_hash_nodes (st)\n     struct rx_hash * st;\n#endif\n{\n  int x;\n  int count = 0;\n  for (x = 0; x < 13; ++x)\n    count += ((st->children[x])\n\t      ? count_hash_nodes (st->children[x])\n\t      : st->bucket_size[x]);\n  \n  return count;\n}\n\n\n#ifdef __STDC__\nstatic void \nse_memo_freer (struct rx_hash_item * node)\n#else\nstatic void \nse_memo_freer (node)\n     struct rx_hash_item * node;\n#endif\n{\n  free ((char *)node->data);\n}\n\n\n#ifdef __STDC__\nstatic void \nnfa_set_freer (struct rx_hash_item * node)\n#else\nstatic void \nnfa_set_freer (node)\n     struct rx_hash_item * node;\n#endif\n{\n  free ((char *)node->data);\n}\n\n\n/* This copies an entire NFA into a single malloced block of memory.\n * Mostly this is for compatability with regex.c, though it is convenient\n * to have the nfa nodes in an array.\n */\n\n#ifdef __STDC__\nRX_DECL int \nrx_compactify_nfa (struct rx *rx,\n\t\t   void **mem, unsigned long *size)\n#else\nRX_DECL int \nrx_compactify_nfa (rx, mem, size)\n     struct rx *rx;\n     void **mem;\n     unsigned long *size;\n#endif\n{\n  int total_nodec;\n  struct rx_nfa_state *n;\n  int edgec = 0;\n  int eclosec = 0;\n  int se_list_consc = count_hash_nodes (&rx->se_list_memo);\n  int nfa_setc = count_hash_nodes (&rx->set_list_memo);\n  unsigned long total_size;\n\n  /* This takes place in two stages.   First, the total size of the\n   * nfa is computed, then structures are copied.  \n   */   \n  n = rx->nfa_states;\n  total_nodec = 0;\n  while (n)\n    {\n      struct rx_nfa_edge *e = n->edges;\n      struct rx_possible_future *ec = n->futures;\n      ++total_nodec;\n      while (e)\n\t{\n\t  ++edgec;\n\t  e = e->next;\n\t}\n      while (ec)\n\t{\n\t  ++eclosec;\n\t  ec = ec->next;\n\t}\n      n = n->next;\n    }\n\n  total_size = (total_nodec * sizeof (struct rx_nfa_state)\n\t\t+ edgec * rx_sizeof_bitset (rx->local_cset_size)\n\t\t+ edgec * sizeof (struct rx_nfa_edge)\n\t\t+ nfa_setc * sizeof (struct rx_nfa_state_set)\n\t\t+ eclosec * sizeof (struct rx_possible_future)\n\t\t+ se_list_consc * sizeof (struct rx_se_list)\n\t\t+ rx->reserved);\n\n  if (total_size > *size)\n    {\n      *mem = remalloc (*mem, total_size);\n      if (*mem)\n\t*size = total_size;\n      else\n\treturn 0;\n    }\n  /* Now we've allocated the memory; this copies the NFA. */\n  {\n    static struct rx_nfa_state **scratch = 0;\n    static int scratch_alloc = 0;\n    struct rx_nfa_state *state_base = (struct rx_nfa_state *) * mem;\n    struct rx_nfa_state *new_state = state_base;\n    struct rx_nfa_edge *new_edge =\n      (struct rx_nfa_edge *)\n\t((char *) state_base + total_nodec * sizeof (struct rx_nfa_state));\n    struct rx_se_list * new_se_list =\n      (struct rx_se_list *)\n\t((char *)new_edge + edgec * sizeof (struct rx_nfa_edge));\n    struct rx_possible_future *new_close =\n      ((struct rx_possible_future *)\n       ((char *) new_se_list\n\t+ se_list_consc * sizeof (struct rx_se_list)));\n    struct rx_nfa_state_set * new_nfa_set =\n      ((struct rx_nfa_state_set *)\n       ((char *)new_close + eclosec * sizeof (struct rx_possible_future)));\n    char *new_bitset =\n      ((char *) new_nfa_set + nfa_setc * sizeof (struct rx_nfa_state_set));\n    int x;\n    struct rx_nfa_state *n;\n\n    if (scratch_alloc < total_nodec)\n      {\n\tscratch = ((struct rx_nfa_state **)\n\t\t   remalloc (scratch, total_nodec * sizeof (*scratch)));\n\tif (scratch)\n\t  scratch_alloc = total_nodec;\n\telse\n\t  {\n\t    scratch_alloc = 0;\n\t    return 0;\n\t  }\n      }\n\n    for (x = 0, n = rx->nfa_states; n; n = n->next)\n      scratch[x++] = n;\n\n    qsort (scratch, total_nodec,\n\t   sizeof (struct rx_nfa_state *), (int (*)())nfacmp);\n\n    for (x = 0; x < total_nodec; ++x)\n      {\n\tstruct rx_possible_future *eclose = scratch[x]->futures;\n\tstruct rx_nfa_edge *edge = scratch[x]->edges;\n\tstruct rx_nfa_state *cn = new_state++;\n\tcn->futures = 0;\n\tcn->edges = 0;\n\tcn->next = (x == total_nodec - 1) ? 0 : (cn + 1);\n\tcn->id = scratch[x]->id;\n\tcn->is_final = scratch[x]->is_final;\n\tcn->is_start = scratch[x]->is_start;\n\tcn->mark = 0;\n\twhile (edge)\n\t  {\n\t    int indx = (edge->dest->id < 0\n\t\t\t ? (total_nodec + edge->dest->id)\n\t\t\t : edge->dest->id);\n\t    struct rx_nfa_edge *e = new_edge++;\n\t    rx_Bitset cset = (rx_Bitset) new_bitset;\n\t    new_bitset += rx_sizeof_bitset (rx->local_cset_size);\n\t    rx_bitset_null (rx->local_cset_size, cset);\n\t    rx_bitset_union (rx->local_cset_size, cset, edge->params.cset);\n\t    e->next = cn->edges;\n\t    cn->edges = e;\n\t    e->type = edge->type;\n\t    e->dest = state_base + indx;\n\t    e->params.cset = cset;\n\t    edge = edge->next;\n\t  }\n\twhile (eclose)\n\t  {\n\t    struct rx_possible_future *ec = new_close++;\n\t    struct rx_hash_item * sp;\n\t    struct rx_se_list ** sepos;\n\t    struct rx_se_list * sesrc;\n\t    struct rx_nfa_state_set * destlst;\n\t    struct rx_nfa_state_set ** destpos;\n\t    ec->next = cn->futures;\n\t    cn->futures = ec;\n\t    for (sepos = &ec->effects, sesrc = eclose->effects;\n\t\t sesrc;\n\t\t sesrc = sesrc->cdr, sepos = &(*sepos)->cdr)\n\t      {\n\t\tsp = rx_hash_find (&rx->se_list_memo,\n\t\t\t\t   (long)sesrc->car ^ (long)sesrc->cdr,\n\t\t\t\t   sesrc, &se_list_hash_rules);\n\t\tif (sp->binding)\n\t\t  {\n\t\t    sesrc = (struct rx_se_list *)sp->binding;\n\t\t    break;\n\t\t  }\n\t\t*new_se_list = *sesrc;\n\t\tsp->binding = (void *)new_se_list;\n\t\t*sepos = new_se_list;\n\t\t++new_se_list;\n\t      }\n\t    *sepos = sesrc;\n\t    for (destpos = &ec->destset, destlst = eclose->destset;\n\t\t destlst;\n\t\t destpos = &(*destpos)->cdr, destlst = destlst->cdr)\n\t      {\n\t\tsp = rx_hash_find (&rx->set_list_memo,\n\t\t\t\t   ((((long)destlst->car) >> 8)\n\t\t\t\t    ^ (long)destlst->cdr),\n\t\t\t\t   destlst, &nfa_set_hash_rules);\n\t\tif (sp->binding)\n\t\t  {\n\t\t    destlst = (struct rx_nfa_state_set *)sp->binding;\n\t\t    break;\n\t\t  }\n\t\t*new_nfa_set = *destlst;\n\t\tnew_nfa_set->car = state_base + destlst->car->id;\n\t\tsp->binding = (void *)new_nfa_set;\n\t\t*destpos = new_nfa_set;\n\t\t++new_nfa_set;\n\t      }\n\t    *destpos = destlst;\n\t    eclose = eclose->next;\n\t  }\n      }\n  }\n  rx_free_hash_table (&rx->se_list_memo, se_memo_freer, &se_list_hash_rules);\n  bzero (&rx->se_list_memo, sizeof (rx->se_list_memo));\n  rx_free_hash_table (&rx->set_list_memo, nfa_set_freer, &nfa_set_hash_rules);\n  bzero (&rx->set_list_memo, sizeof (rx->set_list_memo));\n\n  rx_free_nfa (rx);\n  rx->nfa_states = (struct rx_nfa_state *)*mem;\n  return 1;\n}\n\n\f\n/* The functions in the next several pages define the lazy-NFA-conversion used\n * by matchers.  The input to this construction is an NFA such as \n * is built by compactify_nfa (rx.c).  The output is the superNFA.\n */\n\f\n\n/* Match engines can use arbitrary values for opcodes.  So, the parse tree \n * is built using instructions names (enum rx_opcode), but the superstate\n * nfa is populated with mystery opcodes (void *).\n *\n * For convenience, here is an id table.  The opcodes are == to their inxs\n *\n * The lables in re_search_2 would make good values for instructions.\n */\n\nvoid * rx_id_instruction_table[rx_num_instructions] =\n{\n  (void *) rx_backtrack_point,\n  (void *) rx_do_side_effects,\n  (void *) rx_cache_miss,\n  (void *) rx_next_char,\n  (void *) rx_backtrack,\n  (void *) rx_error_inx\n};\n\n\f\n\n#ifdef __STDC__ /* Added code begins */\nstatic void\nrx_morecore (struct rx_cache * cache);\n#else\nstatic void\nrx_morecore (cache);\n#endif /* Added code ends */     \n\n/* Memory mgt. for superstate graphs. */\n\n#ifdef __STDC__\nstatic char *\nrx_cache_malloc (struct rx_cache * cache, int bytes)\n#else\nstatic char *\nrx_cache_malloc (cache, bytes)\n     struct rx_cache * cache;\n     int bytes;\n#endif\n{\n  while (cache->bytes_left < bytes)\n    {\n      if (cache->memory_pos)\n\tcache->memory_pos = cache->memory_pos->next;\n      if (!cache->memory_pos)\n\t{\n\t  /* cache->morecore (cache); */ rx_morecore((struct rx_cache *) cache);\n\t  if (!cache->memory_pos)\n\t    return 0;\n\t}\n      cache->bytes_left = cache->memory_pos->bytes;\n      cache->memory_addr = ((char *)cache->memory_pos\n\t\t\t    + sizeof (struct rx_blocklist));\n    }\n  cache->bytes_left -= bytes;\n  {\n    char * addr = cache->memory_addr;\n    cache->memory_addr += bytes;\n    return addr;\n  }\n}\n\n#ifdef __STDC__\nstatic void\nrx_cache_free (struct rx_cache * cache,\n\t       struct rx_freelist ** freelist, char * mem)\n#else\nstatic void\nrx_cache_free (cache, freelist, mem)\n     struct rx_cache * cache;\n     struct rx_freelist ** freelist;\n     char * mem;\n#endif\n{\n  struct rx_freelist * it = (struct rx_freelist *)mem;\n  it->next = *freelist;\n  *freelist = it;\n}\n\n\n/* The partially instantiated superstate graph has a transition \n * table at every node.  There is one entry for every character.\n * This fills in the transition for a set.\n */\n#ifdef __STDC__\nstatic void \ninstall_transition (struct rx_superstate *super,\n\t\t    struct rx_inx *answer, rx_Bitset trcset) \n#else\nstatic void \ninstall_transition (super, answer, trcset)\n     struct rx_superstate *super;\n     struct rx_inx *answer;\n     rx_Bitset trcset;\n#endif\n{\n  struct rx_inx * transitions = super->transitions;\n  int chr;\n  for (chr = 0; chr < 256; )\n    if (!*trcset)\n      {\n\t++trcset;\n\tchr += 32;\n      }\n    else\n      {\n\tRX_subset sub = *trcset;\n\tRX_subset mask = 1;\n\tint bound = chr + 32;\n\twhile (chr < bound)\n\t  {\n\t    if (sub & mask)\n\t      transitions [chr] = *answer;\n\t    ++chr;\n\t    mask <<= 1;\n\t  }\n\t++trcset;\n      }\n}\n\n\n#if 1\nstatic int\nqlen (q)\n     struct rx_superstate * q;\n{\n  int count = 1;\n  struct rx_superstate * it;\n  if (!q)\n    return 0;\n  for (it = q->next_recyclable; it != q; it = it->next_recyclable)\n    ++count;\n  return count;\n}\n\nstatic void\ncheck_cache (cache)\n     struct rx_cache * cache;\n{\n  struct rx_cache * you_fucked_up = 0;\n  int total = cache->superstates;\n  int semi = cache->semifree_superstates;\n  if (semi != qlen (cache->semifree_superstate))\n    check_cache (you_fucked_up);\n  if ((total - semi) != qlen (cache->lru_superstate))\n    check_cache (you_fucked_up);\n}\n#endif\n\n#ifdef __STDC__\nstatic void\nsemifree_superstate (struct rx_cache * cache)\n#else\nstatic void\nsemifree_superstate (cache)\n     struct rx_cache * cache;\n#endif\n{\n  int disqualified = cache->semifree_superstates;\n  if (disqualified == cache->superstates)\n    return;\n  while (cache->lru_superstate->locks)\n    {\n      cache->lru_superstate = cache->lru_superstate->next_recyclable;\n      ++disqualified;\n      if (disqualified == cache->superstates)\n\treturn;\n    }\n  {\n    struct rx_superstate * it = cache->lru_superstate;\n    it->next_recyclable->prev_recyclable = it->prev_recyclable;\n    it->prev_recyclable->next_recyclable = it->next_recyclable;\n    cache->lru_superstate = (it == it->next_recyclable\n\t\t\t     ? 0\n\t\t\t     : it->next_recyclable);\n    if (!cache->semifree_superstate)\n      {\n\tcache->semifree_superstate = it;\n\tit->next_recyclable = it;\n\tit->prev_recyclable = it;\n      }\n    else\n      {\n\tit->prev_recyclable = cache->semifree_superstate->prev_recyclable;\n\tit->next_recyclable = cache->semifree_superstate;\n\tit->prev_recyclable->next_recyclable = it;\n\tit->next_recyclable->prev_recyclable = it;\n      }\n    {\n      struct rx_distinct_future *df;\n      it->is_semifree = 1;\n      ++cache->semifree_superstates;\n      df = it->transition_refs;\n      if (df)\n\t{\n\t  df->prev_same_dest->next_same_dest = 0;\n\t  for (df = it->transition_refs; df; df = df->next_same_dest)\n\t    {\n\t      df->future_frame.inx = cache->instruction_table[rx_cache_miss];\n\t      df->future_frame.data = 0;\n\t      df->future_frame.data_2 = (void *) df;\n\t      /* If there are any NEXT-CHAR instruction frames that\n\t       * refer to this state, we convert them to CACHE-MISS frames.\n\t       */\n\t      if (!df->effects\n\t\t  && (df->edge->options->next_same_super_edge[0]\n\t\t      == df->edge->options))\n\t\tinstall_transition (df->present, &df->future_frame,\n\t\t\t\t    df->edge->cset);\n\t    }\n\t  df = it->transition_refs;\n\t  df->prev_same_dest->next_same_dest = df;\n\t}\n    }\n  }\n}\n\n\n#ifdef __STDC__\nstatic void \nrefresh_semifree_superstate (struct rx_cache * cache,\n\t\t\t     struct rx_superstate * super)\n#else\nstatic void \nrefresh_semifree_superstate (cache, super)\n     struct rx_cache * cache;\n     struct rx_superstate * super;\n#endif\n{\n  struct rx_distinct_future *df;\n\n  if (super->transition_refs)\n    {\n      super->transition_refs->prev_same_dest->next_same_dest = 0; \n      for (df = super->transition_refs; df; df = df->next_same_dest)\n\t{\n\t  df->future_frame.inx = cache->instruction_table[rx_next_char];\n\t  df->future_frame.data = (void *) super->transitions;\n\t  /* CACHE-MISS instruction frames that refer to this state,\n\t   * must be converted to NEXT-CHAR frames.\n\t   */\n\t  if (!df->effects\n\t      && (df->edge->options->next_same_super_edge[0]\n\t\t  == df->edge->options))\n\t    install_transition (df->present, &df->future_frame,\n\t\t\t\tdf->edge->cset);\n\t}\n      super->transition_refs->prev_same_dest->next_same_dest\n\t= super->transition_refs;\n    }\n  if (cache->semifree_superstate == super)\n    cache->semifree_superstate = (super->prev_recyclable == super\n\t\t\t\t  ? 0\n\t\t\t\t  : super->prev_recyclable);\n  super->next_recyclable->prev_recyclable = super->prev_recyclable;\n  super->prev_recyclable->next_recyclable = super->next_recyclable;\n\n  if (!cache->lru_superstate)\n    (cache->lru_superstate\n     = super->next_recyclable\n     = super->prev_recyclable\n     = super);\n  else\n    {\n      super->next_recyclable = cache->lru_superstate;\n      super->prev_recyclable = cache->lru_superstate->prev_recyclable;\n      super->next_recyclable->prev_recyclable = super;\n      super->prev_recyclable->next_recyclable = super;\n    }\n  super->is_semifree = 0;\n  --cache->semifree_superstates;\n}\n\n#ifdef __STDC__\nstatic void\nrx_refresh_this_superstate (struct rx_cache * cache, struct rx_superstate * superstate)\n#else\nstatic void\nrx_refresh_this_superstate (cache, superstate)\n     struct rx_cache * cache;\n     struct rx_superstate * superstate;\n#endif\n{\n  if (superstate->is_semifree)\n    refresh_semifree_superstate (cache, superstate);\n  else if (cache->lru_superstate == superstate)\n    cache->lru_superstate = superstate->next_recyclable;\n  else if (superstate != cache->lru_superstate->prev_recyclable)\n    {\n      superstate->next_recyclable->prev_recyclable\n\t= superstate->prev_recyclable;\n      superstate->prev_recyclable->next_recyclable\n\t= superstate->next_recyclable;\n      superstate->next_recyclable = cache->lru_superstate;\n      superstate->prev_recyclable = cache->lru_superstate->prev_recyclable;\n      superstate->next_recyclable->prev_recyclable = superstate;\n      superstate->prev_recyclable->next_recyclable = superstate;\n    }\n}\n\n#ifdef __STDC__\nstatic void \nrelease_superset_low (struct rx_cache * cache,\n\t\t     struct rx_superset *set)\n#else\nstatic void \nrelease_superset_low (cache, set)\n     struct rx_cache * cache;\n     struct rx_superset *set;\n#endif\n{\n  if (!--set->refs)\n    {\n      if (set->cdr)\n\trelease_superset_low (cache, set->cdr);\n\n      set->starts_for = 0;\n\n      rx_hash_free\n\t(rx_hash_find\n\t (&cache->superset_table,\n\t  (unsigned long)set->car ^ set->id ^ (unsigned long)set->cdr,\n\t  (void *)set,\n\t  &cache->superset_hash_rules),\n\t &cache->superset_hash_rules);\n      rx_cache_free (cache, &cache->free_supersets, (char *)set);\n    }\n}\n\n#ifdef __STDC__\nRX_DECL void \nrx_release_superset (struct rx *rx,\n\t\t     struct rx_superset *set)\n#else\nRX_DECL void \nrx_release_superset (rx, set)\n     struct rx *rx;\n     struct rx_superset *set;\n#endif\n{\n  release_superset_low (rx->cache, set);\n}\n\n/* This tries to add a new superstate to the superstate freelist.\n * It might, as a result, free some edge pieces or hash tables.\n * If nothing can be freed because too many locks are being held, fail.\n */\n\n#ifdef __STDC__\nstatic int\nrx_really_free_superstate (struct rx_cache * cache)\n#else\nstatic int\nrx_really_free_superstate (cache)\n     struct rx_cache * cache;\n#endif\n{\n  int locked_superstates = 0;\n  struct rx_superstate * it;\n\n  if (!cache->superstates)\n    return 0;\n\n  {\n    /* This is a total guess.  The idea is that we should expect as\n     * many misses as we've recently experienced.  I.e., cache->misses\n     * should be the same as cache->semifree_superstates.\n     */\n    while ((cache->hits + cache->misses) > cache->superstates_allowed)\n      {\n\tcache->hits >>= 1;\n\tcache->misses >>= 1;\n      }\n    if (  ((cache->hits + cache->misses) * cache->semifree_superstates)\n\t< (cache->superstates\t\t * cache->misses))\n      {\n\tsemifree_superstate (cache);\n\tsemifree_superstate (cache);\n      }\n  }\n\n  while (cache->semifree_superstate && cache->semifree_superstate->locks)\n    {\n      refresh_semifree_superstate (cache, cache->semifree_superstate);\n      ++locked_superstates;\n      if (locked_superstates == cache->superstates)\n\treturn 0;\n    }\n\n  if (cache->semifree_superstate)\n    {\n      it = cache->semifree_superstate;\n      it->next_recyclable->prev_recyclable = it->prev_recyclable;\n      it->prev_recyclable->next_recyclable = it->next_recyclable;\n      cache->semifree_superstate = ((it == it->next_recyclable)\n\t\t\t\t    ? 0\n\t\t\t\t    : it->next_recyclable);\n      --cache->semifree_superstates;\n    }\n  else\n    {\n      while (cache->lru_superstate->locks)\n\t{\n\t  cache->lru_superstate = cache->lru_superstate->next_recyclable;\n\t  ++locked_superstates;\n\t  if (locked_superstates == cache->superstates)\n\t    return 0;\n\t}\n      it = cache->lru_superstate;\n      it->next_recyclable->prev_recyclable = it->prev_recyclable;\n      it->prev_recyclable->next_recyclable = it->next_recyclable;\n      cache->lru_superstate = ((it == it->next_recyclable)\n\t\t\t\t    ? 0\n\t\t\t\t    : it->next_recyclable);\n    }\n\n  if (it->transition_refs)\n    {\n      struct rx_distinct_future *df;\n      for (df = it->transition_refs,\n\t   df->prev_same_dest->next_same_dest = 0;\n\t   df;\n\t   df = df->next_same_dest)\n\t{\n\t  df->future_frame.inx = cache->instruction_table[rx_cache_miss];\n\t  df->future_frame.data = 0;\n\t  df->future_frame.data_2 = (void *) df;\n\t  df->future = 0;\n\t}\n      it->transition_refs->prev_same_dest->next_same_dest =\n\tit->transition_refs;\n    }\n  {\n    struct rx_super_edge *tc = it->edges;\n    while (tc)\n      {\n\tstruct rx_distinct_future * df;\n\tstruct rx_super_edge *tct = tc->next;\n\tdf = tc->options;\n\tdf->next_same_super_edge[1]->next_same_super_edge[0] = 0;\n\twhile (df)\n\t  {\n\t    struct rx_distinct_future *dft = df;\n\t    df = df->next_same_super_edge[0];\n\t    \n\t    \n\t    if (dft->future && dft->future->transition_refs == dft)\n\t      {\n\t\tdft->future->transition_refs = dft->next_same_dest;\n\t\tif (dft->future->transition_refs == dft)\n\t\t  dft->future->transition_refs = 0;\n\t      }\n\t    dft->next_same_dest->prev_same_dest = dft->prev_same_dest;\n\t    dft->prev_same_dest->next_same_dest = dft->next_same_dest;\n\t    rx_cache_free (cache, &cache->free_discernable_futures,\n\t\t\t   (char *)dft);\n\t  }\n\trx_cache_free (cache, &cache->free_transition_classes, (char *)tc);\n\ttc = tct;\n      }\n  }\n  \n  if (it->contents->superstate == it)\n    it->contents->superstate = 0;\n  release_superset_low (cache, it->contents);\n  rx_cache_free (cache, &cache->free_superstates, (char *)it);\n  --cache->superstates;\n  return 1;\n}\n\n#ifdef __STDC__\nstatic char *\nrx_cache_get (struct rx_cache * cache,\n\t      struct rx_freelist ** freelist)\n#else\nstatic char *\nrx_cache_get (cache, freelist)\n     struct rx_cache * cache;\n     struct rx_freelist ** freelist;\n#endif\n{\n  while (!*freelist && rx_really_free_superstate (cache))\n    ;\n  if (!*freelist)\n    return 0;\n  {\n    struct rx_freelist * it = *freelist;\n    *freelist = it->next;\n    return (char *)it;\n  }\n}\n\n#ifdef __STDC__\nstatic char *\nrx_cache_malloc_or_get (struct rx_cache * cache,\n\t\t\tstruct rx_freelist ** freelist, int bytes)\n#else\nstatic char *\nrx_cache_malloc_or_get (cache, freelist, bytes)\n     struct rx_cache * cache;\n     struct rx_freelist ** freelist;\n     int bytes;\n#endif\n{\n  if (!*freelist)\n    {\n      char * answer = rx_cache_malloc (cache, bytes);\n      if (answer)\n\treturn answer;\n    }\n\n  return rx_cache_get (cache, freelist);\n}\n\n#ifdef __STDC__\nstatic char *\nrx_cache_get_superstate (struct rx_cache * cache)\n#else\nstatic char *\nrx_cache_get_superstate (cache)\n\t  struct rx_cache * cache;\n#endif\n{\n  char * answer;\n  int bytes = (   sizeof (struct rx_superstate)\n\t       +  cache->local_cset_size * sizeof (struct rx_inx));\n  if (!cache->free_superstates\n      && (cache->superstates < cache->superstates_allowed))\n    {\n      answer = rx_cache_malloc (cache, bytes);\n      if (answer)\n\t{\n\t  ++cache->superstates;\n\t  return answer;\n\t}\n    }\n  answer = rx_cache_get (cache, &cache->free_superstates);\n  if (!answer)\n    {\n      answer = rx_cache_malloc (cache, bytes);\n      if (answer)\n\t++cache->superstates_allowed;\n    }\n  ++cache->superstates;\n  return answer;\n}\n\n\f\n\nstatic int\nsupersetcmp (va, vb)\n     void * va;\n     void * vb;\n{\n  struct rx_superset * a = (struct rx_superset *)va;\n  struct rx_superset * b = (struct rx_superset *)vb;\n  return (   (a == b)\n\t  || (a && b && (a->car == b->car) && (a->cdr == b->cdr)));\n}\n\n\n#ifdef __STDC__\nstatic struct rx_hash_item *\nsuperset_allocator (struct rx_hash_rules * rules, void * val)\n#else\nstatic struct rx_hash_item *\nsuperset_allocator (rules, val)\n     struct rx_hash_rules * rules;\n     void * val;\n#endif\n{\n  struct rx_cache * cache\n    = ((struct rx_cache *)\n       ((char *)rules\n\t- (unsigned long)(&((struct rx_cache *)0)->superset_hash_rules)));\n  struct rx_superset * template = (struct rx_superset *)val;\n  struct rx_superset * newset\n    = ((struct rx_superset *)\n       rx_cache_malloc_or_get (cache,\n\t\t\t       &cache->free_supersets,\n\t\t\t       sizeof (*template)));\n  if (!newset)\n    return 0;\n  newset->refs = 0;\n  newset->car = template->car;\n  newset->id = template->car->id;\n  newset->cdr = template->cdr;\n  newset->superstate = 0;\n  rx_protect_superset (rx, template->cdr);\n  newset->hash_item.data = (void *)newset;\n  newset->hash_item.binding = 0;\n  return &newset->hash_item;\n}\n\n#ifdef __STDC__\nstatic struct rx_hash * \nsuper_hash_allocator (struct rx_hash_rules * rules)\n#else\nstatic struct rx_hash * \nsuper_hash_allocator (rules)\n     struct rx_hash_rules * rules;\n#endif\n{\n  struct rx_cache * cache\n    = ((struct rx_cache *)\n       ((char *)rules\n\t- (unsigned long)(&((struct rx_cache *)0)->superset_hash_rules)));\n  return ((struct rx_hash *)\n\t  rx_cache_malloc_or_get (cache,\n\t\t\t\t  &cache->free_hash, sizeof (struct rx_hash)));\n}\n\n\n#ifdef __STDC__\nstatic void\nsuper_hash_liberator (struct rx_hash * hash, struct rx_hash_rules * rules)\n#else\nstatic void\nsuper_hash_liberator (hash, rules)\n     struct rx_hash * hash;\n     struct rx_hash_rules * rules;\n#endif\n{\n  struct rx_cache * cache\n    = ((struct rx_cache *)\n       (char *)rules - (long)(&((struct rx_cache *)0)->superset_hash_rules));\n  rx_cache_free (cache, &cache->free_hash, (char *)hash);\n}\n\n#ifdef __STDC__\nstatic void\nsuperset_hash_item_liberator (struct rx_hash_item * it,\n\t\t\t      struct rx_hash_rules * rules)\n#else\nstatic void\nsuperset_hash_item_liberator (it, rules) /* Well, it does ya know. */\n     struct rx_hash_item * it;\n     struct rx_hash_rules * rules;\n#endif\n{\n}\n\nint rx_cache_bound = 128;\nstatic int rx_default_cache_got = 0;\n\n#ifdef __STDC__\nstatic int\nbytes_for_cache_size (int supers, int cset_size)\n#else\nstatic int\nbytes_for_cache_size (supers, cset_size)\n     int supers;\n     int cset_size;\n#endif\n{\n  return (int)\n    ((float)supers *\n     (  (1.03 * (float) (  rx_sizeof_bitset (cset_size)\n\t\t\t + sizeof (struct rx_super_edge)))\n      + (1.80 * (float) sizeof (struct rx_possible_future))\n      + (float) (  sizeof (struct rx_superstate)\n\t\t + cset_size * sizeof (struct rx_inx))));\n}\n\n#ifdef __STDC__\nstatic void\nrx_morecore (struct rx_cache * cache)\n#else\nstatic void\nrx_morecore (cache)\n     struct rx_cache * cache;\n#endif\n{\n  if (rx_default_cache_got >= rx_cache_bound)\n    return;\n\n  rx_default_cache_got += 16;\n  cache->superstates_allowed = rx_cache_bound;\n  {\n    struct rx_blocklist ** pos = &cache->memory;\n    int size = bytes_for_cache_size (16, cache->local_cset_size);\n    while (*pos)\n      pos = &(*pos)->next;\n    *pos = ((struct rx_blocklist *)\n\t    malloc (size + sizeof (struct rx_blocklist))); \n    if (!*pos)\n      return;\n\n    (*pos)->next = 0;\n    (*pos)->bytes = size;\n    cache->memory_pos = *pos;\n    cache->memory_addr = (char *)*pos + sizeof (**pos);\n    cache->bytes_left = size;\n  }\n}\n\nstatic struct rx_cache default_cache = \n{\n  {\n    supersetcmp,\n    super_hash_allocator,\n    super_hash_liberator,\n    superset_allocator,\n    superset_hash_item_liberator,\n  },\n  0,\n  0,\n  0,\n  0,\n  rx_morecore,\n\n  0,\n  0,\n  0,\n  0,\n  0,\n\n  0,\n  0,\n\n  0,\n\n  0,\n  0,\n  0,\n  0,\n  128,\n\n  256,\n  rx_id_instruction_table,\n\n  {\n    0,\n    0,\n    {0},\n    {0},\n    {0}\n  }\n};\n\n/* This adds an element to a superstate set.  These sets are lists, such\n * that lists with == elements are ==.  The empty set is returned by\n * superset_cons (rx, 0, 0) and is NOT equivelent to \n * (struct rx_superset)0.\n */\n\n#ifdef __STDC__\nRX_DECL struct rx_superset *\nrx_superset_cons (struct rx * rx,\n\t\t  struct rx_nfa_state *car, struct rx_superset *cdr)\n#else\nRX_DECL struct rx_superset *\nrx_superset_cons (rx, car, cdr)\n     struct rx * rx;\n     struct rx_nfa_state *car;\n     struct rx_superset *cdr;\n#endif\n{\n  struct rx_cache * cache = rx->cache;\n  if (!car && !cdr)\n    {\n      if (!cache->empty_superset)\n\t{\n\t  cache->empty_superset\n\t    = ((struct rx_superset *)\n\t       rx_cache_malloc_or_get (cache, &cache->free_supersets,\n\t\t\t\t       sizeof (struct rx_superset)));\n\t  if (!cache->empty_superset)\n\t    return 0;\n\t  bzero (cache->empty_superset, sizeof (struct rx_superset));\n\t  cache->empty_superset->refs = 1000;\n\t}\n      return cache->empty_superset;\n    }\n  {\n    struct rx_superset template;\n    struct rx_hash_item * hit;\n    template.car = car;\n    template.cdr = cdr;\n    template.id = car->id;\n    hit = rx_hash_store (&cache->superset_table,\n\t\t\t (unsigned long)car ^ car->id ^ (unsigned long)cdr,\n\t\t\t (void *)&template,\n\t\t\t &cache->superset_hash_rules);\n    return (hit\n\t    ?  (struct rx_superset *)hit->data\n\t    : 0);\n  }\n}\n\n/* This computes a union of two NFA state sets.  The sets do not have the\n * same representation though.  One is a RX_SUPERSET structure (part\n * of the superstate NFA) and the other is an NFA_STATE_SET (part of the NFA).\n */\n\n#ifdef __STDC__\nRX_DECL struct rx_superset *\nrx_superstate_eclosure_union\n  (struct rx * rx, struct rx_superset *set, struct rx_nfa_state_set *ecl) \n#else\nRX_DECL struct rx_superset *\nrx_superstate_eclosure_union (rx, set, ecl)\n     struct rx * rx;\n     struct rx_superset *set;\n     struct rx_nfa_state_set *ecl;\n#endif\n{\n  if (!ecl)\n    return set;\n\n  if (!set->car)\n    return rx_superset_cons (rx, ecl->car,\n\t\t\t     rx_superstate_eclosure_union (rx, set, ecl->cdr));\n  if (set->car == ecl->car)\n    return rx_superstate_eclosure_union (rx, set, ecl->cdr);\n\n  {\n    struct rx_superset * tail;\n    struct rx_nfa_state * first;\n\n    if (set->car > ecl->car)\n      {\n\ttail = rx_superstate_eclosure_union (rx, set->cdr, ecl);\n\tfirst = set->car;\n      }\n    else\n      {\n\ttail = rx_superstate_eclosure_union (rx, set, ecl->cdr);\n\tfirst = ecl->car;\n      }\n    if (!tail)\n      return 0;\n    else\n      {\n\tstruct rx_superset * answer;\n\tanswer = rx_superset_cons (rx, first, tail);\n\tif (!answer)\n\t  {\n\t    rx_protect_superset (rx, tail);\n\t    rx_release_superset (rx, tail);\n\t  }\n\treturn answer;\n      }\n  }\n}\n\n\n\f\n\n/*\n * This makes sure that a list of rx_distinct_futures contains\n * a future for each possible set of side effects in the eclosure\n * of a given state.  This is some of the work of filling in a\n * superstate transition. \n */\n\n#ifdef __STDC__\nstatic struct rx_distinct_future *\ninclude_futures (struct rx *rx,\n\t\t struct rx_distinct_future *df, struct rx_nfa_state\n\t\t *state, struct rx_superstate *superstate) \n#else\nstatic struct rx_distinct_future *\ninclude_futures (rx, df, state, superstate)\n     struct rx *rx;\n     struct rx_distinct_future *df;\n     struct rx_nfa_state *state;\n     struct rx_superstate *superstate;\n#endif\n{\n  struct rx_possible_future *future;\n  struct rx_cache * cache = rx->cache;\n  for (future = state->futures; future; future = future->next)\n    {\n      struct rx_distinct_future *dfp;\n      struct rx_distinct_future *insert_before = 0;\n      if (df)\n\tdf->next_same_super_edge[1]->next_same_super_edge[0] = 0;\n      for (dfp = df; dfp; dfp = dfp->next_same_super_edge[0])\n\tif (dfp->effects == future->effects)\n\t  break;\n\telse\n\t  {\n\t    int order = rx->se_list_cmp (rx, dfp->effects, future->effects);\n\t    if (order > 0)\n\t      {\n\t\tinsert_before = dfp;\n\t\tdfp = 0;\n\t\tbreak;\n\t      }\n\t  }\n      if (df)\n\tdf->next_same_super_edge[1]->next_same_super_edge[0] = df;\n      if (!dfp)\n\t{\n\t  dfp\n\t    = ((struct rx_distinct_future *)\n\t       rx_cache_malloc_or_get (cache, &cache->free_discernable_futures,\n\t\t\t\t       sizeof (struct rx_distinct_future)));\n\t  if (!dfp)\n\t    return 0;\n\t  if (!df)\n\t    {\n\t      df = insert_before = dfp;\n\t      df->next_same_super_edge[0] = df->next_same_super_edge[1] = df;\n\t    }\n\t  else if (!insert_before)\n\t    insert_before = df;\n\t  else if (insert_before == df)\n\t    df = dfp;\n\n\t  dfp->next_same_super_edge[0] = insert_before;\n\t  dfp->next_same_super_edge[1]\n\t    = insert_before->next_same_super_edge[1];\n\t  dfp->next_same_super_edge[1]->next_same_super_edge[0] = dfp;\n\t  dfp->next_same_super_edge[0]->next_same_super_edge[1] = dfp;\n\t  dfp->next_same_dest = dfp->prev_same_dest = dfp;\n\t  dfp->future = 0;\n\t  dfp->present = superstate;\n\t  dfp->future_frame.inx = rx->instruction_table[rx_cache_miss];\n\t  dfp->future_frame.data = 0;\n\t  dfp->future_frame.data_2 = (void *) dfp;\n\t  dfp->side_effects_frame.inx\n\t    = rx->instruction_table[rx_do_side_effects];\n\t  dfp->side_effects_frame.data = 0;\n\t  dfp->side_effects_frame.data_2 = (void *) dfp;\n\t  dfp->effects = future->effects;\n\t}\n    }\n  return df;\n}\n\f\n\n\n\n/* This constructs a new superstate from its state set.  The only \n * complexity here is memory management.\n */\n#ifdef __STDC__\nRX_DECL struct rx_superstate *\nrx_superstate (struct rx *rx,\n\t       struct rx_superset *set)\n#else\nRX_DECL struct rx_superstate *\nrx_superstate (rx, set)\n     struct rx *rx;\n     struct rx_superset *set;\n#endif\n{\n  struct rx_cache * cache = rx->cache;\n  struct rx_superstate * superstate = 0;\n\n  /* Does the superstate already exist in the cache? */\n  if (set->superstate)\n    {\n      if (set->superstate->rx_id != rx->rx_id)\n\t{\n\t  /* Aha.  It is in the cache, but belongs to a superstate\n\t   * that refers to an NFA that no longer exists.\n\t   * (We know it no longer exists because it was evidently\n\t   *  stored in the same region of memory as the current nfa\n\t   *  yet it has a different id.)\n\t   */\n\t  superstate = set->superstate;\n\t  if (!superstate->is_semifree)\n\t    {\n\t      if (cache->lru_superstate == superstate)\n\t\t{\n\t\t  cache->lru_superstate = superstate->next_recyclable;\n\t\t  if (cache->lru_superstate == superstate)\n\t\t    cache->lru_superstate = 0;\n\t\t}\n\t      {\n\t\tsuperstate->next_recyclable->prev_recyclable\n\t\t  = superstate->prev_recyclable;\n\t\tsuperstate->prev_recyclable->next_recyclable\n\t\t  = superstate->next_recyclable;\n\t\tif (!cache->semifree_superstate)\n\t\t  {\n\t\t    (cache->semifree_superstate\n\t\t     = superstate->next_recyclable\n\t\t     = superstate->prev_recyclable\n\t\t     = superstate);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    superstate->next_recyclable = cache->semifree_superstate;\n\t\t    superstate->prev_recyclable\n\t\t      = cache->semifree_superstate->prev_recyclable;\n\t\t    superstate->next_recyclable->prev_recyclable\n\t\t      = superstate;\n\t\t    superstate->prev_recyclable->next_recyclable\n\t\t      = superstate;\n\t\t    cache->semifree_superstate = superstate;\n\t\t  }\n\t\t++cache->semifree_superstates;\n\t      }\n\t    }\n\t  set->superstate = 0;\n\t  goto handle_cache_miss;\n\t}\n      ++cache->hits;\n      superstate = set->superstate;\n\n      rx_refresh_this_superstate (cache, superstate);\n      return superstate;\n    }\n\n handle_cache_miss:\n\n  /* This point reached only for cache misses. */\n  ++cache->misses;\n#if RX_DEBUG\n  if (rx_debug_trace > 1)\n    {\n      struct rx_superset * setp = set;\n      fprintf (stderr, \"Building a superstet %d(%d): \", rx->rx_id, set);\n      while (setp)\n\t{\n\t  fprintf (stderr, \"%d \", setp->id);\n\t  setp = setp->cdr;\n\t}\n      fprintf (stderr, \"(%d)\\n\", set);\n    }\n#endif\n  superstate = (struct rx_superstate *)rx_cache_get_superstate (cache);\n  if (!superstate)\n    return 0;\n\n  if (!cache->lru_superstate)\n    (cache->lru_superstate\n     = superstate->next_recyclable\n     = superstate->prev_recyclable\n     = superstate);\n  else\n    {\n      superstate->next_recyclable = cache->lru_superstate;\n      superstate->prev_recyclable = cache->lru_superstate->prev_recyclable;\n      (  superstate->prev_recyclable->next_recyclable\n       = superstate->next_recyclable->prev_recyclable\n       = superstate);\n    }\n  superstate->rx_id = rx->rx_id;\n  superstate->transition_refs = 0;\n  superstate->locks = 0;\n  superstate->is_semifree = 0;\n  set->superstate = superstate;\n  superstate->contents = set;\n  rx_protect_superset (rx, set);\n  superstate->edges = 0;\n  {\n    int x;\n    /* None of the transitions from this superstate are known yet. */\n    for (x = 0; x < rx->local_cset_size; ++x) /* &&&&& 3.8 % */\n      {\n\tstruct rx_inx * ifr = &superstate->transitions[x];\n\tifr->inx = rx->instruction_table [rx_cache_miss];\n\tifr->data = ifr->data_2 = 0;\n      }\n  }\n  return superstate;\n}\n\f\n\n/* This computes the destination set of one edge of the superstate NFA.\n * Note that a RX_DISTINCT_FUTURE is a superstate edge.\n * Returns 0 on an allocation failure.\n */\n\n#ifdef __STDC__\nstatic int \nsolve_destination (struct rx *rx, struct rx_distinct_future *df)\n#else\nstatic int \nsolve_destination (rx, df)\n     struct rx *rx;\n     struct rx_distinct_future *df;\n#endif\n{\n  struct rx_super_edge *tc = df->edge;\n  struct rx_superset *nfa_state;\n  struct rx_superset *nil_set = rx_superset_cons (rx, 0, 0);\n  struct rx_superset *solution = nil_set;\n  struct rx_superstate *dest;\n\n  rx_protect_superset (rx, solution);\n  /* Iterate over all NFA states in the state set of this superstate. */\n  for (nfa_state = df->present->contents;\n       nfa_state->car;\n       nfa_state = nfa_state->cdr)\n    {\n      struct rx_nfa_edge *e;\n      /* Iterate over all edges of each NFA state. */\n      for (e = nfa_state->car->edges; e; e = e->next)\n        /* If we find an edge that is labeled with \n\t * the characters we are solving for.....\n\t */\n\tif (rx_bitset_is_subset (rx->local_cset_size,\n\t\t\t\t tc->cset, e->params.cset))\n\t  {\n\t    struct rx_nfa_state *n = e->dest;\n\t    struct rx_possible_future *pf;\n\t    /* ....search the partial epsilon closures of the destination\n\t     * of that edge for a path that involves the same set of\n\t     * side effects we are solving for.\n\t     * If we find such a RX_POSSIBLE_FUTURE, we add members to the\n\t     * stateset we are computing.\n\t     */\n\t    for (pf = n->futures; pf; pf = pf->next)\n\t      if (pf->effects == df->effects)\n\t\t{\n\t\t  struct rx_superset * old_sol;\n\t\t  old_sol = solution;\n\t\t  solution = rx_superstate_eclosure_union (rx, solution,\n\t\t\t\t\t\t\t   pf->destset);\n\t\t  if (!solution)\n\t\t    return 0;\n\t\t  rx_protect_superset (rx, solution);\n\t\t  rx_release_superset (rx, old_sol);\n\t\t}\n\t  }\n    }\n  /* It is possible that the RX_DISTINCT_FUTURE we are working on has \n   * the empty set of NFA states as its definition.  In that case, this\n   * is a failure point.\n   */\n  if (solution == nil_set)\n    {\n      df->future_frame.inx = (void *) rx_backtrack;\n      df->future_frame.data = 0;\n      df->future_frame.data_2 = 0;\n      return 1;\n    }\n  dest = rx_superstate (rx, solution);\n  rx_release_superset (rx, solution);\n  if (!dest)\n    return 0;\n\n  {\n    struct rx_distinct_future *dft;\n    dft = df;\n    df->prev_same_dest->next_same_dest = 0;\n    while (dft)\n      {\n\tdft->future = dest;\n\tdft->future_frame.inx = rx->instruction_table[rx_next_char];\n\tdft->future_frame.data = (void *) dest->transitions;\n\tdft = dft->next_same_dest;\n      }\n    df->prev_same_dest->next_same_dest = df;\n  }\n  if (!dest->transition_refs)\n    dest->transition_refs = df;\n  else\n    {\n      struct rx_distinct_future *dft = dest->transition_refs->next_same_dest;\n      dest->transition_refs->next_same_dest = df->next_same_dest;\n      df->next_same_dest->prev_same_dest = dest->transition_refs;\n      df->next_same_dest = dft;\n      dft->prev_same_dest = df;\n    }\n  return 1;\n}\n\n\n/* This takes a superstate and a character, and computes some edges\n * from the superstate NFA.  In particular, this computes all edges\n * that lead from SUPERSTATE given CHR.   This function also \n * computes the set of characters that share this edge set.\n * This returns 0 on allocation error.\n * The character set and list of edges are returned through \n * the paramters CSETOUT and DFOUT.\n} */\n\n#ifdef __STDC__\nstatic int \ncompute_super_edge (struct rx *rx, struct rx_distinct_future **dfout,\n\t\t\t  rx_Bitset csetout, struct rx_superstate *superstate,\n\t\t\t  unsigned char chr)  \n#else\nstatic int \ncompute_super_edge (rx, dfout, csetout, superstate, chr)\n     struct rx *rx;\n     struct rx_distinct_future **dfout;\n     rx_Bitset csetout;\n     struct rx_superstate *superstate;\n     unsigned char chr;\n#endif\n{\n  struct rx_superset *stateset = superstate->contents;\n\n  /* To compute the set of characters that share edges with CHR, \n   * we start with the full character set, and subtract.\n   */\n  rx_bitset_universe (rx->local_cset_size, csetout);\n  *dfout = 0;\n\n  /* Iterate over the NFA states in the superstate state-set. */\n  while (stateset->car)\n    {\n      struct rx_nfa_edge *e;\n      for (e = stateset->car->edges; e; e = e->next)\n\tif (RX_bitset_member (e->params.cset, chr))\n\t  {\n\t    /* If we find an NFA edge that applies, we make sure there\n\t     * are corresponding edges in the superstate NFA.\n\t     */\n\t    {\n\t      struct rx_distinct_future * saved;\n\t      saved = *dfout;\n\t      *dfout = include_futures (rx, *dfout, e->dest, superstate);\n\t      if (!*dfout)\n\t\t{\n\t\t  struct rx_distinct_future * df;\n\t\t  df = saved;\n\t\t  df->next_same_super_edge[1]->next_same_super_edge[0] = 0;\n\t\t  while (df)\n\t\t    {\n\t\t      struct rx_distinct_future *dft;\n\t\t      dft = df;\n\t\t      df = df->next_same_super_edge[0];\n\n\t\t      if (dft->future && dft->future->transition_refs == dft)\n\t\t\t{\n\t\t\t  dft->future->transition_refs = dft->next_same_dest;\n\t\t\t  if (dft->future->transition_refs == dft)\n\t\t\t    dft->future->transition_refs = 0;\n\t\t\t}\n\t\t      dft->next_same_dest->prev_same_dest = dft->prev_same_dest;\n\t\t      dft->prev_same_dest->next_same_dest = dft->next_same_dest;\n\t\t      rx_cache_free (rx->cache,\n\t\t\t\t     &rx->cache->free_discernable_futures,\n\t\t\t\t     (char *)dft);\n\t\t    }\n\t\t  return 0;\n\t\t}\n\t    }\n\t    /* We also trim the character set a bit. */\n\t    rx_bitset_intersection (rx->local_cset_size,\n\t\t\t\t    csetout, e->params.cset);\n\t  }\n\telse\n\t  /* An edge that doesn't apply at least tells us some characters\n\t   * that don't share the same edge set as CHR.\n\t   */\n\t  rx_bitset_difference (rx->local_cset_size, csetout, e->params.cset);\n      stateset = stateset->cdr;\n    }\n  return 1;\n}\n\f\n\n/* This is a constructor for RX_SUPER_EDGE structures.  These are\n * wrappers for lists of superstate NFA edges that share character sets labels.\n * If a transition class contains more than one rx_distinct_future (superstate\n * edge), then it represents a non-determinism in the superstate NFA.\n */\n\n#ifdef __STDC__\nstatic struct rx_super_edge *\nrx_super_edge (struct rx *rx,\n\t       struct rx_superstate *super, rx_Bitset cset,\n\t       struct rx_distinct_future *df) \n#else\nstatic struct rx_super_edge *\nrx_super_edge (rx, super, cset, df)\n     struct rx *rx;\n     struct rx_superstate *super;\n     rx_Bitset cset;\n     struct rx_distinct_future *df;\n#endif\n{\n  struct rx_super_edge *tc =\n    (struct rx_super_edge *)rx_cache_malloc_or_get\n      (rx->cache, &rx->cache->free_transition_classes,\n       sizeof (struct rx_super_edge) + rx_sizeof_bitset (rx->local_cset_size));\n\n  if (!tc)\n    return 0;\n  tc->next = super->edges;\n  super->edges = tc;\n  tc->rx_backtrack_frame.inx = rx->instruction_table[rx_backtrack_point];\n  tc->rx_backtrack_frame.data = 0;\n  tc->rx_backtrack_frame.data_2 = (void *) tc;\n  tc->options = df;\n  tc->cset = (rx_Bitset) ((char *) tc + sizeof (*tc));\n  rx_bitset_assign (rx->local_cset_size, tc->cset, cset);\n  if (df)\n    {\n      struct rx_distinct_future * dfp = df;\n      df->next_same_super_edge[1]->next_same_super_edge[0] = 0;\n      while (dfp)\n\t{\n\t  dfp->edge = tc;\n\t  dfp = dfp->next_same_super_edge[0];\n\t}\n      df->next_same_super_edge[1]->next_same_super_edge[0] = df;\n    }\n  return tc;\n}\n\n\n/* There are three kinds of cache miss.  The first occurs when a\n * transition is taken that has never been computed during the\n * lifetime of the source superstate.  That cache miss is handled by\n * calling COMPUTE_SUPER_EDGE.  The second kind of cache miss\n * occurs when the destination superstate of a transition doesn't\n * exist.  SOLVE_DESTINATION is used to construct the destination superstate.\n * Finally, the third kind of cache miss occurs when the destination\n * superstate of a transition is in a `semi-free state'.  That case is\n * handled by UNFREE_SUPERSTATE.\n *\n * The function of HANDLE_CACHE_MISS is to figure out which of these\n * cases applies.\n */\n\n#ifdef __STDC__\nstatic void\ninstall_partial_transition  (struct rx_superstate *super,\n\t\t\t     struct rx_inx *answer,\n\t\t\t     RX_subset set, int offset)\n#else\nstatic void\ninstall_partial_transition  (super, answer, set, offset)\n     struct rx_superstate *super;\n     struct rx_inx *answer;\n     RX_subset set;\n     int offset;\n#endif\n{\n  int start = offset;\n  int end = start + 32;\n  RX_subset pos = 1;\n  struct rx_inx * transitions = super->transitions;\n  \n  while (start < end)\n    {\n      if (set & pos)\n\ttransitions[start] = *answer;\n      pos <<= 1;\n      ++start;\n    }\n}\n\n\n#ifdef __STDC__\nRX_DECL struct rx_inx *\nrx_handle_cache_miss\n  (struct rx *rx, struct rx_superstate *super, unsigned char chr, void *data) \n#else\nRX_DECL struct rx_inx *\nrx_handle_cache_miss (rx, super, chr, data)\n     struct rx *rx;\n     struct rx_superstate *super;\n     unsigned char chr;\n     void *data;\n#endif\n{\n  int offset = chr / RX_subset_bits;\n  struct rx_distinct_future *df = data;\n\n  if (!df)\t\t\t/* must be the shared_cache_miss_frame */\n    {\n      /* Perhaps this is just a transition waiting to be filled. */\n      struct rx_super_edge *tc;\n      RX_subset mask = rx_subset_singletons [chr % RX_subset_bits];\n\n      for (tc = super->edges; tc; tc = tc->next)\n\tif (tc->cset[offset] & mask)\n\t  {\n\t    struct rx_inx * answer;\n\t    df = tc->options;\n\t    answer = ((tc->options->next_same_super_edge[0] != tc->options)\n\t\t      ? &tc->rx_backtrack_frame\n\t\t      : (df->effects\n\t\t\t ? &df->side_effects_frame\n\t\t\t : &df->future_frame));\n\t    install_partial_transition (super, answer,\n\t\t\t\t\ttc->cset [offset], offset * 32);\n\t    return answer;\n\t  }\n      /* Otherwise, it's a flushed or  newly encountered edge. */\n      {\n\tchar cset_space[1024];\t/* this limit is far from unreasonable */\n\trx_Bitset trcset;\n\tstruct rx_inx *answer;\n\n\tif (rx_sizeof_bitset (rx->local_cset_size) > sizeof (cset_space))\n\t  return 0;\t\t/* If the arbitrary limit is hit, always fail */\n\t\t\t\t/* cleanly. */\n\ttrcset = (rx_Bitset)cset_space;\n\trx_lock_superstate (rx, super);\n\tif (!compute_super_edge (rx, &df, trcset, super, chr))\n\t  {\n\t    rx_unlock_superstate (rx, super);\n\t    return 0;\n\t  }\n\tif (!df)\t\t/* We just computed the fail transition. */\n\t  {\n\t    static struct rx_inx\n\t      shared_fail_frame = { (void *)rx_backtrack, 0, 0 };\n\t    answer = &shared_fail_frame;\n\t  }\n\telse\n\t  {\n\t    tc = rx_super_edge (rx, super, trcset, df);\n\t    if (!tc)\n\t      {\n\t\trx_unlock_superstate (rx, super);\n\t\treturn 0;\n\t      }\n\t    answer = ((tc->options->next_same_super_edge[0] != tc->options)\n\t\t      ? &tc->rx_backtrack_frame\n\t\t      : (df->effects\n\t\t\t ? &df->side_effects_frame\n\t\t\t : &df->future_frame));\n\t  }\n\tinstall_partial_transition (super, answer,\n\t\t\t\t    trcset[offset], offset * 32);\n\trx_unlock_superstate (rx, super);\n\treturn answer;\n      }\n    }\n  else if (df->future) /* A cache miss on an edge with a future? Must be\n\t\t\t* a semi-free destination. */\n    {\t\t\t\t\n      if (df->future->is_semifree)\n\trefresh_semifree_superstate (rx->cache, df->future);\n      return &df->future_frame;\n    }\n  else\n    /* no future superstate on an existing edge */\n    {\n      rx_lock_superstate (rx, super);\n      if (!solve_destination (rx, df))\n\t{\n\t  rx_unlock_superstate (rx, super);\n\t  return 0;\n\t}\n      if (!df->effects\n\t  && (df->edge->options->next_same_super_edge[0] == df->edge->options))\n\tinstall_partial_transition (super, &df->future_frame,\n\t\t\t\t    df->edge->cset[offset], offset * 32);\n      rx_unlock_superstate (rx, super);\n      return &df->future_frame;\n    }\n}\n\n\n\f\n\n/* The rest of the code provides a regex.c compatable interface. */\n\n\nconst char *re_error_msg[] =\n{\n  0,\t\t\t\t\t\t/* REG_NOUT */\n  \"No match\",\t\t\t\t\t/* REG_NOMATCH */\n  \"Invalid regular expression\",\t\t\t/* REG_BADPAT */\n  \"Invalid collation character\",\t\t/* REG_ECOLLATE */\n  \"Invalid character class name\",\t\t/* REG_ECTYPE */\n  \"Trailing backslash\",\t\t\t\t/* REG_EESCAPE */\n  \"Invalid back reference\",\t\t\t/* REG_ESUBREG */\n  \"Unmatched [ or [^\",\t\t\t\t/* REG_EBRACK */\n  \"Unmatched ( or \\\\(\",\t\t\t\t/* REG_EPAREN */\n  \"Unmatched \\\\{\",\t\t\t\t/* REG_EBRACE */\n  \"Invalid content of \\\\{\\\\}\",\t\t\t/* REG_BADBR */\n  \"Invalid range end\",\t\t\t\t/* REG_ERANGE */\n  \"Memory exhausted\",\t\t\t\t/* REG_ESPACE */\n  \"Invalid preceding regular expression\",\t/* REG_BADRPT */\n  \"Premature end of regular expression\",\t/* REG_EEND */\n  \"Regular expression too big\",\t\t\t/* REG_ESIZE */\n  \"Unmatched ) or \\\\)\",\t\t\t\t/* REG_ERPAREN */\n};\n\n\n\f\n/* \n * Macros used while compiling patterns.\n *\n * By convention, PEND points just past the end of the uncompiled pattern,\n * P points to the read position in the pattern.  `translate' is the name\n * of the translation table (`TRANSLATE' is the name of a macro that looks\n * things up in `translate').\n */\n\n\n/*\n * Fetch the next character in the uncompiled pattern---translating it \n * if necessary. *Also cast from a signed character in the constant\n * string passed to us by the user to an unsigned char that we can use\n * as an array index (in, e.g., `translate').\n */\n#define PATFETCH(c)\t\t\t\t\t\t\t\\\n do {if (p == pend) return REG_EEND;\t\t\t\t\t\\\n    c = (unsigned char) *p++;\t\t\t\t\t\t\\\n    c = translate[c];\t\t \t\t\t\t\t\\\n } while (0)\n\n/* \n * Fetch the next character in the uncompiled pattern, with no\n * translation.\n */\n#define PATFETCH_RAW(c)\t\t\t\t\t\t\t\\\n  do {if (p == pend) return REG_EEND;\t\t\t\t\t\\\n    c = (unsigned char) *p++; \t\t\t\t\t\t\\\n  } while (0)\n\n/* Go backwards one character in the pattern.  */\n#define PATUNFETCH p--\n\n\n#define TRANSLATE(d) translate[(unsigned char) (d)]\n\ntypedef unsigned regnum_t;\n\n/* Since offsets can go either forwards or backwards, this type needs to\n * be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.\n */\ntypedef int pattern_offset_t;\n\ntypedef struct\n{\n  struct rexp_node ** top_expression; /* was begalt */\n  struct rexp_node ** last_expression; /* was laststart */\n  pattern_offset_t inner_group_offset;\n  regnum_t regnum;\n} compile_stack_elt_t;\n\ntypedef struct\n{\n  compile_stack_elt_t *stack;\n  unsigned size;\n  unsigned avail;\t\t\t/* Offset of next open position.  */\n} compile_stack_type;\n\n\n#define INIT_COMPILE_STACK_SIZE 32\n\n#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)\n#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)\n\n/* The next available element.  */\n#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])\n\n\n/* Set the bit for character C in a list.  */\n#define SET_LIST_BIT(c)                               \\\n  (b[((unsigned char) (c)) / BYTEWIDTH]               \\\n   |= 1 << (((unsigned char) c) % BYTEWIDTH))\n\n/* Get the next unsigned number in the uncompiled pattern.  */\n#define GET_UNSIGNED_NUMBER(num) \t\t\t\t\t\\\n  { if (p != pend)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       PATFETCH (c); \t\t\t\t\t\t\t\\\n       while (isdigit (c)) \t\t\t\t\t\t\\\n         { \t\t\t\t\t\t\t\t\\\n           if (num < 0)\t\t\t\t\t\t\t\\\n              num = 0;\t\t\t\t\t\t\t\\\n           num = num * 10 + c - '0'; \t\t\t\t\t\\\n           if (p == pend) \t\t\t\t\t\t\\\n              break; \t\t\t\t\t\t\t\\\n           PATFETCH (c);\t\t\t\t\t\t\\\n         } \t\t\t\t\t\t\t\t\\\n       } \t\t\t\t\t\t\t\t\\\n    }\t\t\n\n#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */\n\n#define IS_CHAR_CLASS(string)\t\t\t\t\t\t\\\n   (!strcmp (string, \"alpha\") || !strcmp (string, \"upper\")\t\t\\\n    || !strcmp (string, \"lower\") || !strcmp (string, \"digit\")\t\t\\\n    || !strcmp (string, \"alnum\") || !strcmp (string, \"xdigit\")\t\t\\\n    || !strcmp (string, \"space\") || !strcmp (string, \"print\")\t\t\\\n    || !strcmp (string, \"punct\") || !strcmp (string, \"graph\")\t\t\\\n    || !strcmp (string, \"cntrl\") || !strcmp (string, \"blank\"))\n\n\f\n/* These predicates are used in regex_compile. */\n\n/* P points to just after a ^ in PATTERN.  Return true if that ^ comes\n * after an alternative or a begin-subexpression.  We assume there is at\n * least one character before the ^.  \n */\n\n#ifdef __STDC__\nstatic boolean\nat_begline_loc_p (const char *pattern, const char * p, reg_syntax_t syntax)\n#else\nstatic boolean\nat_begline_loc_p (pattern, p, syntax)\n     const char *pattern;\n     const char * p;\n     reg_syntax_t syntax;\n#endif\n{\n  const char *prev = p - 2;\n  boolean prev_prev_backslash = ((prev > pattern) && (prev[-1] == '\\\\'));\n  \n    return\n      \n      (/* After a subexpression?  */\n       ((*prev == '(') && ((syntax & RE_NO_BK_PARENS) || prev_prev_backslash))\n       ||\n       /* After an alternative?  */\n       ((*prev == '|') && ((syntax & RE_NO_BK_VBAR) || prev_prev_backslash))\n       );\n}\n\n/* The dual of at_begline_loc_p.  This one is for $.  We assume there is\n * at least one character after the $, i.e., `P < PEND'.\n */\n\n#ifdef __STDC__\nstatic boolean\nat_endline_loc_p (const char *p, const char *pend, int syntax)\n#else\nstatic boolean\nat_endline_loc_p (p, pend, syntax)\n     const char *p;\n     const char *pend;\n     int syntax;\n#endif\n{\n  const char *next = p;\n  boolean next_backslash = (*next == '\\\\');\n  const char *next_next = (p + 1 < pend) ? (p + 1) : 0;\n  \n  return\n    (\n     /* Before a subexpression?  */\n     ((syntax & RE_NO_BK_PARENS)\n      ? (*next == ')')\n      : (next_backslash && next_next && (*next_next == ')')))\n    ||\n     /* Before an alternative?  */\n     ((syntax & RE_NO_BK_VBAR)\n      ? (*next == '|')\n      : (next_backslash && next_next && (*next_next == '|')))\n     );\n}\n\f\n\nstatic unsigned char id_translation[256] =\n{\n  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n\n 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n 120, 121, 122, 123, 124, 125, 126, 127, 128, 129,\n 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\n 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,\n 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,\n\n 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\n 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,\n 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,\n 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,\n 250, 251, 252, 253, 254, 255\n};\n\n/* The compiler keeps an inverted translation table.\n * This looks up/inititalize elements.\n * VALID is an array of booleans that validate CACHE.\n */\n\n#ifdef __STDC__\nstatic rx_Bitset\ninverse_translation (struct re_pattern_buffer * rxb,\n\t\t     char * valid, rx_Bitset cache,\n\t\t     unsigned char * translate, int c)\n#else\nstatic rx_Bitset\ninverse_translation (rxb, valid, cache, translate, c)\n     struct re_pattern_buffer * rxb;\n     char * valid;\n     rx_Bitset cache;\n     unsigned char * translate;\n     int c;\n#endif\n{\n  rx_Bitset cs\n    = cache + c * rx_bitset_numb_subsets (rxb->rx.local_cset_size); \n\n  if (!valid[c])\n    {\n      int x;\n      int c_tr = TRANSLATE(c);\n      rx_bitset_null (rxb->rx.local_cset_size, cs);\n      for (x = 0; x < 256; ++x)\t/* &&&& 13.37 */\n\tif (TRANSLATE(x) == c_tr)\n\t  RX_bitset_enjoin (cs, x);\n      valid[c] = 1;\n    }\n  return cs;\n}\n\n\f\n\n\n/* More subroutine declarations and macros for regex_compile.  */\n\n/* Returns true if REGNUM is in one of COMPILE_STACK's elements and \n   false if it's not.  */\n\n#ifdef __STDC__\nstatic boolean\ngroup_in_compile_stack (compile_stack_type compile_stack, regnum_t regnum)\n#else\nstatic boolean\ngroup_in_compile_stack (compile_stack, regnum)\n    compile_stack_type compile_stack;\n    regnum_t regnum;\n#endif\n{\n  int this_element;\n\n  for (this_element = compile_stack.avail - 1;  \n       this_element >= 0; \n       this_element--)\n    if (compile_stack.stack[this_element].regnum == regnum)\n      return true;\n\n  return false;\n}\n\n\n/*\n * Read the ending character of a range (in a bracket expression) from the\n * uncompiled pattern *P_PTR (which ends at PEND).  We assume the\n * starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)\n * Then we set the translation of all bits between the starting and\n * ending characters (inclusive) in the compiled pattern B.\n * \n * Return an error code.\n * \n * We use these short variable names so we can use the same macros as\n * `regex_compile' itself.  \n */\n\n#ifdef __STDC__\nstatic reg_errcode_t\ncompile_range (struct re_pattern_buffer * rxb, rx_Bitset cs,\n\t       const char ** p_ptr, const char * pend,\n\t       unsigned char * translate, reg_syntax_t syntax,\n\t       rx_Bitset inv_tr,  char * valid_inv_tr)\n#else\nstatic reg_errcode_t\ncompile_range (rxb, cs, p_ptr, pend, translate, syntax, inv_tr, valid_inv_tr)\n     struct re_pattern_buffer * rxb;\n     rx_Bitset cs;\n     const char ** p_ptr;\n     const char * pend;\n     unsigned char * translate;\n     reg_syntax_t syntax;\n     rx_Bitset inv_tr;\n     char * valid_inv_tr;\n#endif\n{\n  unsigned this_char;\n\n  const char *p = *p_ptr;\n\n  unsigned char range_end;\n  unsigned char range_start = TRANSLATE(p[-2]);\n\n  if (p == pend)\n    return REG_ERANGE;\n\n  PATFETCH (range_end);\n\n  (*p_ptr)++;\n\n  if (range_start > range_end)\n    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;\n\n  for (this_char = range_start; this_char <= range_end; this_char++)\n    {\n      rx_Bitset it =\n\tinverse_translation (rxb, valid_inv_tr, inv_tr, translate, this_char);\n      rx_bitset_union (rxb->rx.local_cset_size, cs, it);\n    }\n  \n  return REG_NOERROR;\n}\n\f\n\n/* This searches a regexp for backreference side effects.\n * It fills in the array OUT with 1 at the index of every register pair\n * referenced by a backreference.\n *\n * This is used to help optimize patterns for searching.  The information is\n * useful because, if the caller doesn't want register values, backreferenced\n * registers are the only registers for which we need rx_backtrack.\n */\n\n#ifdef __STDC__\nstatic void\nfind_backrefs (char * out, struct rexp_node * rexp,\n\t       struct re_se_params * params)\n#else\nstatic void\nfind_backrefs (out, rexp, params)\n     char * out;\n     struct rexp_node * rexp;\n     struct re_se_params * params;\n#endif\n{\n  if (rexp)\n    switch (rexp->type)\n      {\n      case r_cset:\n      case r_data:\n\treturn;\n      case r_alternate:\n      case r_concat:\n      case r_opt:\n      case r_star:\n      case r_2phase_star:\n\tfind_backrefs (out, rexp->params.pair.left, params);\n\tfind_backrefs (out, rexp->params.pair.right, params);\n\treturn;\n      case r_side_effect:\n\tif (   ((int)rexp->params.side_effect >= 0)\n\t    && (params [(int)rexp->params.side_effect].se == re_se_backref))\n\t  out[ params [(int)rexp->params.side_effect].op1] = 1;\n\treturn;\n      }\n}\n\n\f\n\n/* Returns 0 unless the pattern can match the empty string. */\n\n#ifdef __STDC__\nstatic int\ncompute_fastset (struct re_pattern_buffer * rxb, struct rexp_node * rexp)\n#else\nstatic int\ncompute_fastset (rxb, rexp)\n     struct re_pattern_buffer * rxb;\n     struct rexp_node * rexp;\n#endif\n{\n  if (!rexp)\n    return 1;\n  switch (rexp->type)\n    {\n    case r_data:\n      return 1;\n    case r_cset:\n      {\n\trx_bitset_union (rxb->rx.local_cset_size,\n\t\t\t rxb->fastset, rexp->params.cset);\n      }\n      return 0;\n    case r_concat:\n      return (compute_fastset (rxb, rexp->params.pair.left)\n\t      && compute_fastset (rxb, rexp->params.pair.right));\n    case r_2phase_star:\n      compute_fastset (rxb, rexp->params.pair.left);\n      /* compute_fastset (rxb, rexp->params.pair.right);  nope... */\n      return 1;\n    case r_alternate:\n      return !!(compute_fastset (rxb, rexp->params.pair.left)\n\t\t+ compute_fastset (rxb, rexp->params.pair.right));\n    case r_opt:\n    case r_star:\n      compute_fastset (rxb, rexp->params.pair.left);\n      return 1;\n    case r_side_effect:\n      return 1;\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\f\n\n/* returns\n *  1 -- yes, definately anchored by the given side effect.\n *  2 -- maybe anchored, maybe the empty string.\n *  0 -- definately not anchored\n *  There is simply no other possibility.\n */\n\n#ifdef __STDC__\nstatic int\nis_anchored (struct rexp_node * rexp, rx_side_effect se)\n#else\nstatic int\nis_anchored (rexp, se)\n     struct rexp_node * rexp;\n     rx_side_effect se;\n#endif\n{\n  if (!rexp)\n    return 2;\n  switch (rexp->type)\n    {\n    case r_cset:\n    case r_data:\n      return 0;\n    case r_concat:\n    case r_2phase_star:\n      {\n\tint l = is_anchored (rexp->params.pair.left, se);\n\treturn (l == 2 ? is_anchored (rexp->params.pair.right, se) : l);\n      }\n    case r_alternate:\n      {\n\tint l = is_anchored (rexp->params.pair.left, se);\n\tint r = l ? is_anchored (rexp->params.pair.right, se) : 0;\n\treturn MAX (l, r);\n      }\n    case r_opt:\n    case r_star:\n      return is_anchored (rexp->params.pair.left, se) ? 2 : 0;\n      \n    case r_side_effect:\n      return ((rexp->params.side_effect == se)\n\t      ? 1 : 2);\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n/* This removes register assignments that aren't required by backreferencing.\n * This can speed up explore_future, especially if it eliminates\n * non-determinism in the superstate NFA.\n * \n * NEEDED is an array of characters, presumably filled in by FIND_BACKREFS.\n * The non-zero elements of the array indicate which register assignments\n * can NOT be removed from the expression.\n */\n\n#ifdef __STDC__\nstatic struct rexp_node *\nremove_unecessary_side_effects (struct rx * rx, char * needed,\n\t\t\t\tstruct rexp_node * rexp,\n\t\t\t\tstruct re_se_params * params)\n#else\nstatic struct rexp_node *\nremove_unecessary_side_effects (rx, needed, rexp, params)\n     struct rx * rx;\n     char * needed;\n     struct rexp_node * rexp;\n     struct re_se_params * params;\n#endif\n{\n  struct rexp_node * l;\n  struct rexp_node * r;\n  if (!rexp)\n    return 0;\n  else\n    switch (rexp->type)\n      {\n      case r_cset:\n      case r_data:\n\treturn rexp;\n      case r_alternate:\n      case r_concat:\n      case r_2phase_star:\n\tl = remove_unecessary_side_effects (rx, needed,\n\t\t\t\t\t    rexp->params.pair.left, params);\n\tr = remove_unecessary_side_effects (rx, needed,\n\t\t\t\t\t    rexp->params.pair.right, params);\n\tif ((l && r) || (rexp->type != r_concat))\n\t  {\n\t    rexp->params.pair.left = l;\n\t    rexp->params.pair.right = r;\n\t    return rexp;\n\t  }\n\telse\n\t  {\n\t    rexp->params.pair.left = rexp->params.pair.right = 0;\n\t    rx_free_rexp (rx, rexp);\n\t    return l ? l : r;\n\t  }\n      case r_opt:\n      case r_star:\n\tl = remove_unecessary_side_effects (rx, needed,\n\t\t\t\t\t    rexp->params.pair.left, params);\n\tif (l)\n\t  {\n\t    rexp->params.pair.left = l;\n\t    return rexp;\n\t  }\n\telse\n\t  {\n\t    rexp->params.pair.left = 0;\n\t    rx_free_rexp (rx, rexp);\n\t    return 0;\n\t  }\n      case r_side_effect:\n\t{\n\t  int se = (int)rexp->params.side_effect;\n\t  if (   (se >= 0)\n\t      && (   ((enum re_side_effects)params[se].se == re_se_lparen)\n\t\t  || ((enum re_side_effects)params[se].se == re_se_rparen))\n\t      && (params [se].op1 > 0)\n\t      && (!needed [params [se].op1]))\n\t    {\n\t      rx_free_rexp (rx, rexp);\n\t      return 0;\n\t    }\n\t  else\n\t    return rexp;\n\t}\n      }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n\n#ifdef __STDC__\nstatic int\npointless_if_repeated (struct rexp_node * node, struct re_se_params * params)\n#else\nstatic int\npointless_if_repeated (node, params)\n     struct rexp_node * node;\n     struct re_se_params * params;\n#endif\n{\n  if (!node)\n    return 1;\n  switch (node->type)\n    {\n    case r_cset:\n      return 0;\n    case r_alternate:\n    case r_concat:\n    case r_2phase_star:\n      return (pointless_if_repeated (node->params.pair.left, params)\n\t      && pointless_if_repeated (node->params.pair.right, params));\n    case r_opt:\n    case r_star:\n      return pointless_if_repeated (node->params.pair.left, params);\n    case r_side_effect:\n      switch (((int)node->params.side_effect < 0)\n\t      ? (enum re_side_effects)node->params.side_effect\n\t      : (enum re_side_effects)params[(int)node->params.side_effect].se)\n\t{\n\tcase re_se_try:\n\tcase re_se_at_dot:\n\tcase re_se_begbuf:\n\tcase re_se_hat:\n\tcase re_se_wordbeg:\n\tcase re_se_wordbound:\n\tcase re_se_notwordbound:\n\tcase re_se_wordend:\n\tcase re_se_endbuf:\n\tcase re_se_dollar:\n\tcase re_se_fail:\n\tcase re_se_win:\n\t  return 1;\n\tcase re_se_lparen:\n\tcase re_se_rparen:\n\tcase re_se_iter:\n\tcase re_se_end_iter:\n\tcase re_se_syntax:\n\tcase re_se_not_syntax:\n\tcase re_se_backref:\n\t  return 0;\n\t}\n    case r_data:\n    default:\n      return 0;\n    }\n}\n\n\f\n\n#ifdef __STDC__\nstatic int\nregisters_on_stack (struct re_pattern_buffer * rxb,\n\t\t    struct rexp_node * rexp, int in_danger,\n\t\t    struct re_se_params * params)\n#else\nstatic int\nregisters_on_stack (rxb, rexp, in_danger, params)\n     struct re_pattern_buffer * rxb;\n     struct rexp_node * rexp;\n     int in_danger;\n     struct re_se_params * params;\n#endif\n{\n  if (!rexp)\n    return 0;\n  else\n    switch (rexp->type)\n      {\n      case r_cset:\n      case r_data:\n\treturn 0;\n      case r_alternate:\n      case r_concat:\n\treturn (   registers_on_stack (rxb, rexp->params.pair.left,\n\t\t\t\t       in_danger, params)\n\t\t|| (registers_on_stack\n\t\t    (rxb, rexp->params.pair.right,\n\t\t     in_danger, params)));\n      case r_opt:\n\treturn registers_on_stack (rxb, rexp->params.pair.left, 0, params);\n      case r_star:\n\treturn registers_on_stack (rxb, rexp->params.pair.left, 1, params);\n      case r_2phase_star:\n\treturn\n\t  (   registers_on_stack (rxb, rexp->params.pair.left, 1, params)\n\t   || registers_on_stack (rxb, rexp->params.pair.right, 1, params));\n      case r_side_effect:\n\t{\n\t  int se = (int)rexp->params.side_effect;\n\t  if (   in_danger\n\t      && (se >= 0)\n\t      && (params [se].op1 > 0)\n\t      && (   ((enum re_side_effects)params[se].se == re_se_lparen)\n\t\t  || ((enum re_side_effects)params[se].se == re_se_rparen)))\n\t    return 1;\n\t  else\n\t    return 0;\n\t}\n      }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n\nstatic char idempotent_complex_se[] =\n{\n#define RX_WANT_SE_DEFS 1\n#undef RX_DEF_SE\n#undef RX_DEF_CPLX_SE\n#define RX_DEF_SE(IDEM, NAME, VALUE)\t      \n#define RX_DEF_CPLX_SE(IDEM, NAME, VALUE)     IDEM,\n#include \"rx.h\"\n#undef RX_DEF_SE\n#undef RX_DEF_CPLX_SE\n#undef RX_WANT_SE_DEFS\n  23\n};\n\nstatic char idempotent_se[] =\n{\n  13,\n#define RX_WANT_SE_DEFS 1\n#undef RX_DEF_SE\n#undef RX_DEF_CPLX_SE\n#define RX_DEF_SE(IDEM, NAME, VALUE)\t      IDEM,\n#define RX_DEF_CPLX_SE(IDEM, NAME, VALUE)     \n#include \"rx.h\"\n#undef RX_DEF_SE\n#undef RX_DEF_CPLX_SE\n#undef RX_WANT_SE_DEFS\n  42\n};\n\n\f\n\n\n#ifdef __STDC__\nstatic int\nhas_any_se (struct rx * rx,\n\t    struct rexp_node * rexp)\n#else\nstatic int\nhas_any_se (rx, rexp)\n     struct rx * rx;\n     struct rexp_node * rexp;\n#endif\n{\n  if (!rexp)\n    return 0;\n\n  switch (rexp->type)\n    {\n    case r_cset:\n    case r_data:\n      return 0;\n\n    case r_side_effect:\n      return 1;\n      \n    case r_2phase_star:\n    case r_concat:\n    case r_alternate:\n      return\n\t(   has_any_se (rx, rexp->params.pair.left)\n\t || has_any_se (rx, rexp->params.pair.right));\n\n    case r_opt:\n    case r_star:\n      return has_any_se (rx, rexp->params.pair.left);\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n\n/* This must be called AFTER `convert_hard_loops' for a given REXP. */\n#ifdef __STDC__\nstatic int\nhas_non_idempotent_epsilon_path (struct rx * rx,\n\t\t\t\t struct rexp_node * rexp,\n\t\t\t\t struct re_se_params * params)\n#else\nstatic int\nhas_non_idempotent_epsilon_path (rx, rexp, params)\n     struct rx * rx;\n     struct rexp_node * rexp;\n     struct re_se_params * params;\n#endif\n{\n  if (!rexp)\n    return 0;\n\n  switch (rexp->type)\n    {\n    case r_cset:\n    case r_data:\n    case r_star:\n      return 0;\n\n    case r_side_effect:\n      return\n\t!((int)rexp->params.side_effect > 0\n\t  ? idempotent_complex_se [ params [(int)rexp->params.side_effect].se ]\n\t  : idempotent_se [-(int)rexp->params.side_effect]);\n      \n    case r_alternate:\n      return\n\t(   has_non_idempotent_epsilon_path (rx,\n\t\t\t\t\t     rexp->params.pair.left, params)\n\t || has_non_idempotent_epsilon_path (rx,\n\t\t\t\t\t     rexp->params.pair.right, params));\n\n    case r_2phase_star:\n    case r_concat:\n      return\n\t(   has_non_idempotent_epsilon_path (rx,\n\t\t\t\t\t     rexp->params.pair.left, params)\n\t && has_non_idempotent_epsilon_path (rx,\n\t\t\t\t\t     rexp->params.pair.right, params));\n\n    case r_opt:\n      return has_non_idempotent_epsilon_path (rx,\n\t\t\t\t\t      rexp->params.pair.left, params);\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n\n/* This computes rougly what it's name suggests.   It can (and does) go wrong \n * in the direction of returning spurious 0 without causing disasters.\n */\n#ifdef __STDC__\nstatic int\nbegins_with_complex_se (struct rx * rx, struct rexp_node * rexp)\n#else\nstatic int\nbegins_with_complex_se (rx, rexp)\n     struct rx * rx;\n     struct rexp_node * rexp;\n#endif\n{\n  if (!rexp)\n    return 0;\n\n  switch (rexp->type)\n    {\n    case r_cset:\n    case r_data:\n      return 0;\n\n    case r_side_effect:\n      return ((int)rexp->params.side_effect >= 0);\n      \n    case r_alternate:\n      return\n\t(   begins_with_complex_se (rx, rexp->params.pair.left)\n\t && begins_with_complex_se (rx, rexp->params.pair.right));\n\n\n    case r_concat:\n      return has_any_se (rx, rexp->params.pair.left);\n    case r_opt:\n    case r_star:\n    case r_2phase_star:\n      return 0;\n    }\n\n  /* this should never happen */\n  return 0;\n}\n\n\f\n/* This destructively removes some of the re_se_tv side effects from \n * a rexp tree.  In particular, during parsing re_se_tv was inserted on the\n * right half of every | to guarantee that posix path preference could be \n * honored.  This function removes some which it can be determined aren't \n * needed.  \n */\n\n#ifdef __STDC__\nstatic void\nspeed_up_alt (struct rx * rx,\n\t      struct rexp_node * rexp,\n\t      int unposix)\n#else\nstatic void\nspeed_up_alt (rx, rexp, unposix)\n     struct rx * rx;\n     struct rexp_node * rexp;\n     int unposix;\n#endif\n{\n  if (!rexp)\n    return;\n\n  switch (rexp->type)\n    {\n    case r_cset:\n    case r_data:\n    case r_side_effect:\n      return;\n\n    case r_opt:\n    case r_star:\n      speed_up_alt (rx, rexp->params.pair.left, unposix);\n      return;\n\n    case r_2phase_star:\n    case r_concat:\n      speed_up_alt (rx, rexp->params.pair.left, unposix);\n      speed_up_alt (rx, rexp->params.pair.right, unposix);\n      return;\n\n    case r_alternate:\n      /* the right child is guaranteed to be (concat re_se_tv <subexp>) */\n\n      speed_up_alt (rx, rexp->params.pair.left, unposix);\n      speed_up_alt (rx, rexp->params.pair.right->params.pair.right, unposix);\n      \n      if (   unposix\n\t  || (begins_with_complex_se\n\t      (rx, rexp->params.pair.right->params.pair.right))\n\t  || !(   has_any_se (rx, rexp->params.pair.right->params.pair.right)\n\t       || has_any_se (rx, rexp->params.pair.left)))\n\t{\n\t  struct rexp_node * conc = rexp->params.pair.right;\n\t  rexp->params.pair.right = conc->params.pair.right;\n\t  conc->params.pair.right = 0;\n\t  rx_free_rexp (rx, conc);\n\t}\n    }\n}\n\n\n\f\n\n\n/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.\n   Returns one of error codes defined in `regex.h', or zero for success.\n\n   Assumes the `allocated' (and perhaps `buffer') and `translate'\n   fields are set in BUFP on entry.\n\n   If it succeeds, results are put in BUFP (if it returns an error, the\n   contents of BUFP are undefined):\n     `buffer' is the compiled pattern;\n     `syntax' is set to SYNTAX;\n     `used' is set to the length of the compiled pattern;\n     `fastmap_accurate' is set to zero;\n     `re_nsub' is set to the number of groups in PATTERN;\n     `not_bol' and `not_eol' are set to zero.\n   \n   The `fastmap' and `newline_anchor' fields are neither\n   examined nor set.  */\n\n\n\n#ifdef __STDC__\nreg_errcode_t\nrx_compile (const char *pattern, int size,\n\t    reg_syntax_t syntax,\n\t    struct re_pattern_buffer * rxb) \n#else\nreg_errcode_t\nrx_compile (pattern, size, syntax, rxb)\n     const char *pattern;\n     int size;\n     reg_syntax_t syntax;\n     struct re_pattern_buffer * rxb;\n#endif\n{\n  RX_subset\n    inverse_translate [CHAR_SET_SIZE * rx_bitset_numb_subsets(CHAR_SET_SIZE)];\n  char\n    validate_inv_tr [CHAR_SET_SIZE * rx_bitset_numb_subsets(CHAR_SET_SIZE)];\n\n  /* We fetch characters from PATTERN here.  Even though PATTERN is\n     `char *' (i.e., signed), we declare these variables as unsigned, so\n     they can be reliably used as array indices.  */\n  register unsigned char c, c1;\n  \n  /* A random tempory spot in PATTERN.  */\n  const char *p1;\n  \n  /* Keeps track of unclosed groups.  */\n  compile_stack_type compile_stack;\n\n  /* Points to the current (ending) position in the pattern.  */\n  const char *p = pattern;\n  const char *pend = pattern + size;\n  \n  /* How to translate the characters in the pattern.  */\n  unsigned char *translate = (rxb->translate\n\t\t\t      ? (unsigned char *)rxb->translate\n\t\t\t      : (unsigned char *)id_translation);\n\n  /* When parsing is done, this will hold the expression tree. */\n  struct rexp_node * rexp = 0;\n\n  /* In the midst of compilation, this holds onto the regexp \n   * first parst while rexp goes on to aquire additional constructs.\n   */\n  struct rexp_node * orig_rexp = 0;\n  struct rexp_node * fewer_side_effects = 0;\n\n  /* This and top_expression are saved on the compile stack. */\n  struct rexp_node ** top_expression = &rexp;\n  struct rexp_node ** last_expression = top_expression;\n  \n  /* Parameter to `goto append_node' */\n  struct rexp_node * append;\n\n  /* Counts open-groups as they are encountered.  This is the index of the\n   * innermost group being compiled.\n   */\n  regnum_t regnum = 0;\n\n  /* Place in the uncompiled pattern (i.e., the {) to\n   * which to go back if the interval is invalid.  \n   */\n  const char *beg_interval;\n\n  struct re_se_params * params = 0;\n  int paramc = 0;\t\t/* How many complex side effects so far? */\n\n  rx_side_effect side;\t\t/* param to `goto add_side_effect' */\n\n  bzero (validate_inv_tr, sizeof (validate_inv_tr));\n\n  rxb->rx.instruction_table = rx_id_instruction_table;\n\n\n  /* Initialize the compile stack.  */\n  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);\n  if (compile_stack.stack == 0)\n    return REG_ESPACE;\n\n  compile_stack.size = INIT_COMPILE_STACK_SIZE;\n  compile_stack.avail = 0;\n\n  /* Initialize the pattern buffer.  */\n  rxb->rx.cache = &default_cache;\n  rxb->syntax = syntax;\n  rxb->fastmap_accurate = 0;\n  rxb->not_bol = rxb->not_eol = 0;\n  rxb->least_subs = 0;\n  \n  /* Always count groups, whether or not rxb->no_sub is set.  \n   * The whole pattern is implicitly group 0, so counting begins\n   * with 1.\n   */\n  rxb->re_nsub = 0;\n\n#if !defined (emacs) && !defined (SYNTAX_TABLE)\n  /* Initialize the syntax table.  */\n   init_syntax_once ();\n#endif\n\n  /* Loop through the uncompiled pattern until we're at the end.  */\n  while (p != pend)\n    {\n      PATFETCH (c);\n\n      switch (c)\n        {\n        case '^':\n          {\n            if (   /* If at start of pattern, it's an operator.  */\n                   p == pattern + 1\n                   /* If context independent, it's an operator.  */\n                || syntax & RE_CONTEXT_INDEP_ANCHORS\n                   /* Otherwise, depends on what's come before.  */\n                || at_begline_loc_p (pattern, p, syntax))\n\t      {\n\t\tstruct rexp_node * n\n\t\t  = rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)re_se_hat);\n\t\tif (!n)\n\t\t  return REG_ESPACE;\n\t\tappend = n;\n\t\tgoto append_node;\n\t      }\n            else\n              goto normal_char;\n          }\n          break;\n\n\n        case '$':\n          {\n            if (   /* If at end of pattern, it's an operator.  */\n                   p == pend \n                   /* If context independent, it's an operator.  */\n                || syntax & RE_CONTEXT_INDEP_ANCHORS\n                   /* Otherwise, depends on what's next.  */\n                || at_endline_loc_p (p, pend, syntax))\n\t      {\n\t\tstruct rexp_node * n\n\t\t  = rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)re_se_dollar);\n\t\tif (!n)\n\t\t  return REG_ESPACE;\n\t\tappend = n;\n\t\tgoto append_node;\n\t      }\n             else\n               goto normal_char;\n           }\n           break;\n\n\n\tcase '+':\n        case '?':\n          if ((syntax & RE_BK_PLUS_QM)\n              || (syntax & RE_LIMITED_OPS))\n            goto normal_char;\n\n        handle_plus:\n        case '*':\n          /* If there is no previous pattern... */\n          if (pointless_if_repeated (*last_expression, params))\n            {\n              if (syntax & RE_CONTEXT_INVALID_OPS)\n                return REG_BADRPT;\n              else if (!(syntax & RE_CONTEXT_INDEP_OPS))\n                goto normal_char;\n            }\n\n          {\n            /* 1 means zero (many) matches is allowed.  */\n            char zero_times_ok = 0, many_times_ok = 0;\n\n            /* If there is a sequence of repetition chars, collapse it\n               down to just one (the right one).  We can't combine\n               interval operators with these because of, e.g., `a{2}*',\n               which should only match an even number of `a's.  */\n\n            for (;;)\n              {\n                zero_times_ok |= c != '+';\n                many_times_ok |= c != '?';\n\n                if (p == pend)\n                  break;\n\n                PATFETCH (c);\n\n                if (c == '*'\n                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))\n                  ;\n\n                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\\\')\n                  {\n                    if (p == pend) return REG_EESCAPE;\n\n                    PATFETCH (c1);\n                    if (!(c1 == '+' || c1 == '?'))\n                      {\n                        PATUNFETCH;\n                        PATUNFETCH;\n                        break;\n                      }\n\n                    c = c1;\n                  }\n                else\n                  {\n                    PATUNFETCH;\n                    break;\n                  }\n\n                /* If we get here, we found another repeat character.  */\n               }\n\n            /* Star, etc. applied to an empty pattern is equivalent\n               to an empty pattern.  */\n            if (!last_expression)\n              break;\n\n\t    /* Now we know whether or not zero matches is allowed\n\t     * and also whether or not two or more matches is allowed.\n\t     */\n\n\t    {\n\t      struct rexp_node * inner_exp = *last_expression;\n\t      int need_sync = 0;\n\t      if (many_times_ok\n\t\t  && has_non_idempotent_epsilon_path (&rxb->rx,\n\t\t\t\t\t\t      inner_exp, params))\n\t\t{\n\t\t  struct rexp_node * pusher\n\t\t    = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t   (rx_side_effect)re_se_pushpos);\n\t\t  struct rexp_node * checker\n\t\t    = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t   (rx_side_effect)re_se_chkpos);\n\t\t  struct rexp_node * pushback\n\t\t    = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t   (rx_side_effect)re_se_pushback);\n\t\t  rx_Bitset cs = rx_cset (&rxb->rx);\n\t\t  struct rexp_node * lit_t = rx_mk_r_cset (&rxb->rx, cs);\n\t\t  struct rexp_node * fake_state\n\t\t    = rx_mk_r_concat (&rxb->rx, pushback, lit_t);\n\t\t  struct rexp_node * phase2\n\t\t    = rx_mk_r_concat (&rxb->rx, checker, fake_state);\n\t\t  struct rexp_node * popper\n\t\t    = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t   (rx_side_effect)re_se_poppos);\n\t\t  struct rexp_node * star\n\t\t    = rx_mk_r_2phase_star (&rxb->rx, inner_exp, phase2);\n\t\t  struct rexp_node * a\n\t\t    = rx_mk_r_concat (&rxb->rx, pusher, star);\n\t\t  struct rexp_node * whole_thing\n\t\t    = rx_mk_r_concat (&rxb->rx, a, popper);\n\t\t  if (!(pusher && star && pushback && lit_t && fake_state\n\t\t\t&& lit_t && phase2 && checker && popper\n\t\t\t&& a && whole_thing))\n\t\t    return REG_ESPACE;\n\t\t  RX_bitset_enjoin (cs, 't');\n\t\t  *last_expression = whole_thing;\n\t\t}\n\t      else\n\t\t{\n\t\t  struct rexp_node * star =\n\t\t    (many_times_ok ? rx_mk_r_star : rx_mk_r_opt)\n\t\t      (&rxb->rx, *last_expression);\n\t\t  if (!star)\n\t\t    return REG_ESPACE;\n\t\t  *last_expression = star;\n\t\t  need_sync = has_any_se (&rxb->rx, *last_expression);\n\t\t}\n\t      if (!zero_times_ok)\n\t\t{\n\t\t  struct rexp_node * concat\n\t\t    = rx_mk_r_concat (&rxb->rx, inner_exp,\n\t\t\t\t      rx_copy_rexp (&rxb->rx,\n\t\t\t\t\t\t    *last_expression));\n\t\t  if (!concat)\n\t\t    return REG_ESPACE;\n\t\t  *last_expression = concat;\n\t\t}\n\t      if (need_sync)\n\t\t{\n\t\t  int sync_se = paramc;\n\t\t  params = (params\n\t\t\t    ? ((struct re_se_params *)\n\t\t\t       realloc (params,\n\t\t\t\t\tsizeof (*params) * (1 + paramc)))\n\t\t\t    : ((struct re_se_params *)\n\t\t\t       malloc (sizeof (*params))));\n\t\t  if (!params)\n\t\t    return REG_ESPACE;\n\t\t  ++paramc;\n\t\t  params [sync_se].se = re_se_tv;\n\t\t  side = (rx_side_effect)sync_se;\n\t\t  goto add_side_effect;\n\t\t}\n\t    }\n\t    /* The old regex.c used to optimize `.*\\n'.  \n\t     * Maybe rx should too?\n\t     */\n\t  }\n\t  break;\n\n\n\tcase '.':\n\t  {\n\t    rx_Bitset cs = rx_cset (&rxb->rx);\n\t    struct rexp_node * n = rx_mk_r_cset (&rxb->rx, cs);\n\t    if (!(cs && n))\n\t      return REG_ESPACE;\n\t    rx_bitset_universe (rxb->rx.local_cset_size, cs);\n\t    if (!(rxb->syntax & RE_DOT_NEWLINE))\n\t      RX_bitset_remove (cs, '\\n');\n\t    if (!(rxb->syntax & RE_DOT_NOT_NULL))\n\t      RX_bitset_remove (cs, 0);\n\n\t    append = n;\n\t    goto append_node;\n\t    break;\n\t  }\n\n\n        case '[':\n\t  if (p == pend) return REG_EBRACK;\n          {\n            boolean had_char_class = false;\n\t    rx_Bitset cs = rx_cset (&rxb->rx);\n\t    struct rexp_node * node = rx_mk_r_cset (&rxb->rx, cs);\n\t    int is_inverted = *p == '^';\n\t    \n\t    if (!(node && cs))\n\t      return REG_ESPACE;\n\t    \n\t    /* This branch of the switch is normally exited with\n\t     *`goto append_node'\n\t     */\n\t    append = node;\n\t    \n            if (is_inverted)\n\t      p++;\n\t    \n            /* Remember the first position in the bracket expression.  */\n            p1 = p;\n\t    \n            /* Read in characters and ranges, setting map bits.  */\n            for (;;)\n              {\n                if (p == pend) return REG_EBRACK;\n\t\t\n                PATFETCH (c);\n\t\t\n                /* \\ might escape characters inside [...] and [^...].  */\n                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\\\')\n                  {\n                    if (p == pend) return REG_EESCAPE;\n\t\t    \n                    PATFETCH (c1);\n\t\t    {\n\t\t      rx_Bitset it = inverse_translation (rxb, \n\t\t\t\t\t\t\t  validate_inv_tr,\n\t\t\t\t\t\t\t  inverse_translate,\n\t\t\t\t\t\t\t  translate,\n\t\t\t\t\t\t\t  c1);\n\t\t      rx_bitset_union (rxb->rx.local_cset_size, cs, it);\n\t\t    }\n                    continue;\n                  }\n\t\t\n                /* Could be the end of the bracket expression.  If it's\n                   not (i.e., when the bracket expression is `[]' so\n                   far), the ']' character bit gets set way below.  */\n                if (c == ']' && p != p1 + 1)\n                  goto finalize_class_and_append;\n\t\t\n                /* Look ahead to see if it's a range when the last thing\n                   was a character class.  */\n                if (had_char_class && c == '-' && *p != ']')\n                  return REG_ERANGE;\n\t\t\n                /* Look ahead to see if it's a range when the last thing\n                   was a character: if this is a hyphen not at the\n                   beginning or the end of a list, then it's the range\n                   operator.  */\n                if (c == '-' \n                    && !(p - 2 >= pattern && p[-2] == '[') \n                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')\n                    && *p != ']')\n                  {\n                    reg_errcode_t ret\n                      = compile_range (rxb, cs, &p, pend, translate, syntax,\n\t\t\t\t       inverse_translate, validate_inv_tr);\n                    if (ret != REG_NOERROR) return ret;\n                  }\n\t\t\n                else if (p[0] == '-' && p[1] != ']')\n                  { /* This handles ranges made up of characters only.  */\n                    reg_errcode_t ret;\n\t\t    \n\t\t    /* Move past the `-'.  */\n                    PATFETCH (c1);\n                    \n                    ret = compile_range (rxb, cs, &p, pend, translate, syntax,\n\t\t\t\t\t inverse_translate, validate_inv_tr);\n                    if (ret != REG_NOERROR) return ret;\n                  }\n\t\t\n                /* See if we're at the beginning of a possible character\n                   class.  */\n\t\t\n\t\telse if ((syntax & RE_CHAR_CLASSES)\n\t\t\t && (c == '[') && (*p == ':'))\n                  {\n                    char str[CHAR_CLASS_MAX_LENGTH + 1];\n\t\t    \n                    PATFETCH (c);\n                    c1 = 0;\n\t\t    \n                    /* If pattern is `[[:'.  */\n                    if (p == pend) return REG_EBRACK;\n\t\t    \n                    for (;;)\n                      {\n                        PATFETCH (c);\n                        if (c == ':' || c == ']' || p == pend\n                            || c1 == CHAR_CLASS_MAX_LENGTH)\n\t\t\t  break;\n                        str[c1++] = c;\n                      }\n                    str[c1] = '\\0';\n\t\t    \n                    /* If isn't a word bracketed by `[:' and:`]':\n                       undo the ending character, the letters, and leave \n                       the leading `:' and `[' (but set bits for them).  */\n                    if (c == ':' && *p == ']')\n                      {\n                        int ch;\n                        boolean is_alnum = !strcmp (str, \"alnum\");\n                        boolean is_alpha = !strcmp (str, \"alpha\");\n                        boolean is_blank = !strcmp (str, \"blank\");\n                        boolean is_cntrl = !strcmp (str, \"cntrl\");\n                        boolean is_digit = !strcmp (str, \"digit\");\n                        boolean is_graph = !strcmp (str, \"graph\");\n                        boolean is_lower = !strcmp (str, \"lower\");\n                        boolean is_print = !strcmp (str, \"print\");\n                        boolean is_punct = !strcmp (str, \"punct\");\n                        boolean is_space = !strcmp (str, \"space\");\n                        boolean is_upper = !strcmp (str, \"upper\");\n                        boolean is_xdigit = !strcmp (str, \"xdigit\");\n                        \n                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;\n\t\t\t\n                        /* Throw away the ] at the end of the character\n                           class.  */\n                        PATFETCH (c);\t\t\t\t\t\n\t\t\t\n                        if (p == pend) return REG_EBRACK;\n\t\t\t\n                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)\n                          {\n                            if (   (is_alnum  && isalnum (ch))\n                                || (is_alpha  && isalpha (ch))\n                                || (is_blank  && isblank (ch))\n                                || (is_cntrl  && iscntrl (ch))\n                                || (is_digit  && isdigit (ch))\n                                || (is_graph  && isgraph (ch))\n                                || (is_lower  && islower (ch))\n                                || (is_print  && isprint (ch))\n                                || (is_punct  && ispunct (ch))\n                                || (is_space  && isspace (ch))\n                                || (is_upper  && isupper (ch))\n                                || (is_xdigit && isxdigit (ch)))\n\t\t\t      {\n\t\t\t\trx_Bitset it =\n\t\t\t\t  inverse_translation (rxb, \n\t\t\t\t\t\t       validate_inv_tr,\n\t\t\t\t\t\t       inverse_translate,\n\t\t\t\t\t\t       translate,\n\t\t\t\t\t\t       ch);\n\t\t\t\trx_bitset_union (rxb->rx.local_cset_size,\n\t\t\t\t\t\t cs, it);\n\t\t\t      }\n                          }\n                        had_char_class = true;\n                      }\n                    else\n                      {\n                        c1++;\n                        while (c1--)    \n                          PATUNFETCH;\n\t\t\t{\n\t\t\t  rx_Bitset it =\n\t\t\t    inverse_translation (rxb, \n\t\t\t\t\t\t validate_inv_tr,\n\t\t\t\t\t\t inverse_translate,\n\t\t\t\t\t\t translate,\n\t\t\t\t\t\t '[');\n\t\t\t  rx_bitset_union (rxb->rx.local_cset_size,\n\t\t\t\t\t   cs, it);\n\t\t\t}\n\t\t\t{\n\t\t\t  rx_Bitset it =\n\t\t\t    inverse_translation (rxb, \n\t\t\t\t\t\t validate_inv_tr,\n\t\t\t\t\t\t inverse_translate,\n\t\t\t\t\t\t translate,\n\t\t\t\t\t\t ':');\n\t\t\t  rx_bitset_union (rxb->rx.local_cset_size,\n\t\t\t\t\t   cs, it);\n\t\t\t}\n                        had_char_class = false;\n                      }\n                  }\n                else\n                  {\n                    had_char_class = false;\n\t\t    {\n\t\t      rx_Bitset it = inverse_translation (rxb, \n\t\t\t\t\t\t\t  validate_inv_tr,\n\t\t\t\t\t\t\t  inverse_translate,\n\t\t\t\t\t\t\t  translate,\n\t\t\t\t\t\t\t  c);\n\t\t      rx_bitset_union (rxb->rx.local_cset_size, cs, it);\n\t\t    }\n                  }\n              }\n\n\t  finalize_class_and_append:\n\t    if (is_inverted)\n\t      {\n\t\trx_bitset_complement (rxb->rx.local_cset_size, cs);\n\t\tif (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\t\t  RX_bitset_remove (cs, '\\n');\n\t      }\n\t    goto append_node;\n          }\n          break;\n\n\n\tcase '(':\n          if (syntax & RE_NO_BK_PARENS)\n            goto handle_open;\n          else\n            goto normal_char;\n\n\n        case ')':\n          if (syntax & RE_NO_BK_PARENS)\n            goto handle_close;\n          else\n            goto normal_char;\n\n\n        case '\\n':\n          if (syntax & RE_NEWLINE_ALT)\n            goto handle_alt;\n          else\n            goto normal_char;\n\n\n\tcase '|':\n          if (syntax & RE_NO_BK_VBAR)\n            goto handle_alt;\n          else\n            goto normal_char;\n\n\n        case '{':\n\t  if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\t    goto handle_interval;\n\t  else\n\t    goto normal_char;\n\n\n        case '\\\\':\n          if (p == pend) return REG_EESCAPE;\n\n          /* Do not translate the character after the \\, so that we can\n             distinguish, e.g., \\B from \\b, even if we normally would\n             translate, e.g., B to b.  */\n          PATFETCH_RAW (c);\n\n          switch (c)\n            {\n            case '(':\n              if (syntax & RE_NO_BK_PARENS)\n                goto normal_backslash;\n\n            handle_open:\n              rxb->re_nsub++;\n              regnum++;\n              if (COMPILE_STACK_FULL)\n                { \n                  RETALLOC (compile_stack.stack, compile_stack.size << 1,\n                            compile_stack_elt_t);\n                  if (compile_stack.stack == 0) return REG_ESPACE;\n\n                  compile_stack.size <<= 1;\n                }\n\n\t      if (*last_expression)\n\t\t{\n\t\t  struct rexp_node * concat\n\t\t    = rx_mk_r_concat (&rxb->rx, *last_expression, 0);\n\t\t  if (!concat)\n\t\t    return REG_ESPACE;\n\t\t  *last_expression = concat;\n\t\t  last_expression = &concat->params.pair.right;\n\t\t}\n\n              /*\n\t       * These are the values to restore when we hit end of this\n               * group.  \n\t       */\n\t      COMPILE_STACK_TOP.top_expression = top_expression;\n\t      COMPILE_STACK_TOP.last_expression = last_expression;\n              COMPILE_STACK_TOP.regnum = regnum;\n\t      \n              compile_stack.avail++;\n\t      \n\t      top_expression = last_expression;\n\t      break;\n\n\n            case ')':\n              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;\n\n            handle_close:\n              /* See similar code for backslashed left paren above.  */\n              if (COMPILE_STACK_EMPTY)\n                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)\n                  goto normal_char;\n                else\n                  return REG_ERPAREN;\n\n              /* Since we just checked for an empty stack above, this\n                 ``can't happen''.  */\n\n              {\n                /* We don't just want to restore into `regnum', because\n                   later groups should continue to be numbered higher,\n                   as in `(ab)c(de)' -- the second group is #2.  */\n                regnum_t this_group_regnum;\n\t\tstruct rexp_node ** inner = top_expression;\n\n                compile_stack.avail--;\n\t\ttop_expression = COMPILE_STACK_TOP.top_expression;\n\t\tlast_expression = COMPILE_STACK_TOP.last_expression;\n                this_group_regnum = COMPILE_STACK_TOP.regnum;\n\t\t{\n\t\t  int left_se = paramc;\n\t\t  int right_se = paramc + 1;\n\n\t\t  params = (params\n\t\t\t    ? ((struct re_se_params *)\n\t\t\t       realloc (params,\n\t\t\t\t\t(paramc + 2) * sizeof (params[0])))\n\t\t\t    : ((struct re_se_params *)\n\t\t\t       malloc (2 * sizeof (params[0]))));\n\t\t  if (!params)\n\t\t    return REG_ESPACE;\n\t\t  paramc += 2;\n\n\t\t  params[left_se].se = re_se_lparen;\n\t\t  params[left_se].op1 = this_group_regnum;\n\t\t  params[right_se].se = re_se_rparen;\n\t\t  params[right_se].op1 = this_group_regnum;\n\t\t  {\n\t\t    struct rexp_node * left\n\t\t      = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t     (rx_side_effect)left_se);\n\t\t    struct rexp_node * right\n\t\t      = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t     (rx_side_effect)right_se);\n\t\t    struct rexp_node * c1\n\t\t      = (*inner\n\t\t\t ? rx_mk_r_concat (&rxb->rx, left, *inner) : left);\n\t\t    struct rexp_node * c2\n\t\t      = rx_mk_r_concat (&rxb->rx, c1, right);\n\t\t    if (!(left && right && c1 && c2))\n\t\t      return REG_ESPACE;\n\t\t    *inner = c2;\n\t\t  }\n\t\t}\n\t\tbreak;\n\t      }\n\n            case '|':\t\t\t\t\t/* `\\|'.  */\n              if ((syntax & RE_LIMITED_OPS) || (syntax & RE_NO_BK_VBAR))\n                goto normal_backslash;\n            handle_alt:\n              if (syntax & RE_LIMITED_OPS)\n                goto normal_char;\n\n\t      {\n\t\tstruct rexp_node * alt\n\t\t  = rx_mk_r_alternate (&rxb->rx, *top_expression, 0);\n\t\tif (!alt)\n\t\t  return REG_ESPACE;\n\t\t*top_expression = alt;\n\t\tlast_expression = &alt->params.pair.right;\n\t\t{\n\t\t  int sync_se = paramc;\n\n\t\t  params = (params\n\t\t\t    ? ((struct re_se_params *)\n\t\t\t       realloc (params,\n\t\t\t\t\t(paramc + 1) * sizeof (params[0])))\n\t\t\t    : ((struct re_se_params *)\n\t\t\t       malloc (sizeof (params[0]))));\n\t\t  if (!params)\n\t\t    return REG_ESPACE;\n\t\t  ++paramc;\n\n\t\t  params[sync_se].se = re_se_tv;\n\t\t  {\n\t\t    struct rexp_node * sync\n\t\t      = rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t     (rx_side_effect)sync_se);\n\t\t    struct rexp_node * conc\n\t\t      = rx_mk_r_concat (&rxb->rx, sync, 0);\n\n\t\t    if (!sync || !conc)\n\t\t      return REG_ESPACE;\n\n\t\t    *last_expression = conc;\n\t\t    last_expression = &conc->params.pair.right;\n\t\t  }\n\t\t}\n\t      }\n              break;\n\n\n            case '{': \n              /* If \\{ is a literal.  */\n              if (!(syntax & RE_INTERVALS)\n                     /* If we're at `\\{' and it's not the open-interval \n                        operator.  */\n                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n                  || (p - 2 == pattern  &&  p == pend))\n                goto normal_backslash;\n\n            handle_interval:\n              {\n                /* If got here, then the syntax allows intervals.  */\n\n                /* At least (most) this many matches must be made.  */\n                int lower_bound = -1, upper_bound = -1;\n\n                beg_interval = p - 1;\n\n                if (p == pend)\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else\n                      return REG_EBRACE;\n                  }\n\n                GET_UNSIGNED_NUMBER (lower_bound);\n\n                if (c == ',')\n                  {\n                    GET_UNSIGNED_NUMBER (upper_bound);\n                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;\n                  }\n                else\n                  /* Interval such as `{1}' => match exactly once. */\n                  upper_bound = lower_bound;\n\n                if (lower_bound < 0 || upper_bound > RE_DUP_MAX\n                    || lower_bound > upper_bound)\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else \n                      return REG_BADBR;\n                  }\n\n                if (!(syntax & RE_NO_BK_BRACES)) \n                  {\n                    if (c != '\\\\') return REG_EBRACE;\n                    PATFETCH (c);\n                  }\n\n                if (c != '}')\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else \n                      return REG_BADBR;\n                  }\n\n                /* We just parsed a valid interval.  */\n\n                /* If it's invalid to have no preceding re.  */\n                if (pointless_if_repeated (*last_expression, params))\n                  {\n                    if (syntax & RE_CONTEXT_INVALID_OPS)\n                      return REG_BADRPT;\n                    else if (!(syntax & RE_CONTEXT_INDEP_OPS))\n                      goto unfetch_interval;\n\t\t    /* was: else laststart = b; */\n                  }\n\n                /* If the upper bound is zero, don't want to iterate\n                 * at all.\n\t\t */\n                 if (upper_bound == 0)\n\t\t   {\n\t\t     if (*last_expression)\n\t\t       {\n\t\t\t rx_free_rexp (&rxb->rx, *last_expression);\n\t\t\t *last_expression = 0;\n\t\t       }\n\t\t   }\n\t\telse\n\t\t  /* Otherwise, we have a nontrivial interval. */\n\t\t  {\n\t\t    int iter_se = paramc;\n\t\t    int end_se = paramc + 1;\n\t\t    params = (params\n\t\t\t      ? ((struct re_se_params *)\n\t\t\t\t realloc (params,\n\t\t\t\t\t  sizeof (*params) * (2 + paramc)))\n\t\t\t      : ((struct re_se_params *)\n\t\t\t\t malloc (2 * sizeof (*params))));\n\t\t    if (!params)\n\t\t      return REG_ESPACE;\n\t\t    paramc += 2;\n\t\t    params [iter_se].se = re_se_iter;\n\t\t    params [iter_se].op1 = lower_bound;\n\t\t    params[iter_se].op2 = upper_bound;\n\n\t\t    params[end_se].se = re_se_end_iter;\n\t\t    params[end_se].op1 = lower_bound;\n\t\t    params[end_se].op2 = upper_bound;\n\t\t    {\n\t\t      struct rexp_node * push0\n\t\t\t= rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t       (rx_side_effect)re_se_push0);\n\t\t      struct rexp_node * start_one_iter\n\t\t\t= rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t       (rx_side_effect)iter_se);\n\t\t      struct rexp_node * phase1\n\t\t\t= rx_mk_r_concat (&rxb->rx, start_one_iter,\n\t\t\t\t\t  *last_expression);\n\t\t      struct rexp_node * pushback\n\t\t\t= rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t       (rx_side_effect)re_se_pushback);\n\t\t      rx_Bitset cs = rx_cset (&rxb->rx);\n\t\t      struct rexp_node * lit_t\n\t\t\t= rx_mk_r_cset (&rxb->rx, cs);\n\t\t      struct rexp_node * phase2\n\t\t\t= rx_mk_r_concat (&rxb->rx, pushback, lit_t);\n\t\t      struct rexp_node * loop\n\t\t\t= rx_mk_r_2phase_star (&rxb->rx, phase1, phase2);\n\t\t      struct rexp_node * push_n_loop\n\t\t\t= rx_mk_r_concat (&rxb->rx, push0, loop);\n\t\t      struct rexp_node * final_test\n\t\t\t= rx_mk_r_side_effect (&rxb->rx,\n\t\t\t\t\t       (rx_side_effect)end_se);\n\t\t      struct rexp_node * full_exp\n\t\t\t= rx_mk_r_concat (&rxb->rx, push_n_loop, final_test);\n\n\t\t      if (!(push0 && start_one_iter && phase1\n\t\t\t    && pushback && lit_t && phase2\n\t\t\t    && loop && push_n_loop && final_test && full_exp))\n\t\t\treturn REG_ESPACE;\n\n\t\t      RX_bitset_enjoin(cs, 't');\n\n\t\t      *last_expression = full_exp;\n\t\t    }\n\t\t  }\n                beg_interval = 0;\n              }\n              break;\n\n            unfetch_interval:\n              /* If an invalid interval, match the characters as literals.  */\n               p = beg_interval;\n               beg_interval = NULL;\n\n               /* normal_char and normal_backslash need `c'.  */\n               PATFETCH (c);\t\n\n               if (!(syntax & RE_NO_BK_BRACES))\n                 {\n                   if (p > pattern  &&  p[-1] == '\\\\')\n                     goto normal_backslash;\n                 }\n               goto normal_char;\n\n#ifdef emacs\n            /* There is no way to specify the before_dot and after_dot\n               operators.  rms says this is ok.  --karl  */\n            case '=':\n\t      side = at_dot;\n\t      goto add_side_effect;\n              break;\n\n            case 's':\n\t    case 'S':\n\t      {\n\t\trx_Bitset cs = cset (&rxb->rx);\n\t\tstruct rexp_node * set = rx_mk_r_cset (&rxb->rx, cs);\n\t\tif (!(cs && set))\n\t\t  return REG_ESPACE;\n\t\tif (c == 'S')\n\t\t  rx_bitset_universe (rxb->rx.local_cset_size, cs);\n\n\t\tPATFETCH (c);\n\t\t{\n\t\t  int x;\n\t\t  char code = syntax_spec_code (c);\n\t\t  for (x = 0; x < 256; ++x)\n\t\t  \n\t\t    {\n\t\t      \n\t\t      if (SYNTAX (x) & code)\n\t\t\t{\n\t\t\t  rx_Bitset it =\n\t\t\t    inverse_translation (rxb, validate_inv_tr,\n\t\t\t\t\t\t inverse_translate,\n\t\t\t\t\t\t translate, x);\n\t\t\t  rx_bitset_xor (rxb->rx.local_cset_size, cs, it);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto append_node;\n\t      }\n              break;\n#endif /* emacs */\n\n\n            case 'w':\n            case 'W':\n\t      {\n\t\trx_Bitset cs = rx_cset (&rxb->rx);\n\t\tstruct rexp_node * n = (cs ? rx_mk_r_cset (&rxb->rx, cs) : 0);\n\t\tif (!(cs && n))\n\t\t  return REG_ESPACE;\n\t\tif (c == 'W')\n\t\t  rx_bitset_universe (rxb->rx.local_cset_size ,cs);\n\t\t{\n\t\t  int x;\n\t\t  for (x = rxb->rx.local_cset_size - 1; x > 0; --x)\n\t\t    if (re_syntax_table[x] & Sword)\n\t\t      RX_bitset_toggle (cs, x);\n\t\t}\n\t\tappend = n;\n\t\tgoto append_node;\n\t      }\n              break;\n\n/* With a little extra work, some of these side effects could be optimized\n * away (basicly by looking at what we already know about the surrounding\n * chars).  \n */\n            case '<':\n\t      side = (rx_side_effect)re_se_wordbeg;\n\t      goto add_side_effect;\n              break;\n\n            case '>':\n              side = (rx_side_effect)re_se_wordend;\n\t      goto add_side_effect;\n              break;\n\n            case 'b':\n              side = (rx_side_effect)re_se_wordbound;\n\t      goto add_side_effect;\n              break;\n\n            case 'B':\n              side = (rx_side_effect)re_se_notwordbound;\n\t      goto add_side_effect;\n              break;\n\n            case '`':\n\t      side = (rx_side_effect)re_se_begbuf;\n\t      goto add_side_effect;\n\t      break;\n\t      \n            case '\\'':\n\t      side = (rx_side_effect)re_se_endbuf;\n\t      goto add_side_effect;\n              break;\n\n\t    add_side_effect:\n\t      {\n\t\tstruct rexp_node * se\n\t\t  = rx_mk_r_side_effect (&rxb->rx, side);\n\t\tif (!se)\n\t\t  return REG_ESPACE;\n\t\tappend = se;\n\t\tgoto append_node;\n\t      }\n\t      break;\n\n            case '1': case '2': case '3': case '4': case '5':\n            case '6': case '7': case '8': case '9':\n              if (syntax & RE_NO_BK_REFS)\n                goto normal_char;\n\n              c1 = c - '0';\n\n              if (c1 > regnum)\n                return REG_ESUBREG;\n\n              /* Can't back reference to a subexpression if inside of it.  */\n              if (group_in_compile_stack (compile_stack, c1))\n\t\treturn REG_ESUBREG;\n\n\t      {\n\t\tint backref_se = paramc;\n\t\tparams = (params\n\t\t\t  ? ((struct re_se_params *)\n\t\t\t     realloc (params,\n\t\t\t\t      sizeof (*params) * (1 + paramc)))\n\t\t\t  : ((struct re_se_params *)\n\t\t\t     malloc (sizeof (*params))));\n\t\tif (!params)\n\t\t  return REG_ESPACE;\n\t\t++paramc;\n\t\tparams[backref_se].se = re_se_backref;\n\t\tparams[backref_se].op1 = c1;\n\t\tside = (rx_side_effect)backref_se;\n\t\tgoto add_side_effect;\n\t      }\n              break;\n\n            case '+':\n            case '?':\n              if (syntax & RE_BK_PLUS_QM)\n                goto handle_plus;\n              else\n                goto normal_backslash;\n\n            default:\n            normal_backslash:\n              /* You might think it would be useful for \\ to mean\n                 not to translate; but if we don't translate it\n                 it will never match anything.  */\n              c = TRANSLATE (c);\n              goto normal_char;\n            }\n          break;\n\n\n\tdefault:\n        /* Expects the character in `c'.  */\n\tnormal_char:\n\t    {\n\t      rx_Bitset cs = rx_cset(&rxb->rx);\n\t      struct rexp_node * match = rx_mk_r_cset (&rxb->rx, cs);\n\t      rx_Bitset it;\n\t      if (!(cs && match))\n\t\treturn REG_ESPACE;\n\t      it = inverse_translation (rxb, validate_inv_tr,\n\t\t\t\t\tinverse_translate, translate, c);\n\t      rx_bitset_union (CHAR_SET_SIZE, cs, it);\n\t      append = match;\n\n\t    append_node:\n\t      /* This genericly appends the rexp APPEND to *LAST_EXPRESSION\n\t       * and then parses the next character normally.\n\t       */\n\t      if (*last_expression)\n\t\t{\n\t\t  struct rexp_node * concat\n\t\t    = rx_mk_r_concat (&rxb->rx, *last_expression, append);\n\t\t  if (!concat)\n\t\t    return REG_ESPACE;\n\t\t  *last_expression = concat;\n\t\t  last_expression = &concat->params.pair.right;\n\t\t}\n\t      else\n\t\t*last_expression = append;\n\t    }\n\t} /* switch (c) */\n    } /* while p != pend */\n\n  \n  {\n    int win_se = paramc;\n    params = (params\n\t      ? ((struct re_se_params *)\n\t\t realloc (params,\n\t\t\t  sizeof (*params) * (1 + paramc)))\n\t      : ((struct re_se_params *)\n\t\t malloc (sizeof (*params))));\n    if (!params)\n      return REG_ESPACE;\n    ++paramc;\n    params[win_se].se = re_se_win;\n    {\n      struct rexp_node * se\n\t= rx_mk_r_side_effect (&rxb->rx, (rx_side_effect)win_se);\n      struct rexp_node * concat\n\t= rx_mk_r_concat (&rxb->rx, rexp, se);\n      if (!(se && concat))\n\treturn REG_ESPACE;\n      rexp = concat;\n    }\n  }\n\n\n  /* Through the pattern now.  */\n\n  if (!COMPILE_STACK_EMPTY) \n    return REG_EPAREN;\n\n      free (compile_stack.stack);\n\n  orig_rexp = rexp;\n#ifdef RX_DEBUG\n  if (rx_debug_compile)\n    {\n      dbug_rxb = rxb;\n      fputs (\"\\n\\nCompiling \", stdout);\n      fwrite (pattern, 1, size, stdout);\n      fputs (\":\\n\", stdout);\n      rxb->se_params = params;\n      print_rexp (&rxb->rx, orig_rexp, 2, re_seprint, stdout);\n    }\n#endif\n  {\n    rx_Bitset cs = rx_cset(&rxb->rx);\n    rx_Bitset cs2 = rx_cset(&rxb->rx);\n    char * se_map = (char *) alloca (paramc);\n    struct rexp_node * new_rexp = 0;\n\n\n    bzero (se_map, paramc);\n    find_backrefs (se_map, rexp, params);\n    fewer_side_effects =\n      remove_unecessary_side_effects (&rxb->rx, se_map,\n\t\t\t\t      rx_copy_rexp (&rxb->rx, rexp), params);\n\n    speed_up_alt (&rxb->rx, rexp, 0);\n    speed_up_alt (&rxb->rx, fewer_side_effects, 1);\n\n    {\n      char * syntax_parens = rxb->syntax_parens;\n      if (syntax_parens == (char *)0x1)\n\trexp = remove_unecessary_side_effects\n\t  (&rxb->rx, se_map, rexp, params);\n      else if (syntax_parens)\n\t{\n\t  int x;\n\t  for (x = 0; x < paramc; ++x)\n\t    if ((   (params[x].se == re_se_lparen)\n\t\t || (params[x].se == re_se_rparen))\n\t\t&& (!syntax_parens [params[x].op1]))\n\t      se_map [x] = 1;\n\t  rexp = remove_unecessary_side_effects\n\t    (&rxb->rx, se_map, rexp, params);\n\t}\n    }\n\n    /* At least one more optimization would be nice to have here but i ran out \n     * of time.  The idea would be to delay side effects.  \n     * For examle, `(abc)' is the same thing as `abc()' except that the\n     * left paren is offset by 3 (which we know at compile time).\n     * (In this comment, write that second pattern `abc(:3:)' \n     * where `(:3:' is a syntactic unit.)\n     *\n     * Trickier:  `(abc|defg)'  is the same as `(abc(:3:|defg(:4:))'\n     * (The paren nesting may be hard to follow -- that's an alternation\n     *\tof `abc(:3:' and `defg(:4:' inside (purely syntactic) parens\n     *  followed by the closing paren from the original expression.)\n     *\n     * Neither the expression tree representation nor the the nfa make\n     * this very easy to write. :(\n     */\n\n  /* What we compile is different than what the parser returns.\n   * Suppose the parser returns expression R.\n   * Let R' be R with unnecessary register assignments removed \n   * (see REMOVE_UNECESSARY_SIDE_EFFECTS, above).\n   *\n   * What we will compile is the expression:\n   *\n   *    m{try}R{win}\\|s{try}R'{win}\n   *\n   * {try} and {win} denote side effect epsilons (see EXPLORE_FUTURE).\n   * \n   * When trying a match, we insert an `m' at the beginning of the \n   * string if the user wants registers to be filled, `s' if not.\n   */\n    new_rexp =\n      rx_mk_r_alternate\n\t(&rxb->rx,\n\t rx_mk_r_concat (&rxb->rx, rx_mk_r_cset (&rxb->rx, cs2), rexp),\n\t rx_mk_r_concat (&rxb->rx,\n\t\t\t rx_mk_r_cset (&rxb->rx, cs), fewer_side_effects));\n\n    if (!(new_rexp && cs && cs2))\n      return REG_ESPACE;\n    RX_bitset_enjoin (cs2, '\\0'); /* prefixed to the rexp used for matching. */\n    RX_bitset_enjoin (cs, '\\1'); /* prefixed to the rexp used for searching. */\n    rexp = new_rexp;\n  }\n\n#ifdef RX_DEBUG\n  if (rx_debug_compile)\n    {\n      fputs (\"\\n...which is compiled as:\\n\", stdout);\n      print_rexp (&rxb->rx, rexp, 2, re_seprint, stdout);\n    }\n#endif\n  {\n    struct rx_nfa_state *start = 0;\n    struct rx_nfa_state *end = 0;\n\n    if (!rx_build_nfa (&rxb->rx, rexp, &start, &end))\n      return REG_ESPACE;\t/*  */\n    else\n      {\n\tvoid * mem = (void *)rxb->buffer;\n\tunsigned long size = rxb->allocated;\n\tint start_id;\n\tchar * perm_mem;\n\tint iterator_size = paramc * sizeof (params[0]);\n\n\tend->is_final = 1;\n\tstart->is_start = 1;\n\trx_name_nfa_states (&rxb->rx);\n\tstart_id = start->id;\n#ifdef RX_DEBUG\n\tif (rx_debug_compile)\n\t  {\n\t    fputs (\"...giving the NFA: \\n\", stdout);\n\t    dbug_rxb = rxb;\n\t    print_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);\n\t  }\n#endif\n\tif (!rx_eclose_nfa (&rxb->rx))\n\t  return REG_ESPACE;\n\telse\n\t  {\n\t    rx_delete_epsilon_transitions (&rxb->rx);\n\t    \n\t    /* For compatability reasons, we need to shove the\n\t     * compiled nfa into one chunk of malloced memory.\n\t     */\n\t    rxb->rx.reserved = (   sizeof (params[0]) * paramc\n\t\t\t\t+  rx_sizeof_bitset (rxb->rx.local_cset_size));\n#ifdef RX_DEBUG\n\t    if (rx_debug_compile)\n\t      {\n\t\tdbug_rxb = rxb;\n\t\tfputs (\"...which cooks down (uncompactified) to: \\n\", stdout);\n\t\tprint_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);\n\t      }\n#endif\n\t    if (!rx_compactify_nfa (&rxb->rx, &mem, &size))\n\t      return REG_ESPACE;\n\t    rxb->buffer = mem;\n\t    rxb->allocated = size;\n\t    rxb->rx.buffer = mem;\n\t    rxb->rx.allocated = size;\n\t    perm_mem = ((char *)rxb->rx.buffer\n\t\t\t+ rxb->rx.allocated - rxb->rx.reserved);\n\t    rxb->se_params = ((struct re_se_params *)perm_mem);\n\t    bcopy (params, rxb->se_params, iterator_size);\n\t    perm_mem += iterator_size;\n\t    rxb->fastset = (rx_Bitset) perm_mem;\n\t    rxb->start = rx_id_to_nfa_state (&rxb->rx, start_id);\n\t  }\n\trx_bitset_null (rxb->rx.local_cset_size, rxb->fastset);\n\trxb->can_match_empty = compute_fastset (rxb, orig_rexp);\n\trxb->match_regs_on_stack =\n\t  registers_on_stack (rxb, orig_rexp, 0, params); \n\trxb->search_regs_on_stack =\n\t  registers_on_stack (rxb, fewer_side_effects, 0, params);\n\tif (rxb->can_match_empty)\n\t  rx_bitset_universe (rxb->rx.local_cset_size, rxb->fastset);\n\trxb->is_anchored = is_anchored (orig_rexp, (rx_side_effect) re_se_hat);\n\trxb->begbuf_only = is_anchored (orig_rexp,\n\t\t\t\t\t(rx_side_effect) re_se_begbuf);\n      }\n    rx_free_rexp (&rxb->rx, rexp);\n    if (params)\n      free (params);\n#ifdef RX_DEBUG\n    if (rx_debug_compile)\n      {\n\tdbug_rxb = rxb;\n\tfputs (\"...which cooks down to: \\n\", stdout);\n\tprint_nfa (&rxb->rx, rxb->rx.nfa_states, re_seprint, stdout);\n      }\n#endif\n  }\n  return REG_NOERROR;\n}\n\n\f\n\n/* This table gives an error message for each of the error codes listed\n   in regex.h.  Obviously the order here has to be same as there.  */\n\nconst char * rx_error_msg[] =\n{ 0,\t\t\t\t\t\t/* REG_NOERROR */\n    \"No match\",\t\t\t\t\t/* REG_NOMATCH */\n    \"Invalid regular expression\",\t\t/* REG_BADPAT */\n    \"Invalid collation character\",\t\t/* REG_ECOLLATE */\n    \"Invalid character class name\",\t\t/* REG_ECTYPE */\n    \"Trailing backslash\",\t\t\t/* REG_EESCAPE */\n    \"Invalid back reference\",\t\t\t/* REG_ESUBREG */\n    \"Unmatched [ or [^\",\t\t\t/* REG_EBRACK */\n    \"Unmatched ( or \\\\(\",\t\t\t/* REG_EPAREN */\n    \"Unmatched \\\\{\",\t\t\t\t/* REG_EBRACE */\n    \"Invalid content of \\\\{\\\\}\",\t\t/* REG_BADBR */\n    \"Invalid range end\",\t\t\t/* REG_ERANGE */\n    \"Memory exhausted\",\t\t\t\t/* REG_ESPACE */\n    \"Invalid preceding regular expression\",\t/* REG_BADRPT */\n    \"Premature end of regular expression\",\t/* REG_EEND */\n    \"Regular expression too big\",\t\t/* REG_ESIZE */\n    \"Unmatched ) or \\\\)\",\t\t\t/* REG_ERPAREN */\n};\n\n\f\n\n/* Test if at very beginning or at very end of the virtual concatenation\n *  of `string1' and `string2'.  If only one string, it's `string2'.  \n */\n\n#define AT_STRINGS_BEG() \\\n  (string1 \\\n   ? ((tst_half == 0) \\\n      && ((unsigned char *)tst_pos == (unsigned char *)string1 - 1)) \\\n   : ((unsigned char *)tst_pos == (unsigned char *)string2 - 1))\n\n#define AT_STRINGS_END() \\\n  (string2 \\\n   ? ((tst_half == 1) \\\n      && ((unsigned char *)tst_pos \\\n\t  == ((unsigned char *)string2 + size2 - 1))) \\\n   : ((unsigned char *)tst_pos == ((unsigned char *)string1 + size1 - 1)))\n\n/* Test if D points to a character which is word-constituent.  We have\n * two special cases to check for: if past the end of string1, look at\n * the first character in string2; and if before the beginning of\n * string2, look at the last character in string1.\n *\n * Assumes `string1' exists, so use in conjunction with AT_STRINGS_BEG ().  \n */\n#define LETTER_P(d)\t\t\t\t\t\t\t\\\n  (SYNTAX ((string2 && (tst_half == 0)\t\t\t\t\t\\\n\t    && ((d) == ((unsigned char *)string1 + size1)))\t\t\\\n\t   ? *(unsigned char *)string2\t\t\t\t\t\\\n\t   : ((string1 && (tst_half == 1)\t\t\t\t\\\n\t       && ((d) == (unsigned char *)string2 - 1))\t\t\\\n\t      ? *((unsigned char *)string1 + size1 - 1)\t\t\t\\\n\t      : *(d))) == Sword)\n\n/* Test if the character at D and the one after D differ with respect\n * to being word-constituent.  \n */\n#define AT_WORD_BOUNDARY(d)\t\t\t\t\t\t\\\n  (AT_STRINGS_BEG () || AT_STRINGS_END () || LETTER_P (d) != LETTER_P (d + 1))\n\n\nstatic char slowmap [256] =\n{\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n};\n\n#ifdef __STDC__\nstatic void\nrx_blow_up_fastmap (struct re_pattern_buffer * rxb)\n#else\nstatic void\nrx_blow_up_fastmap (rxb)\n     struct re_pattern_buffer * rxb;\n#endif\n{\n  int x;\n  for (x = 0; x < 256; ++x)\t/* &&&& 3.6 % */\n    rxb->fastmap [x] = !!RX_bitset_member (rxb->fastset, x);\n  rxb->fastmap_accurate = 1;\n}\n\n\n\f\n\nstruct stack_chunk\n{\n  struct stack_chunk * next_chunk;\n  int bytes_left;\n  char * sp;\n};\n\n#define PUSH(CHUNK_VAR,BYTES)   \\\n  if (!CHUNK_VAR || (CHUNK_VAR->bytes_left < (BYTES)))  \\\n    {\t\t\t\t\t\\\n      struct stack_chunk * new_chunk;\t\\\n      if (free_chunks)\t\t\t\\\n\t{\t\t\t\t\\\n\t  new_chunk = free_chunks;\t\\\n\t  free_chunks = free_chunks->next_chunk; \\\n\t}\t\t\t\t\\\n      else\t\t\t\t\\\n\t{\t\t\t\t\\\n\t  new_chunk = (struct stack_chunk *)alloca (chunk_bytes); \\\n\t  if (!new_chunk)\t\t\\\n\t    {\t\t\t\t\\\n\t      ret_val = 0;\t\t\\\n\t      goto test_do_return;\t\\\n\t    }\t\t\t\t\\\n\t}\t\t\t\t\\\n      new_chunk->sp = (char *)new_chunk + sizeof (struct stack_chunk); \\\n      new_chunk->bytes_left = (chunk_bytes \\\n\t\t\t       - (BYTES) \\\n\t\t\t       - sizeof (struct stack_chunk)); \\\n      new_chunk->next_chunk = CHUNK_VAR; \\\n      CHUNK_VAR = new_chunk;\t\t\\\n    } \\\n  else \\\n    (CHUNK_VAR->sp += (BYTES)), (CHUNK_VAR->bytes_left -= (BYTES))\n\n#define POP(CHUNK_VAR,BYTES) \\\n  if (CHUNK_VAR->sp == ((char *)CHUNK_VAR + sizeof(*CHUNK_VAR))) \\\n    { \\\n      struct stack_chunk * new_chunk = CHUNK_VAR->next_chunk; \\\n      CHUNK_VAR->next_chunk = free_chunks; \\\n      free_chunks = CHUNK_VAR; \\\n      CHUNK_VAR = new_chunk; \\\n    } \\\n  else \\\n    (CHUNK_VAR->sp -= BYTES), (CHUNK_VAR->bytes_left += BYTES)\n\nstruct counter_frame\n{\n  int tag;\n  int val;\n  struct counter_frame * inherited_from; /* If this is a copy. */\n  struct counter_frame * cdr;\n};\n\nstruct backtrack_frame\n{\n  char * counter_stack_sp;\n\n  /* A frame is used to save the matchers state when it crosses a \n   * backtracking point.  The `stk_' fields correspond to variables\n   * in re_search_2 (just strip off thes `stk_').  They are documented\n   * tere.\n   */\n  struct rx_superstate * stk_super;\n  const unsigned char * stk_tst_pos;\n  int stk_tst_half;\n  unsigned int stk_c;\n  const unsigned char * stk_tst_str_half;\n  const unsigned char * stk_tst_end_half;\n  int stk_last_l;\n  int stk_last_r;\n  int stk_test_ret;\n\n  /* This is the list of options left to explore at the backtrack\n   * point for which this frame was created. \n   */\n  struct rx_distinct_future * df;\n  struct rx_distinct_future * first_df;\n\n#ifdef RX_DEBUG\n   int stk_line_no;\n#endif\n};\n\n\f\n\n#if !defined(REGEX_MALLOC) && !defined(__GNUC__)\n#define RE_SEARCH_2_FN\tinner_re_search_2\n#else\n#define RE_SEARCH_2_FN\tre_search_2\n#endif\n\n#ifdef __STDC__\nint\nRE_SEARCH_2_FN (struct re_pattern_buffer *rxb,\n\t\tconst char * string1, int size1,\n\t\tconst char * string2, int size2,\n\t\tint startpos, int range,\n\t\tstruct re_registers *regs,\n\t\tint stop)\n#else\nint\nRE_SEARCH_2_FN (rxb,\n\t\tstring1, size1, string2, size2, startpos, range, regs, stop)\n     struct re_pattern_buffer *rxb;\n     const char * string1;\n     int size1;\n     const char * string2;\n     int size2;\n     int startpos;\n     int range;\n     struct re_registers *regs;\n     int stop;\n#endif\n{\n  /* Two groups of registers are kept.  The group with the register state\n   * of the current test match, and the group that holds the state at the end\n   * of the best known match, if any.\n   *\n   * For some patterns, there may also be registers saved on the stack.\n   */\n  regoff_t * lparen = 0; /* scratch space for register returns */\n  regoff_t * rparen = 0;\n  regoff_t * best_lpspace = 0; /* in case the user doesn't want these */\n  regoff_t * best_rpspace = 0; /* values, we still need space to store\n\t\t\t\t* them.  Normally, this memoryis unused\n\t\t\t\t* and the space pointed to by REGS is \n\t\t\t\t* used instead.\n\t\t\t\t*/\n  \n  int last_l;\t\t\t/* Highest index of a valid lparen. */\n  int last_r;\t\t\t/* It's dual. */\n\n  int * best_lparen;\t\t/* This contains the best known register */\n  int * best_rparen;\t\t/* assignments. \n\t\t\t\t * This may point to the same mem as\n\t\t\t\t * best_lpspace, or it might point to memory\n\t\t\t\t * passed by the caller.\n\t\t\t\t */\n  int best_last_l;\t\t/* best_last_l:best_lparen::last_l:lparen */\n  int best_last_r;\n  \n  \n\n  /* Figure the number of registers we may need for use in backreferences.\n   * The number here includes an element for register zero.  \n   */\n  unsigned num_regs = rxb->re_nsub + 1;\n\n  int total_size = size1 + size2;\n\n\f\n  /***** INIT re_search_2 */\n  \n  /* Check for out-of-range STARTPOS.  */\n  if ((startpos < 0) || (startpos > total_size))\n    return -1;\n\n  /* Fix up RANGE if it might eventually take us outside\n   * the virtual concatenation of STRING1 and STRING2.\n   */\n  {\n    int endpos = startpos + range;\n    if (endpos < -1)\n      range = (-1 - startpos);\n    else if (endpos > total_size)\n      range = total_size - startpos;\n  }\n\n  /* If the search isn't to be a backwards one, don't waste time in a\n   * long search for a pattern that says it is anchored.\n   */\n  if (rxb->begbuf_only && (range > 0))\n    {\n      if (startpos > 0)\n\treturn -1;\n      else\n\trange = 1;\n    }\n\n  /* Then, decide whether to use internal or user-provided reg buffers. */\n  if (!regs || rxb->no_sub)\n    {\n      best_lpspace = (regoff_t *)REGEX_ALLOCATE (num_regs * sizeof(regoff_t));\n      best_rpspace = (regoff_t *)REGEX_ALLOCATE (num_regs * sizeof(regoff_t));\n      best_lparen = best_lpspace;\n      best_rparen = best_rpspace;\n    }\n  else\n    {\t\n      /* Have the register data arrays been allocated?  */\n      if (rxb->regs_allocated == REGS_UNALLOCATED)\n\t{ /* No.  So allocate them with malloc.  We need one\n\t     extra element beyond `num_regs' for the `-1' marker\n\t     GNU code uses.  */\n\t  regs->num_regs = MAX (RE_NREGS, rxb->re_nsub + 1);\n\t  regs->start = TALLOC (regs->num_regs, regoff_t);\n\t  regs->end = TALLOC (regs->num_regs, regoff_t);\n\t  if (regs->start == 0 || regs->end == 0)\n\t    return -2;\n\t  rxb->regs_allocated = REGS_REALLOCATE;\n\t}\n      else if (rxb->regs_allocated == REGS_REALLOCATE)\n\t{ /* Yes.  If we need more elements than were already\n\t     allocated, reallocate them.  If we need fewer, just\n\t     leave it alone.  */\n\t  if (regs->num_regs < num_regs + 1)\n\t    {\n\t      regs->num_regs = num_regs + 1;\n\t      RETALLOC (regs->start, regs->num_regs, regoff_t);\n\t      RETALLOC (regs->end, regs->num_regs, regoff_t);\n\t      if (regs->start == 0 || regs->end == 0)\n\t\treturn -2;\n\t    }\n\t}\n      else if (rxb->regs_allocated != REGS_FIXED)\n\treturn -2;\n\n      if (regs->num_regs < num_regs + 1)\n\t{\n\t  best_lpspace = ((regoff_t *)\n\t\t\t  REGEX_ALLOCATE (num_regs * sizeof(regoff_t)));\n\t  best_rpspace = ((regoff_t *)\n\t\t\t  REGEX_ALLOCATE (num_regs * sizeof(regoff_t)));\n\t  best_lparen = best_lpspace;\n\t  best_rparen = best_rpspace;\n\t}\n      else\n\t{\n\t  best_lparen = regs->start;\n\t  best_rparen = regs->end;\n\t}\n    }\n  \n  lparen = (regoff_t *) REGEX_ALLOCATE (num_regs * sizeof(regoff_t));\n  rparen = (regoff_t *) REGEX_ALLOCATE (num_regs * sizeof(regoff_t)); \n  \n  if (!(best_rparen && best_lparen && lparen && rparen))\n    return -2;\n  \n  best_last_l = best_last_r = -1;\n\n\f\n\n  /***** fastmap/search loop, initialization */\n\n  /* This is the loop that scans using the fastmap, and sometimes tries to \n   * match. From this point on, don't return.  Instead, assign to ret_val\n   * and goto fail.\n   */\n  {\n    const unsigned char * translate = (rxb->translate\n\t\t\t\t       ? (unsigned char *)rxb->translate\n\t\t\t\t       : (unsigned char *)id_translation);\n    \n    /** This is state associated with returning to the caller. */\n\n    int ret_val = -1;\n\n    /*   A sentinal is sometimes installed in the fastmap.  This records\n     *   where so it can be removed before returning.\n     */\n    int fastmap_chr = -1;\n    int fastmap_val = 0;\n\n    /** End of state associated with returning to the caller. */\n\n    /** Start of variables associated with the fastmap based search: */\n\n    char * fastmap = rxb->fastmap ? (char *)rxb->fastmap : (char *)slowmap;\n    int search_direction;\t/* 1 or -1 */\n    int search_end;\t\t/* first position to not try */\n    int offset;\t\t\t/* either size1 or 0 as string == string2 */\n\n    /* The string-pair position of the fastmap/search loop: */\n    const unsigned char * pos;\t/* The current pos. */\n    const unsigned char * string; /* The current string half. */\n    const unsigned char * end;\t/* End of current string. */\n    int size;\t\t\t/* Current string's size */\n    int half;\t\t\t/* 0 means string1, 1 means string2 */\n\n    /** End of variables associated with the fastmap based search: */\n\n\n    /** Start of variables associated with trying a match\n     *  after the fastmap has found a plausible starting point.\n     */\n\n    struct rx_superstate * start_super = 0; /* The superNFA start state. */\n\n    /*\n     * Two nfa's were compiled.  \n     * `0' is complete.\n     * `1' faster but gets registers wrong and ends too soon.\n     */\n    int nfa_choice = ((regs && !rxb->least_subs) ? '\\0' : '\\1');\n\n    const unsigned char * abs_end; /* Don't fetch a character from here. */\n    int first_found;\t\t/* If true, return after finding any match. */\n\n    /** End of variables associated with trying a match. */\n\n    /* Update the fastmap now if not correct already. \n     * When the regexp was compiled, the fastmap was computed\n     * and stored in a bitset.  This expands the bitset into a\n     * character array containing 1s and 0s.\n     */\n    if ((fastmap == rxb->fastmap) && !rxb->fastmap_accurate)\n      rx_blow_up_fastmap (rxb);\n\n    /* Now we build the starting state of the supernfa. */\n    {\n      struct rx_superset * start_contents;\n      struct rx_nfa_state_set * start_nfa_set;\n      \n      /* We presume here that the nfa start state has only one\n       * possible future with no side effects.  \n       */\n      start_nfa_set = rxb->start->futures->destset;\n      if (   rxb->rx.start_set\n\t  && (rxb->rx.start_set->starts_for == &rxb->rx))\n\tstart_contents = rxb->rx.start_set;\n      else\n\t{\n\t  start_contents =\n\t    rx_superstate_eclosure_union (&rxb->rx,\n\t\t\t\t\t  rx_superset_cons (&rxb->rx, 0, 0),\n\t\t\t\t\t  start_nfa_set);\n\t  \n\t  if (!start_contents)\n\t    return -1;\n\n\t  start_contents->starts_for = &rxb->rx;\n\t  rxb->rx.start_set = start_contents;\n\t}\n      if (   start_contents->superstate\n\t  && (start_contents->superstate->rx_id == rxb->rx.rx_id))\n\t{\n\t  start_super = start_contents->superstate;\n\t  rx_lock_superstate (&rxb->rx, start_super);\n\t}\n      else\n\t{\n\t  rx_protect_superset (&rxb->rx, start_contents);\n\t  \n\t  start_super = rx_superstate (&rxb->rx, start_contents);\n\t  if (!start_super)\n\t    return -1;\n\t  rx_lock_superstate (&rxb->rx, start_super);\n\t  rx_release_superset (&rxb->rx, start_contents);\n\t}\n    }\n    \n    /* This computes an upper bound on string addresses for use by\n     * the match-test.\n     */\n    abs_end = ((const unsigned char *) ((stop <= size1)\n\t\t\t\t\t? string1 + stop\n\t\t\t\t\t: string2 + stop - size1));\n\n    /* We have the option to look for the best match or the first\n     * one we can find.  If the user isn't asking for register information,\n     * we don't need to find the best match.\n     */\n    first_found = !regs;\n\n    /* Compute search_end & search_direction for the fastmap loop. */\n    if (range >= 0)\n      {\n\tsearch_end = MIN (size1 + size2, startpos + range) + 1;\n\tsearch_direction = 1;\n      }\n    else\n      {\n\tsearch_end = MAX(-1, startpos + range);\n\tsearch_direction = -1;\n      }\n\n    /* The vacuous search always turns up nothing. */\n    if ((search_direction == 1)\n\t? (startpos > search_end)\n\t: (startpos < search_end))\n      return -1;\n\n    /* Set string/size/offset/end -- the state that tells the fastmap\n     * loop which half of the string we're in.  Also set pos, which\n     * is the addr of the current fastmap scan position.\n     */\n    if (!string2 || (startpos < size1))\n      {\n\tstring = (const unsigned char *)string1;\n\tsize = size1;\n\toffset = 0;\n\tpos = (const unsigned char *)(string1 + startpos);\n\thalf = 0;\n\tend = (const unsigned char *)MIN(string1 + size1, string1 + stop);\n      }\n    else\n      {\n\tstring = (const unsigned char *)string2;\n\tsize = size2;\n\toffset = size1;\n\tpos = (const unsigned char *)(string2 + startpos - size1);\n\thalf = 1;\n\tend = (const unsigned char *)MIN(string2 + size2,\n\t\t\t\t\t string2 + stop - size1);\n      }\n\n\n\f\n\n    /***** fastmap/search loop,  body */\n\n\n  init_fastmap_sentinal:\n\n    /* For the sake of fast fastmapping, set a sentinal in the fastmap.\n     * This sentinal will trap the fastmap loop when it reaches the last\n     * valid character in a string half.\n     *\n     * This must be reset when the fastmap/search loop crosses a string \n     * boundry, and before returning to the caller.  So sometimes,\n     * the fastmap loop is restarted with `continue', othertimes by\n     * `goto init_fastmap_sentinal'.\n     */\n    if (size)\n      {\n\tfastmap_chr = ((search_direction == 1)\n\t\t       ? *(end - 1)\n\t\t       : *string);\n\tfastmap_val = fastmap[fastmap_chr];\n\tfastmap[fastmap_chr] = 1;\n      }\n    else\n      {\n\tfastmap_chr = -1;\n\tfastmap_val = 0;\n      }\n\n    do\n      {\n\t/* If we haven't reached the end of a string half, and if the\n\t * pattern can't match the empty string, then the fastmap \n\t * optimization applies.  This conditional scans using the \n\t * fastmap -- stoping when a string half ends, or when a \n\t * plausible starting point for a match is found.\n\t * It updates HIT_BOUND to tell which case occured.\n\t */\n\tif (pos == end)\n\t  goto fastmap_hit_bound;\n\telse\n\t  {\n\t    if (search_direction == 1)\n\t      {\n\t\tif (fastmap_val)\n\t\t  {\n\t\t    for (;;)\n\t\t      {\n\t\t\twhile (!fastmap[*pos])\n\t\t\t  ++pos;\n\t\t\tgoto commence_a_matchin;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    for (;;)\n\t\t      {\n\t\t\twhile (!fastmap[*pos])\n\t\t\t  ++pos;\n\t\t\tif (*pos != fastmap_chr)\n\t\t\t  goto commence_a_matchin;\n\t\t\telse \n\t\t\t  {\n\t\t\t    ++pos;\n\t\t\t    if (pos == end)\n\t\t\t      goto fastmap_hit_bound;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\tconst unsigned char * bound = string - 1;\n\t\tif (fastmap_val)\n\t\t  {\n\t\t    for (;;)\n\t\t      {\n\t\t\twhile (!fastmap[*pos])\n\t\t\t  --pos;\n\t\t\tgoto commence_a_matchin;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    for (;;)\n\t\t      {\n\t\t\twhile (!fastmap[*pos])\n\t\t\t  --pos;\n\t\t\tif ((*pos != fastmap_chr) || fastmap_val)\n\t\t\t  goto commence_a_matchin;\n\t\t\telse \n\t\t\t  {\n\t\t\t    --pos;\n\t\t\t    if (pos == bound)\n\t\t\t      goto fastmap_hit_bound;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n\t\n      fastmap_hit_bound:\n\t{\n\t  /* If we hit a bound, it may simply be time to switch sides\n\t   * between strings.\n\t   */\n\t  if ((search_direction == 1) && string2 && (half == 0))\n\t    {\n\t      string = (const unsigned char *)string2;\n\t      size = size2;\n\t      offset = size1;\n\t      half = 1;\n\t      end = (const unsigned char *)MIN(string2 + size2,\n\t\t\t\t\t       string2 + stop - size1);\n\t      startpos = size1;\n\t      pos = (const unsigned char *)string2;\n\t      goto init_fastmap_sentinal;\n\t    }\n\t  else if (   string1\n\t\t   && (search_direction == -1)\n\t\t   && (half == 1))\n\t    {\n\t      string = (const unsigned char *)string1;\n\t      size = size1;\n\t      offset = 0;\n\t      end = (const unsigned char *)string1 + size1;\n\t      half = 0;\n\t      startpos = size1 - 1;\n\t      pos = (const unsigned char *)string1 + size1 - 1;\n\t      goto init_fastmap_sentinal;\n\t    }\n\t  /* ...not a string split, simply no more string. \n\t   *\n\t   * When searching backward, running out of string\n\t   * is reason to quit.\n\t   */\n\t  else if (search_direction == -1)\n\t    goto finish;\n\t  \n\t  /* ...when searching forward, we allow the possibility\n\t   * of an (empty) match after the last character in the\n\t   * virtual string.  So, fall through to the matcher\n\t   */\n\t}\n\n\f\n      commence_a_matchin:\n\n\t/***** fastmap/search loop body\n\t *\t      test for a match that begins at pos\n\t */\n\n\t/* Now the fastmap loop has brought us to a plausible \n\t * starting point for a match.  So, it's time to run the\n\t * NFA and see if a match occured.\n\t */\n\n\tstartpos = pos - string + offset;\n\tif (startpos == search_end)\n\t  goto finish;\n\t\n\tlast_l = last_r = 0;\n\tlparen[0] = startpos;\t/* We know match-begin for this test... */\n\n\t/* The test matcher is essentially a recursive function\n\t * that does an exhaustive run of the superNFA at the \n\t * test position.  For performance, that function has \n\t * been in-lined by hand.\n\t */\n\n#undef OF\n#ifndef HAVE_GNUC_LABELS\n#define OF(A,B)\tA\n#else\n#define OF(A,B)\tA: B\n\t  static void * rx_labels_instruction_table[] =\n\t    {\n\t      [rx_backtrack_point] &&backtrack_point,\n\t      [rx_backtrack] &&backtrack,\n\t      [rx_do_side_effects] &&do_side_effects,\n\t      [rx_cache_miss] &&cache_miss,\n\t      [rx_next_char] 0,\n\t      [rx_error_inx] 0\n\t    };\n#endif\n\t{\t  \n\t  /* The current superNFA position of the matcher. */\n\t  struct rx_superstate * super = start_super;\n\t  \n\t  /* The matcher interprets a series of instruction frames.\n\t   * This is the `instruction counter' for the interpretation.\n\t   */\n\t  struct rx_inx * ifr;\n\t  \n\t  /* We insert a ghost character in the string to prime\n\t   * the nfa.  tst_pos, tst_str_half, and tst_end_half\n\t   * keep track of the test-match position and string-half.\n\t   */\n\t  const unsigned char * tst_pos = pos - 1;\n\t  int tst_half = half;\n\t  unsigned char c = nfa_choice;\n\t  \n\t  const unsigned char * tst_str_half = string;\n\t  const unsigned char * tst_end_half = end;\n\t  \n\t  struct stack_chunk * counter_stack = 0;\n\t  struct stack_chunk * backtrack_stack = 0;\n\t  int backtrack_frame_bytes =\n\t    (sizeof (struct backtrack_frame)\n\t     + (rxb->match_regs_on_stack\n\t\t? sizeof (regoff_t) * (num_regs + 1) * 2\n\t\t: 0));\n\t  int chunk_bytes = backtrack_frame_bytes * 64;\n\t  struct stack_chunk * free_chunks = 0;\n\n#ifdef RX_DEBUG\n\t  int backtrack_depth = 0;\n#endif\n\n\t  /* To return from this function, set test_ret and \n\t   * `goto test_do_return'.\n\t   *\n\t   * Possible return values are:\n\t   *     1   --- end of string while the superNFA is still going\n\t   *     0   --- internal error (out of memory)\n\t   *\t-1   --- search completed by reaching the superNFA fail state\n\t   *    -2   --- a match was found, maybe not the longest.\n\t   *\n\t   * When the search is complete (-1), best_last_r indicates whether\n\t   * a match was found.\n\t   *\n\t   * -2 is return only if first_found is non-zero.\n\t   *\n\t   * if first_found is non-zero, a return of -1 indicates no match,\n\t   * otherwise, best_last_r has to be checked.\n\t   */\n\t  int test_ret = -1;\n\t  \n\t  while (1)\n\t    {\n\t      int inx;\n#ifdef RX_DEBUG\n\t      /* There is a search tree with every node as set of deterministic\n\t       * transitions in the super nfa.  For every branch of a \n\t       * backtrack point is an edge in the tree.\n\t       * This counts up a pre-order of nodes in that tree.\n\t       * It's saved on the search stack and printed when debugging. \n\t       */\n\t      int line_no = 0;\n\t      int lines_found = 0;\n#endif\n\n\n\t    top_of_cycle:\n\t      /* A superstate is basicly a transition table, indexed by \n\t       * characters from the string being tested, and containing \n\t       * RX_INX structures.\n\t       */\n\t      ifr = &super->transitions [c];\n\t      \n\t    recurse_test_match:\n\t      /* This is the point to which control is sent when the\n\t       * test matcher recurses.  Before jumping here, some variables\n\t       * need to be saved on the stack and setup for the recursion.\n\t       */\n\n\t    restart:\n\t      /* Some instructions don't advance the matcher, but just\n\t       * carry out some side effects and fetch a new instruction.\n\t       * To dispatch that new instruction, `goto restart'.\n\t       */\n\t      \n\t      {\n\t\tstruct rx_inx * next_tr_table = (struct rx_inx *)ifr->data;\n\t\tstruct rx_inx * this_tr_table = super->transitions;\n\t\t/* The fastest route through the loop is when the instruction \n\t\t * is RX_NEXT_CHAR.  This case is detected when IFR->DATA\n\t\t * is non-zero.  In that case, it points to the next\n\t\t * superstate. \n\t\t *\n\t\t * This allows us to not bother fetching the bytecode.\n\t\t */\n\t\twhile (next_tr_table)\n\t\t  {\n#ifdef RX_DEBUG\n\t\t    if (rx_debug_trace)\n\t\t      {\n\t\t\tstruct rx_superset * setp;\n\n\t\t\tfprintf (stderr, \"%d %d>> re_next_char @ %d (%d)\",\n\t\t\t\t line_no,\n\t\t\t\t backtrack_depth,\n\t\t\t\t (tst_pos - tst_str_half\n\t\t\t\t  + (tst_half == 0\n\t\t\t\t     ? 0 : size1)), c);\n\t\t\t\n\t\t\tsuper =\n\t\t\t  ((struct rx_superstate *)\n\t\t\t   ((char *)this_tr_table\n\t\t\t    - ((unsigned long)\n\t\t\t       ((struct rx_superstate *)0)->transitions)));\n\n\t\t\tsetp = super->contents;\n\t\t\tfprintf (stderr, \"   superstet (rx=%d, &=%x: \",\n\t\t\t\t rxb->rx.rx_id, setp);\n\t\t\twhile (setp)\n\t\t\t  {\n\t\t\t    fprintf (stderr, \"%d \", setp->id);\n\t\t\t    setp = setp->cdr;\n\t\t\t  }\n\t\t\tfprintf (stderr, \"\\n\");\n\t\t      }\n#endif\n\t\t    this_tr_table = next_tr_table;\n\t\t    ++tst_pos;\n\t\t    if (tst_pos == tst_end_half)\n\t\t      {\n\t\t\tif (   (tst_pos != abs_end)\n\t\t\t    && string2\n\t\t\t    && half == 0)\n\t\t\t  {\n\t\t\t    /* Here we are crossing the break \n\t\t\t     * in a split string. \n\t\t\t     */\n\t\t\t    tst_str_half = (const unsigned char *)string2;\n\t\t\t    tst_end_half = abs_end;\n\t\t\t    tst_pos = (const unsigned char *)string2;\n\t\t\t    tst_half = 1;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    test_ret = 1;\n\t\t\t    goto test_do_return;\n\t\t\t  }\n\t\t      }\n\t\t    c = *tst_pos;\n\t\t    ifr = this_tr_table + c;\n\t\t    next_tr_table = (struct rx_inx *)ifr->data;\n\t\t  }\n\t\t\n\t\t/* Here when we ran out cached next-char transitions. \n\t\t * So, it will be necessary to do a more expensive\n\t\t * dispatch on the current instruction.  The superstate\n\t\t * pointer is allowed to become invalid during next-char\n\t\t * transitions -- now we must bring it up to date.\n\t\t */\n\t\tsuper =\n\t\t  ((struct rx_superstate *)\n\t\t   ((char *)this_tr_table\n\t\t    - ((unsigned long)\n\t\t       ((struct rx_superstate *)0)->transitions)));\n\t      }\n\t      \n\t      /* We've encountered an instruction other than next-char.\n\t       * Dispatch that instruction:\n\t       */\n\t      inx = (int)ifr->inx;\n#ifdef HAVE_GNUC_LABELS\n\t      goto *rx_labels_instruction_table[inx];\n#endif\n#ifdef RX_DEBUG\n\t      if (rx_debug_trace)\n\t\t{\n\t\t  struct rx_superset * setp = super->contents;\n\t\t  \n\t\t  fprintf (stderr, \"%d %d>> %s @ %d (%d)\", line_no,\n\t\t\t   backtrack_depth,\n\t\t\t   inx_names[inx],\n\t\t\t   (tst_pos - tst_str_half\n\t\t\t    + (tst_half == 0 ? 0 : size1)), c);\n\t\t  \n\t\t  fprintf (stderr, \"   superstet (rx=%d, &=%x: \",\n\t\t\t   rxb->rx.rx_id, setp);\n\t\t  while (setp)\n\t\t    {\n\t\t      fprintf (stderr, \"%d \", setp->id);\n\t\t      setp = setp->cdr;\n\t\t    }\n\t\t  fprintf (stderr, \"\\n\");\n\t\t}\n#endif\n\t      switch ((enum rx_opcode)inx)\n\t\t{\n\t\tcase OF(rx_do_side_effects,do_side_effects):\n\n\t\t  /*  RX_DO_SIDE_EFFECTS occurs when we cross epsilon \n\t\t   *  edges associated with parentheses, backreferencing, etc.\n\t\t   */\n\t\t  {\n\t\t    struct rx_distinct_future * df =\n\t\t      (struct rx_distinct_future *)ifr->data_2;\n\t\t    struct rx_se_list * el = df->effects;\n\t\t    /* Side effects come in lists.  This walks down\n\t\t     * a list, dispatching.\n\t\t     */\n\t\t    while (el)\n\t\t      {\n#ifdef HAVE_GNUC_LABELS\n\t\t\tstatic void * se_labels[] =\n\t\t\t  {\n\t\t\t    [-re_se_try] &&se_try,\n\t\t\t    [-re_se_pushback] &&se_pushback,\n\t\t\t    [-re_se_push0] &&se_push0,\n\t\t\t    [-re_se_pushpos] &&se_pushpos,\n\t\t\t    [-re_se_chkpos] &&se_chkpos,\n\t\t\t    [-re_se_poppos] &&se_poppos,\n#ifdef emacs\n\t\t\t    [-re_se_at_dot] &&se_at_dot,\n\t\t\t    [-re_se_syntax] &&se_syntax,\n\t\t\t    [-re_se_not_syntax] &&se_not_syntax,\n#endif\n\t\t\t    [-re_se_begbuf] &&se_begbuf,\n\t\t\t    [-re_se_hat] &&se_hat,\n\t\t\t    [-re_se_wordbeg] &&se_wordbeg,\n\t\t\t    [-re_se_wordbound] &&se_wordbound,\n\t\t\t    [-re_se_notwordbound] &&se_notwordbound,\n\t\t\t    [-re_se_wordend] &&se_wordend,\n\t\t\t    [-re_se_endbuf] &&se_endbuf,\n\t\t\t    [-re_se_dollar] &&se_dollar,\n\t\t\t    [-re_se_fail] &&se_fail,\n\t\t\t  };\n\t\t\tstatic void * se_lables2[] =\n\t\t\t  {\n\t\t\t    [re_se_win] &&se_win\n\t\t\t    [re_se_lparen] &&se_lparen,\n\t\t\t    [re_se_rparen] &&se_rparen,\n\t\t\t    [re_se_backref] &&se_backref,\n\t\t\t    [re_se_iter] &&se_iter,\n\t\t\t    [re_se_end_iter] &&se_end_iter,\n\t\t\t    [re_se_tv] &&se_tv\n\t\t\t  };\n#endif\n\t\t\tint effect = (int)el->car;\n\t\t\tif (effect < 0)\n\t\t\t  {\n#ifdef HAVE_GNUC_LABELS\n\t\t\t    goto *se_labels[-effect];\n#endif\n#ifdef RX_DEBUG\n\t\t\t    if (rx_debug_trace)\n\t\t\t      {\n\t\t\t\tstruct rx_superset * setp = super->contents;\n\t\t\t\t\n\t\t\t\tfprintf (stderr, \"....%d %d>> %s\\n\", line_no,\n\t\t\t\t\t backtrack_depth,\n\t\t\t\t\t efnames[-effect]);\n\t\t\t      }\n#endif\n\t\t\t    switch ((enum re_side_effects) effect)\n\t\t\t      {\n\t\t\t      case OF(re_se_pushback,se_pushback):\n\t\t\t\tifr = &df->future_frame;\n\t\t\t\tif (!ifr->data)\n\t\t\t\t  {\n\t\t\t\t    struct rx_superstate * sup = super;\n\t\t\t\t    rx_lock_superstate (rx, sup);\n\t\t\t\t    if (!rx_handle_cache_miss (&rxb->rx,\n\t\t\t\t\t\t\t       super, c,\n\t\t\t\t\t\t\t       ifr->data_2))\n\t\t\t\t      {\n\t\t\t\t\trx_unlock_superstate (rx, sup);\n\t\t\t\t\ttest_ret = 0;\n\t\t\t\t\tgoto test_do_return;\n\t\t\t\t      }\n\t\t\t\t    rx_unlock_superstate (rx, sup);\n\t\t\t\t  }\n\t\t\t\t/* --tst_pos; */\n\t\t\t\tc = 't';\n\t\t\t\tsuper\n\t\t\t\t  = ((struct rx_superstate *)\n\t\t\t\t     ((char *)ifr->data\n\t\t\t\t      - (long)(((struct rx_superstate *)0)\n\t\t\t\t\t       ->transitions)));\n\t\t\t\tgoto top_of_cycle;\n\t\t\t\tbreak;\n\t\t\t      case OF(re_se_push0,se_push0):\n\t\t\t\t{\n\t\t\t\t  struct counter_frame * old_cf\n\t\t\t\t     = (counter_stack\n\t\t\t\t\t? ((struct counter_frame *)\n\t\t\t\t\t   counter_stack->sp)\n\t\t\t\t\t: 0);\n\t\t\t\t  struct counter_frame * cf;\n\t\t\t\t  PUSH (counter_stack,\n\t\t\t\t\tsizeof (struct counter_frame));\n\t\t\t\t  cf = ((struct counter_frame *)\n\t\t\t\t\tcounter_stack->sp);\n\t\t\t\t  cf->tag = re_se_iter;\n\t\t\t\t  cf->val = 0;\n\t\t\t\t  cf->inherited_from = 0;\n\t\t\t\t  cf->cdr = old_cf;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t      case OF(re_se_fail,se_fail):\n\t\t\t\tgoto test_do_return;\n\t\t\t      case OF(re_se_begbuf,se_begbuf):\n\t\t\t\tif (!AT_STRINGS_BEG ())\n\t\t\t\t  goto test_do_return;\n\t\t\t\tbreak;\n\t\t\t      case OF(re_se_endbuf,se_endbuf):\n\t\t\t\tif (!AT_STRINGS_END ())\n\t\t\t\t  goto test_do_return;\n\t\t\t\tbreak;\n\t\t\t      case OF(re_se_wordbeg,se_wordbeg):\n\t\t\t\tif (   LETTER_P (tst_pos + 1)\n\t\t\t\t    && (   AT_STRINGS_BEG()\n\t\t\t\t\t|| !LETTER_P (tst_pos)))\n\t\t\t\t  break;\n\t\t\t\telse\n\t\t\t\t  goto test_do_return;\n\t\t\t      case OF(re_se_wordend,se_wordend):\n\t\t\t\tif (   !AT_STRINGS_BEG ()\n\t\t\t\t    && LETTER_P (tst_pos)\n\t\t\t\t    && (AT_STRINGS_END ()\n\t\t\t\t\t|| !LETTER_P (tst_pos + 1)))\n\t\t\t\t  break;\n\t\t\t\telse\n\t\t\t\t  goto test_do_return;\n\t\t\t      case OF(re_se_wordbound,se_wordbound):\n\t\t\t\tif (AT_WORD_BOUNDARY (tst_pos))\n\t\t\t\t  break;\n\t\t\t\telse\n\t\t\t\t  goto test_do_return;\n\t\t\t      case OF(re_se_notwordbound,se_notwordbound):\n\t\t\t\tif (!AT_WORD_BOUNDARY (tst_pos))\n\t\t\t\t  break;\n\t\t\t\telse\n\t\t\t\t  goto test_do_return;\n\t\t\t      case OF(re_se_hat,se_hat):\n\t\t\t\tif (AT_STRINGS_BEG ())\n\t\t\t\t  {\n\t\t\t\t    if (rxb->not_bol)\n\t\t\t\t      goto test_do_return;\n\t\t\t\t    else\n\t\t\t\t      break;\n\t\t\t\t  }\n\t\t\t\telse\n\t\t\t\t  {\n\t\t\t\t    char pos_c = *tst_pos;\n\t\t\t\t    if (   (TRANSLATE (pos_c)\n\t\t\t\t\t    == TRANSLATE('\\n'))\n\t\t\t\t\t&& rxb->newline_anchor)\n\t\t\t\t      break;\n\t\t\t\t    else\n\t\t\t\t      goto test_do_return;\n\t\t\t\t  }\n\t\t\t      case OF(re_se_dollar,se_dollar):\n\t\t\t\tif (AT_STRINGS_END ())\n\t\t\t\t  {\n\t\t\t\t    if (rxb->not_eol)\n\t\t\t\t      goto test_do_return;\n\t\t\t\t    else\n\t\t\t\t      break;\n\t\t\t\t  }\n\t\t\t\telse\n\t\t\t\t  {\n\t\t\t\t    const unsigned char * next_pos\n\t\t\t\t      = ((string2 && (tst_half == 0) &&\n\t\t\t\t\t  (tst_pos\n\t\t\t\t\t   == ((unsigned char *)\n\t\t\t\t\t       string1 + size1 - 1)))\n\t\t\t\t\t ? (unsigned char *)string2\n\t\t\t\t\t : tst_pos + 1);\n\t\t\t\t    \n\t\t\t\t    if (   (TRANSLATE (*next_pos)\n\t\t\t\t\t    == TRANSLATE ('\\n'))\n\t\t\t\t\t&& rxb->newline_anchor)\n\t\t\t\t      break;\n\t\t\t\t    else\n\t\t\t\t      goto test_do_return;\n\t\t\t\t  }\n\t\t\t\t\n\t\t\t      case OF(re_se_try,se_try):\n\t\t\t\t/* This is the first side effect in every\n\t\t\t\t * expression.\n\t\t\t\t *\n\t\t\t\t *  FOR NO GOOD REASON...get rid of it...\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\t      case OF(re_se_pushpos,se_pushpos):\n\t\t\t\t{\n\t\t\t\t  int urhere =\n\t\t\t\t    ((int)(tst_pos - tst_str_half)\n\t\t\t\t     + ((tst_half == 0) ? 0 : size1));\n\t\t\t\t  struct counter_frame * old_cf\n\t\t\t\t    = (counter_stack\n\t\t\t\t       ? ((struct counter_frame *)\n\t\t\t\t\t  counter_stack->sp)\n\t\t\t\t       : 0);\n\t\t\t\t  struct counter_frame * cf;\n\t\t\t\t  PUSH(counter_stack,\n\t\t\t\t       sizeof (struct counter_frame));\n\t\t\t\t  cf = ((struct counter_frame *)\n\t\t\t\t\tcounter_stack->sp);\n\t\t\t\t  cf->tag = re_se_pushpos;\n\t\t\t\t  cf->val = urhere;\n\t\t\t\t  cf->inherited_from = 0;\n\t\t\t\t  cf->cdr = old_cf;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t      case OF(re_se_chkpos,se_chkpos):\n\t\t\t\t{\n\t\t\t\t  int urhere =\n\t\t\t\t    ((int)(tst_pos - tst_str_half)\n\t\t\t\t     + ((tst_half == 0) ? 0 : size1));\n\t\t\t\t  struct counter_frame * cf\n\t\t\t\t    = ((struct counter_frame *)\n\t\t\t\t       counter_stack->sp);\n\t\t\t\t  if (cf->val == urhere)\n\t\t\t\t    goto test_do_return;\n\t\t\t\t  cf->val = urhere;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t      case OF(re_se_poppos,se_poppos):\n\t\t\t\tPOP(counter_stack,\n\t\t\t\t    sizeof (struct counter_frame));\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t\n\t\t\t      case OF(re_se_at_dot,se_at_dot):\n\t\t\t      case OF(re_se_syntax,se_syntax):\n\t\t\t      case OF(re_se_not_syntax,se_not_syntax):\n#ifdef emacs\n\t\t\t\tthis release lacks emacs support;\n\t\t\t\t(coming soon);\n#endif\n\t\t\t\tbreak;\n\t\t\t      case re_se_win:\n\t\t\t      case re_se_lparen:\n\t\t\t      case re_se_rparen:\n\t\t\t      case re_se_backref:\n\t\t\t      case re_se_iter:\n\t\t\t      case re_se_end_iter:\n\t\t\t      case re_se_tv:\n\t\t\t      case re_floogle_flap:\n\t\t\t\tret_val = 0;\n\t\t\t\tgoto test_do_return;\n\t\t\t      }\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n#ifdef HAVE_GNUC_LABELS\n\t\t\t    goto *se_lables2[(rxb->se_params [effect].se)];\n#endif\n#ifdef RX_DEBUG\n\t\t\t  if (rx_debug_trace)\n\t\t\t    fprintf (stderr, \"....%d %d>> %s %d %d\\n\", line_no,\n\t\t\t\t     backtrack_depth,\n\t\t\t\t     efnames2[rxb->se_params [effect].se],\n\t\t\t\t     rxb->se_params [effect].op1,\n\t\t\t\t     rxb->se_params [effect].op2);\n#endif\n\t\t\t    switch (rxb->se_params [effect].se)\n\t\t\t      {\n\t\t\t      case OF(re_se_win,se_win):\n\t\t\t\t/* This side effect indicates that we've \n\t\t\t\t * found a match, though not necessarily the \n\t\t\t\t * best match.  This is a fancy assignment to \n\t\t\t\t * register 0 unless the caller didn't \n\t\t\t\t * care about registers.  In which case,\n\t\t\t\t * this stops the match.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t  int urhere =\n\t\t\t\t    ((int)(tst_pos - tst_str_half)\n\t\t\t\t     + ((tst_half == 0)\n\t\t\t\t\t? 0 : size1));\n\n\t\t\t\t  if (   (best_last_r < 0)\n\t\t\t\t      || (urhere + 1 > best_rparen[0]))\n\t\t\t\t    {\n\t\t\t\t      /* Record the best known and keep\n\t\t\t\t       * looking.\n\t\t\t\t       */\n\t\t\t\t      int x;\n\t\t\t\t      for (x = 0; x <= last_l; ++x)\n\t\t\t\t\tbest_lparen[x] = lparen[x];\n\t\t\t\t      best_last_l = last_l;\n\t\t\t\t      for (x = 0; x <= last_r; ++x)\n\t\t\t\t\tbest_rparen[x] = rparen[x];\n\t\t\t\t      best_rparen[0] = urhere + 1;\n\t\t\t\t      best_last_r = last_r;\n\t\t\t\t    }\n\t\t\t\t  /* If we're not reporting the match-length \n\t\t\t\t   * or other register info, we need look no\n\t\t\t\t   * further.\n\t\t\t\t   */\n\t\t\t\t  if (first_found)\n\t\t\t\t    {\n\t\t\t\t      test_ret = -2;\n\t\t\t\t      goto test_do_return;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t      case OF(re_se_lparen,se_lparen):\n\t\t\t\t{\n\t\t\t\t  int urhere =\n\t\t\t\t    ((int)(tst_pos - tst_str_half)\n\t\t\t\t     + ((tst_half == 0) ? 0 : size1));\n\t\t\t\t  \n\t\t\t\t  int reg = rxb->se_params [effect].op1;\n#if 0\n\t\t\t\t  if (reg > last_l)\n#endif\n\t\t\t\t    {\n\t\t\t\t      lparen[reg] = urhere + 1;\n\t\t\t\t      /* In addition to making this assignment,\n\t\t\t\t       * we now know that lower numbered regs\n\t\t\t\t       * that haven't already been assigned,\n\t\t\t\t       * won't be.  We make sure they're\n\t\t\t\t       * filled with -1, so they can be\n\t\t\t\t       * recognized as unassigned.\n\t\t\t\t       */\n\t\t\t\t      if (last_l < reg)\n\t\t\t\t\twhile (++last_l < reg)\n\t\t\t\t\t  lparen[last_l] = -1;\n\t\t\t\t    }\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t      case OF(re_se_rparen,se_rparen):\n\t\t\t\t{\n\t\t\t\t  int urhere =\n\t\t\t\t    ((int)(tst_pos - tst_str_half)\n\t\t\t\t     + ((tst_half == 0) ? 0 : size1));\n\t\t\t\t  int reg = rxb->se_params [effect].op1;\n\t\t\t\t  rparen[reg] = urhere + 1;\n\t\t\t\t  if (last_r < reg)\n\t\t\t\t    {\n\t\t\t\t      while (++last_r < reg)\n\t\t\t\t\trparen[last_r] = -1;\n\t\t\t\t    }\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t      case OF(re_se_backref,se_backref):\n\t\t\t\t{\n\t\t\t\t  int reg = rxb->se_params [effect].op1;\n\t\t\t\t  if (reg > last_r || rparen[reg] < 0)\n\t\t\t\t    goto test_do_return;\n\t\t\t\t  {\n\t\t\t\t    /* fixme */\n\t\t\t\t    const unsigned char * there\n\t\t\t\t      = tst_str_half + lparen[reg];\n\t\t\t\t    const unsigned char * last\n\t\t\t\t      = tst_str_half + rparen[reg];\n\t\t\t\t    const unsigned char * here = tst_pos + 1;\n\n\t\t\t\t    if ((here == tst_end_half) && string2\n\t\t\t\t\t&& (tst_str_half\n\t\t\t\t\t    == (unsigned char *) string1)\n\t\t\t\t\t&& (tst_end_half != abs_end))\n\t\t\t\t      {\n\t\t\t\t\there = (unsigned char *)string2;\n\t\t\t\t\ttst_end_half = abs_end;\n\t\t\t\t      }\n\t\t\t\t    \n\t\t\t\t    while (there < last && here < tst_end_half)\t/* 4% */\n\t\t\t\t      if (TRANSLATE(*there) /* &&&& 6% */\n\t\t\t\t\t  != TRANSLATE(*here))\n\t\t\t\t\tgoto test_do_return;\n\t\t\t\t      else\n\t\t\t\t\t{\n\t\t\t\t\t  ++there; ++here;\n\t\t\t\t\t  if ((here == tst_end_half) && string2\n\t\t\t\t\t      && (tst_str_half\n\t\t\t\t\t\t  == (unsigned char *)string1)\n\t\t\t\t\t      && (tst_end_half != abs_end))\n\t\t\t\t\t    {\n\t\t\t\t\t      here = (unsigned char *)string2;\n\t\t\t\t\t      tst_end_half = abs_end;\n\t\t\t\t\t      tst_half = 1;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    if (there != last)\n\t\t\t\t      goto test_do_return;\n\t\t\t\t    tst_pos = here - 1;\n\t\t\t\t    if ((here == (unsigned char *)string2)\n\t\t\t\t\t&& (unsigned char *)string1)\n\t\t\t\t      {\n\t\t\t\t\ttst_pos = ((unsigned char *)string1\n\t\t\t\t\t\t   + size1 - 1);\n\t\t\t\t\ttst_end_half = tst_pos + 1;\n\t\t\t\t\ttst_half = 0;\n\t\t\t\t      }\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t      case OF(re_se_iter,se_iter):\n\t\t\t\t{\n\t\t\t\t  struct counter_frame * csp\n\t\t\t\t    = ((struct counter_frame *)\n\t\t\t\t       counter_stack->sp);\n\t\t\t\t  if (csp->val == rxb->se_params[effect].op2)\n\t\t\t\t    goto test_do_return;\n\t\t\t\t  else\n\t\t\t\t    ++csp->val;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t      case OF(re_se_end_iter,se_end_iter):\n\t\t\t\t{\n\t\t\t\t  struct counter_frame * csp\n\t\t\t\t    = ((struct counter_frame *)\n\t\t\t\t       counter_stack->sp);\n\t\t\t\t  if (csp->val < rxb->se_params[effect].op1)\n\t\t\t\t    goto test_do_return;\n\t\t\t\t  else\n\t\t\t\t    {\n\t\t\t\t      struct counter_frame * source = csp;\n\t\t\t\t      while (source->inherited_from)\n\t\t\t\t\tsource = source->inherited_from;\n\t\t\t\t      if (!source || !source->cdr)\n\t\t\t\t\t{\n\t\t\t\t\t  POP(counter_stack,\n\t\t\t\t\t      sizeof(struct counter_frame));\n\t\t\t\t\t}\n\t\t\t\t      else\n\t\t\t\t\t{\n\t\t\t\t\t  source = source->cdr;\n\t\t\t\t\t  csp->val = source->val;\n\t\t\t\t\t  csp->tag = source->tag;\n\t\t\t\t\t  csp->cdr = 0;\n\t\t\t\t\t  csp->inherited_from = source;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t      case OF(re_se_tv, se_tv):\n\t\t\t\t/* is a noop */\n\t\t\t\tbreak;\n\t\t\t      case re_se_try:\n\t\t\t      case re_se_pushback:\n\t\t\t      case re_se_push0:\n\t\t\t      case re_se_pushpos:\n\t\t\t      case re_se_chkpos:\n\t\t\t      case re_se_poppos:\n\t\t\t      case re_se_at_dot:\n\t\t\t      case re_se_syntax:\n\t\t\t      case re_se_not_syntax:\n\t\t\t      case re_se_begbuf:\n\t\t\t      case re_se_hat:\n\t\t\t      case re_se_wordbeg:\n\t\t\t      case re_se_wordbound:\n\t\t\t      case re_se_notwordbound:\n\t\t\t      case re_se_wordend:\n\t\t\t      case re_se_endbuf:\n\t\t\t      case re_se_dollar:\n\t\t\t      case re_se_fail:\n\t\t\t      case re_floogle_flap:\n\t\t\t\tret_val = 0;\n\t\t\t\tgoto test_do_return;\n\t\t\t      }\n\t\t\t  }\n\t\t\tel = el->cdr;\n\t\t      }\n\t\t    /* Now the side effects are done,\n\t\t     * so get the next instruction.\n\t\t     * and move on.\n\t\t     */\n\t\t    ifr = &df->future_frame;\n\t\t    goto restart;\n\t\t  }\n\t\t  \n\t\tcase OF(rx_backtrack_point,backtrack_point):\n\t\t  {\n\t\t    /* A backtrack point indicates that we've reached a\n\t\t     * non-determinism in the superstate NFA.  This is a\n\t\t     * loop that exhaustively searches the possibilities.\n\t\t     *\n\t\t     * A backtracking strategy is used.  We keep track of what\n\t\t     * registers are valid so we can erase side effects.\n\t\t     *\n\t\t     * First, make sure there is some stack space to hold \n\t\t     * our state.\n\t\t     */\n\n\t\t    struct backtrack_frame * bf;\n\n\t\t    PUSH(backtrack_stack, backtrack_frame_bytes);\n#ifdef RX_DEBUG\n\t\t    ++backtrack_depth;\n#endif\n\n\t\t    bf = ((struct backtrack_frame *)\n\t\t\t  backtrack_stack->sp);\n\t\t    {\n\t\t      bf->stk_super = super;\n\t\t      /* We prevent the current superstate from being\n\t\t       * deleted from the superstate cache.\n\t\t       */\n\t\t      rx_lock_superstate (&rxb->rx, super);\n\t\t      bf->stk_tst_pos = tst_pos;\n#ifdef RX_DEBUG\n\t\t      bf->stk_line_no = line_no;\n#endif\n\t\t      bf->stk_tst_half = tst_half;\n\t\t      bf->stk_c = c;\n\t\t      bf->stk_tst_str_half = tst_str_half;\n\t\t      bf->stk_tst_end_half = tst_end_half;\n\t\t      bf->stk_last_l = last_l;\n\t\t      bf->stk_last_r = last_r;\n\t\t      bf->df = ((struct rx_super_edge *)ifr->data_2)->options;\n\t\t      bf->first_df = bf->df;\n\t\t      bf->counter_stack_sp = (counter_stack\n\t\t\t\t\t      ? counter_stack->sp\n\t\t\t\t\t      : 0);\n\t\t      bf->stk_test_ret = test_ret;\n\t\t      if (rxb->match_regs_on_stack)\n\t\t\t{\n\t\t\t  int x;\n\t\t\t  regoff_t * stk =\n\t\t\t    (regoff_t *)((char *)bf + sizeof (*bf));\n\t\t\t  for (x = 0; x <= last_l; ++x)\n\t\t\t    stk[x] = lparen[x];\n\t\t\t  stk += x;\n\t\t\t  for (x = 0; x <= last_r; ++x)\n\t\t\t    stk[x] = rparen[x];\n\t\t\t}\n\n\t\t    }\n\n\t\t    /* Here is a while loop whose body is mainly a function\n\t\t     * call and some code to handle a return from that\n\t\t     * function.\n\t\t     *\n\t\t     * From here on for the rest of `case backtrack_point' it\n\t\t     * is unsafe to assume that the variables saved on the\n\t\t     * stack are valid -- so reread their values from the stack\n\t\t     * as needed.\n\t\t     *\n\t\t     * This lets us re-use one generation fewer stack saves in\n\t\t     * the call-graph of a search.\n\t\t     */\n\t\t    \n\t\t  while_non_det_options:\n#ifdef RX_DEBUG\n\t\t    ++lines_found;\n\t\t    if (rx_debug_trace)\n\t\t      fprintf (stderr, \"@@@ %d calls %d @@@\\n\",\n\t\t\t       line_no, lines_found);\n\t\t    \n\t\t    line_no = lines_found;\n#endif\n\t\t    \n\t\t    if (bf->df->next_same_super_edge[0] == bf->first_df)\n\t\t      {\n\t\t\t/* This is a tail-call optimization -- we don't recurse\n\t\t\t * for the last of the possible futures.\n\t\t\t */\n\t\t\tifr = (bf->df->effects\n\t\t\t       ? &bf->df->side_effects_frame\n\t\t\t       : &bf->df->future_frame);\n\n\t\t\trx_unlock_superstate (&rxb->rx, super);\n\t\t\tPOP(backtrack_stack, backtrack_frame_bytes);\n#ifdef RX_DEBUG\n\t\t\t--backtrack_depth;\n#endif\n\t\t\tgoto restart;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tif (counter_stack)\n\t\t\t  {\n\t\t\t    struct counter_frame * old_cf\n\t\t\t      = ((struct counter_frame *)counter_stack->sp);\n\t\t\t    struct counter_frame * cf;\n\t\t\t    PUSH(counter_stack, sizeof (struct counter_frame));\n\t\t\t    cf = ((struct counter_frame *)counter_stack->sp);\n\t\t\t    cf->tag = old_cf->tag;\n\t\t\t    cf->val = old_cf->val;\n\t\t\t    cf->inherited_from = old_cf;\n\t\t\t    cf->cdr = 0;\n\t\t\t  }\t\t\t\n\t\t\t/* `Call' this test-match block */\n\t\t\tifr = (bf->df->effects\n\t\t\t       ? &bf->df->side_effects_frame\n\t\t\t       : &bf->df->future_frame);\n\t\t\tgoto recurse_test_match;\n\t\t      }\n\n\t\t    /* Returns in this block are accomplished by\n\t\t     * goto test_do_return.  There are two cases.\n\t\t     * If there is some search-stack left,\n\t\t     * then it is a return from a `recursive' call.\n\t\t     * If there is no search-stack left, then\n\t\t     * we should return to the fastmap/search loop.\n\t\t     */\n\t\t    \n\t\t  test_do_return:\n\n\t\t    if (!backtrack_stack)\n\t\t      {\n#ifdef RX_DEBUG\n\t\t\tif (rx_debug_trace)\n\t\t\t  fprintf (stderr, \"!!! %d bails returning %d !!!\\n\",\n\t\t\t\t   line_no, test_ret);\n#endif\n\n\t\t\t/* No more search-stack -- this test is done. */\n\t\t\tif (test_ret)\n\t\t\t  goto return_from_test_match;\n\t\t\telse\n\t\t\t  goto error_in_testing_match;\n\t\t      }\n\n\t\t    /* Ok..we're returning from a recursive call to \n\t\t     * the test match block:\n\t\t     */\n\t\t    \n\t\t    bf = ((struct backtrack_frame *)\n\t\t\t  backtrack_stack->sp);\n#ifdef RX_DEBUG\n\t\t    if (rx_debug_trace)\n\t\t      fprintf (stderr, \"+++ %d returns %d (to %d)+++\\n\",\n\t\t\t       line_no, test_ret, bf->stk_line_no);\n#endif\n\n\t\t    while (counter_stack\n\t\t\t   && (!bf->counter_stack_sp\n\t\t\t       || (bf->counter_stack_sp != counter_stack->sp)))\n\t\t      {\n\t\t\tPOP(counter_stack, sizeof (struct counter_frame));\n\t\t      }\n\n\t\t    if (!test_ret)\n\t\t      {\n\t\t\tPOP (backtrack_stack, backtrack_frame_bytes);\n\t\t\tgoto test_do_return;\n\t\t      }\n\n\t\t    /* If any possible future reaches the end of the \n\t\t     * string without failing, make sure we propogate \n\t\t     * that information to the caller.\n\t\t     */\n\t\t    if ((test_ret == -2) && first_found)\n\t\t      {\n\t\t\trx_unlock_superstate (&rxb->rx, bf->stk_super);\n\t\t\tPOP (backtrack_stack, backtrack_frame_bytes);\n\t\t\tgoto test_do_return;\n\t\t      }\n\n\t\t    if (bf->stk_test_ret < 0)\n\t\t      test_ret = bf->stk_test_ret;\n\n\t\t    last_l = bf->stk_last_l;\n\t\t    last_r = bf->stk_last_r;\n\t\t    bf->df = bf->df->next_same_super_edge[0];\n\t\t    super = bf->stk_super;\n\t\t    tst_pos = bf->stk_tst_pos;\n\t\t    tst_half = bf->stk_tst_half;\n\t\t    c = bf->stk_c;\n\t\t    tst_str_half = bf->stk_tst_str_half;\n\t\t    tst_end_half = bf->stk_tst_end_half;\n#ifdef RX_DEBUG\n\t\t    line_no = bf->stk_line_no;\n#endif\n\n\t\t    if (rxb->match_regs_on_stack)\n\t\t      {\n\t\t\tint x;\n\t\t\tregoff_t * stk =\n\t\t\t  (regoff_t *)((char *)bf + sizeof (*bf));\n\t\t\tfor (x = 0; x <= last_l; ++x)\n\t\t\t  lparen[x] = stk[x];\n\t\t\tstk += x;\n\t\t\tfor (x = 0; x <= last_r; ++x)\n\t\t\t  rparen[x] = stk[x];\n\t\t      }\n\n\t\t    goto while_non_det_options;\n\t\t  }\n\n\t\t  \n\t\tcase OF(rx_cache_miss,cache_miss):\n\t\t  /* Because the superstate NFA is lazily constructed,\n\t\t   * and in fact may erode from underneath us, we sometimes\n\t\t   * have to construct the next instruction from the hard way.\n\t\t   * This invokes one step in the lazy-conversion.\n\t\t   */\n\t\t  ifr = rx_handle_cache_miss (&rxb->rx, super, c, ifr->data_2);\n\t\t  if (!ifr)\n\t\t    {\n\t\t      test_ret = 0;\n\t\t      goto test_do_return;\n\t\t    }\n\t\t  goto restart;\n\t\t  \n\t\tcase OF(rx_backtrack,backtrack):\n\t\t  /* RX_BACKTRACK means that we've reached the empty\n\t\t   * superstate, indicating that match can't succeed\n\t\t   * from this point.\n\t\t   */\n\t\t  goto test_do_return;\n\t\tcase rx_next_char:\n\t\tcase rx_error_inx:\n\t\tcase rx_num_instructions:\n\t\t  ret_val = 0;\n\t\t  goto test_do_return;\n\t\t}\n\t    }\n\t}\n\n\f\n\t/* Healthy exists from the test-match loop do a \n\t * `goto return_from_test_match'   On the other hand, \n\t * we might end up here.\n\t */\n      error_in_testing_match:\n\tret_val = -2;\n\tgoto finish;\n\n\f\n\t/***** fastmap/search loop body\n\t *\t      considering the results testing for a match\n\t */\n\n      return_from_test_match:\n\n\tif (best_last_l >= 0)\n\t  {\n\t    if (regs && (regs->start != best_lparen))\n\t      {\n\t\tbcopy (best_lparen, regs->start,\n\t\t       regs->num_regs * sizeof (int));\n\t\tbcopy (best_rparen, regs->end,\n\t\t       regs->num_regs * sizeof (int));\n\t      }\n\t    if (regs && !rxb->no_sub)\n\t      {\n\t\tint q;\n\t\tint bound = (regs->num_regs > num_regs\n\t\t\t     ? regs->num_regs\n\t\t\t     : num_regs);\n\t\tregoff_t * s = regs->start;\n\t\tregoff_t * e = regs->end;\n\t\tfor (q = best_last_l + 1;  q < bound; ++q)\n\t\t  s[q] = e[q] = -1;\n\t      }\n\t    ret_val = best_lparen[0];\n\t    goto finish;\n\t  }\n\f\n\t/***** fastmap/search loop,  increment and loop-test */\n\n\tpos += search_direction;\n\tstartpos += search_direction;\n\n      } while (startpos < search_end);\n\n\f\n  /**** Exit code for fastmap/searchloop and the entire re_search_2 fn. */\n\n  finish:\n    /* Unset the fastmap sentinel */\n    if (fastmap_chr >= 0)\n      fastmap[fastmap_chr] = fastmap_val;\n\n    if (start_super)\n      rx_unlock_superstate (&rxb->rx, start_super);\n\n#ifdef REGEX_MALLOC\n    if (lparen) free (lparen);\n    if (rparen) free (rparen);\n    if (best_lpspace) free (best_lpspace);\n    if (best_rpspace) free (best_rpspace);\n#endif\n    return ret_val;\n  }\n}\n\n#if !defined(REGEX_MALLOC) && !defined(__GNUC__)\n#ifdef __STDC__\nint\nre_search_2 (struct re_pattern_buffer *rxb,\n\t     const char * string1, int size1,\n\t     const char * string2, int size2,\n\t     int startpos, int range,\n\t     struct re_registers *regs,\n\t     int stop)\n#else\nint\nre_search_2 (rxb, string1, size1, string2, size2, startpos, range, regs, stop)\n     struct re_pattern_buffer *rxb;\n     const char * string1;\n     int size1;\n     const char * string2;\n     int size2;\n     int startpos;\n     int range;\n     struct re_registers *regs;\n     int stop;\n#endif\n{\n  int ret;\n  ret = inner_re_search_2 (rxb, string1, size1, string2, size2, startpos,\n\t\t\t   range, regs, stop);\n  alloca (0);\n  return ret;\n}\n#endif\n\n\n/* Like re_search_2, above, but only one string is specified, and\n * doesn't let you say where to stop matching.\n */\n\n#ifdef __STDC__\nint\nre_search (struct re_pattern_buffer * rxb, const char *string,\n\t   int size, int startpos, int range,\n\t   struct re_registers *regs)\n#else\nint\nre_search (rxb, string, size, startpos, range, regs)\n     struct re_pattern_buffer * rxb;\n     const char * string;\n     int size;\n     int startpos;\n     int range;\n     struct re_registers *regs;\n#endif\n{\n  return re_search_2 (rxb, 0, 0, string, size, startpos, range, regs, size);\n}\n\n#ifdef __STDC__\nint\nre_match_2 (struct re_pattern_buffer * rxb,\n\t    const char * string1, int size1,\n\t    const char * string2, int size2,\n\t    int pos, struct re_registers *regs, int stop)\n#else\nint\nre_match_2 (rxb, string1, size1, string2, size2, pos, regs, stop)\n     struct re_pattern_buffer * rxb;\n     const char * string1;\n     int size1;\n     const char * string2;\n     int size2;\n     int pos;\n     struct re_registers *regs;\n     int stop;\n#endif\n{\n  struct re_registers some_regs;\n  regoff_t start;\n  regoff_t end;\n  int srch;\n  int save = rxb->regs_allocated;\n  struct re_registers * regs_to_pass = regs;\n\n  if (!regs)\n    {\n      some_regs.start = &start;\n      some_regs.end = &end;\n      some_regs.num_regs = 1;\n      regs_to_pass = &some_regs;\n      rxb->regs_allocated = REGS_FIXED;\n    }\n\n  srch = re_search_2 (rxb, string1, size1, string2, size2,\n\t\t      pos, 1, regs_to_pass, stop);\n  if (regs_to_pass != regs)\n    rxb->regs_allocated = save;\n  if (srch < 0)\n    return srch;\n  return regs_to_pass->end[0] - regs_to_pass->start[0];\n}\n\n/* re_match is like re_match_2 except it takes only a single string.  */\n\n#ifdef __STDC__\nint\nre_match (struct re_pattern_buffer * rxb,\n\t  const char * string,\n\t  int size, int pos,\n\t  struct re_registers *regs)\n#else\nint\nre_match (rxb, string, size, pos, regs)\n     struct re_pattern_buffer * rxb;\n     const char *string;\n     int size;\n     int pos;\n     struct re_registers *regs;\n#endif\n{\n  return re_match_2 (rxb, string, size, 0, 0, pos, regs, size);\n}\n\n\n\f\n/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can\n   also be assigned to arbitrarily: each pattern buffer stores its own\n   syntax, so it can be changed between regex compilations.  */\nreg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;\n\n\n/* Specify the precise syntax of regexps for compilation.  This provides\n   for compatibility for various utilities which historically have\n   different, incompatible syntaxes.\n\n   The argument SYNTAX is a bit mask comprised of the various bits\n   defined in regex.h.  We return the old syntax.  */\n\n#ifdef __STDC__\nreg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n#else\nreg_syntax_t\nre_set_syntax (syntax)\n    reg_syntax_t syntax;\n#endif\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}\n\f\n\n/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use\n   this memory for recording register information.  STARTS and ENDS\n   must be allocated using the malloc library routine, and must each\n   be at least NUM_REGS * sizeof (regoff_t) bytes long.\n\n   If NUM_REGS == 0, then subsequent matches should allocate their own\n   register data.\n\n   Unless this function is called, the first search or match using\n   PATTERN_BUFFER will allocate its own register data, without\n   freeing the old data.  */\n\n#ifdef __STDC__\nvoid\nre_set_registers (struct re_pattern_buffer *bufp,\n\t\t  struct re_registers *regs,\n\t\t  unsigned num_regs,\n\t\t  regoff_t * starts, regoff_t * ends)\n#else\nvoid\nre_set_registers (bufp, regs, num_regs, starts, ends)\n     struct re_pattern_buffer *bufp;\n     struct re_registers *regs;\n     unsigned num_regs;\n     regoff_t * starts;\n     regoff_t * ends;\n#endif\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = (regoff_t) 0;\n    }\n}\n\n\n\f\n\n#ifdef __STDC__\nstatic int \ncplx_se_sublist_len (struct rx_se_list * list)\n#else\nstatic int \ncplx_se_sublist_len (list)\n     struct rx_se_list * list;\n#endif\n{\n  int x = 0;\n  while (list)\n    {\n      if ((int)list->car >= 0)\n\t++x;\n      list = list->cdr;\n    }\n  return x;\n}\n\n\n/* For rx->se_list_cmp */\n\n#ifdef __STDC__\nstatic int \nposix_se_list_order (struct rx * rx,\n\t\t     struct rx_se_list * a, struct rx_se_list * b)\n#else\nstatic int \nposix_se_list_order (rx, a, b)\n     struct rx * rx;\n     struct rx_se_list * a;\n     struct rx_se_list * b;\n#endif\n{\n  int al = cplx_se_sublist_len (a);\n  int bl = cplx_se_sublist_len (b);\n\n  if (!al && !bl)\n    return ((a == b)\n\t    ? 0\n\t    : ((a < b) ? -1 : 1));\n  \n  else if (!al)\n    return -1;\n\n  else if (!bl)\n    return 1;\n\n  else\n    {\n      rx_side_effect * av = ((rx_side_effect *)\n\t\t\t     alloca (sizeof (rx_side_effect) * (al + 1)));\n      rx_side_effect * bv = ((rx_side_effect *)\n\t\t\t     alloca (sizeof (rx_side_effect) * (bl + 1)));\n      struct rx_se_list * ap = a;\n      struct rx_se_list * bp = b;\n      int ai, bi;\n      \n      for (ai = al - 1; ai >= 0; --ai)\n\t{\n\t  while ((int)ap->car < 0)\n\t    ap = ap->cdr;\n\t  av[ai] = ap->car;\n\t  ap = ap->cdr;\n\t}\n      av[al] = (rx_side_effect)-2;\n      for (bi = bl - 1; bi >= 0; --bi)\n\t{\n\t  while ((int)bp->car < 0)\n\t    bp = bp->cdr;\n\t  bv[bi] = bp->car;\n\t  bp = bp->cdr;\n\t}\n      bv[bl] = (rx_side_effect)-1;\n\n      {\n\tint ret;\n\tint x = 0;\n\twhile (av[x] == bv[x])\n\t  ++x;\n\tret = ((av[x] < bv[x]) ? -1 : 1);\n\treturn ret;\n      }\n    }\n}\n\n\n\n\f\n/* re_compile_pattern is the GNU regular expression compiler: it\n   compiles PATTERN (of length SIZE) and puts the result in RXB.\n   Returns 0 if the pattern was valid, otherwise an error string.\n\n   Assumes the `allocated' (and perhaps `buffer') and `translate' fields\n   are set in RXB on entry.\n\n   We call rx_compile to do the actual compilation.  */\n\n#ifdef __STDC__\nconst char *\nre_compile_pattern (const char *pattern,\n\t\t    int length,\n\t\t    struct re_pattern_buffer * rxb)\n#else\nconst char *\nre_compile_pattern (pattern, length, rxb)\n     const char *pattern;\n     int length;\n     struct re_pattern_buffer * rxb;\n#endif\n{\n  reg_errcode_t ret;\n\n  /* GNU code is written to assume at least RE_NREGS registers will be set\n     (and at least one extra will be -1).  */\n  rxb->regs_allocated = REGS_UNALLOCATED;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub.  */\n  rxb->no_sub = 0;\n\n  rxb->rx.local_cset_size = 256;\n\n  /* Match anchors at newline.  */\n  rxb->newline_anchor = 1;\n \n  rxb->re_nsub = 0;\n  rxb->start = 0;\n  rxb->se_params = 0;\n  rxb->rx.nodec = 0;\n  rxb->rx.epsnodec = 0;\n  rxb->rx.instruction_table = 0;\n  rxb->rx.nfa_states = 0;\n  rxb->rx.se_list_cmp = posix_se_list_order;\n  rxb->rx.start_set = 0;\n\n  ret = rx_compile (pattern, length, re_syntax_options, rxb);\n  alloca (0);\n  return rx_error_msg[(int) ret];\n}\n\n\n\n#ifdef __STDC__\nint\nre_compile_fastmap (struct re_pattern_buffer * rxb)\n#else\nint\nre_compile_fastmap (rxb)\n     struct re_pattern_buffer * rxb;\n#endif\n{\n  rx_blow_up_fastmap (rxb);\n  return 0;\n}\n\n\n\n\f\n/* Entry points compatible with 4.2 BSD regex library.  We don't define\n   them if this is an Emacs or POSIX compilation.  */\n\n#if !defined (emacs) && !defined (_POSIX_SOURCE) && 0\n\n/* BSD has one and only one pattern buffer.  */\nstatic struct re_pattern_buffer rx_comp_buf;\n\n#ifdef __STDC__\nchar *\nre_comp (const char *s)\n#else\nchar *\nre_comp (s)\n    const char *s;\n#endif\n{\n  reg_errcode_t ret;\n\n  if (!s)\n    {\n      if (!rx_comp_buf.buffer)\n\treturn \"No previous regular expression\";\n      return 0;\n    }\n\n  if (!rx_comp_buf.fastmap)\n    {\n      rx_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);\n      if (!rx_comp_buf.fastmap)\n\treturn \"Memory exhausted\";\n    }\n\n  /* Since `rx_exec' always passes NULL for the `regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  rx_comp_buf.newline_anchor = 1;\n\n  rx_comp_buf.re_nsub = 0;\n  rx_comp_buf.start = 0;\n  rx_comp_buf.se_params = 0;\n  rx_comp_buf.rx.nodec = 0;\n  rx_comp_buf.rx.epsnodec = 0;\n  rx_comp_buf.rx.instruction_table = 0;\n  rx_comp_buf.rx.nfa_states = 0;\n  rx_comp_buf.rx.start = 0;\n  rx_comp_buf.rx.se_list_cmp = posix_se_list_order;\n\n  ret = rx_compile (s, strlen (s), rx_syntax_options, &rx_comp_buf);\n  alloca (0);\n\n  /* Yes, we're discarding `const' here.  */\n  return (char *) rx_error_msg[(int) ret];\n}\n\n\n#ifdef __STDC__\nint\nrx_exec (const char *s)\n#else\nint\nrx_exec (s)\n    const char *s;\n#endif\n{\n  const int len = strlen (s);\n  return\n    0 <= re_search (&rx_comp_buf, s, len, 0, len, (struct rx_registers *) 0);\n}\n#endif /* not emacs and not _POSIX_SOURCE */\n\n\f\n\n/* POSIX.2 functions.  Don't define these for Emacs.  */\n\n#if !defined(emacs)\n\n/* regcomp takes a regular expression as a string and compiles it.\n\n   PREG is a regex_t *.  We do not expect any fields to be initialized,\n   since POSIX says we shouldn't.  Thus, we set\n\n     `buffer' to the compiled pattern;\n     `used' to the length of the compiled pattern;\n     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the\n       REG_EXTENDED bit in CFLAGS is set; otherwise, to\n       RE_SYNTAX_POSIX_BASIC;\n     `newline_anchor' to REG_NEWLINE being set in CFLAGS;\n     `fastmap' and `fastmap_accurate' to zero;\n     `re_nsub' to the number of subexpressions in PATTERN.\n\n   PATTERN is the address of the pattern string.\n\n   CFLAGS is a series of bits which affect compilation.\n\n     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we\n     use POSIX basic syntax.\n\n     If REG_NEWLINE is set, then . and [^...] don't match newline.\n     Also, regexec will try a match beginning after every newline.\n\n     If REG_ICASE is set, then we considers upper- and lowercase\n     versions of letters to be equivalent when matching.\n\n     If REG_NOSUB is set, then when PREG is passed to regexec, that\n     routine will report only success or failure, and nothing about the\n     registers.\n\n   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for\n   the return codes and their meanings.)  */\n\n\n#ifdef __STDC__\nint\nregcomp (regex_t * preg, const char * pattern, int cflags)\n#else\nint\nregcomp (preg, pattern, cflags)\n    regex_t * preg;\n    const char * pattern;\n    int cflags;\n#endif\n{\n  reg_errcode_t ret;\n  unsigned syntax\n    = cflags & REG_EXTENDED ? RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;\n\n  /* regex_compile will allocate the space for the compiled pattern.  */\n  preg->buffer = 0;\n  preg->allocated = 0;\n\n  preg->fastmap = malloc (256);\n  if (!preg->fastmap)\n    return REG_ESPACE;\n  preg->fastmap_accurate = 0;\n\n  if (cflags & REG_ICASE)\n    {\n      unsigned i;\n\n      preg->translate = (char *) malloc (256);\n      if (!preg->translate)\n        return (int) REG_ESPACE;\n\n      /* Map uppercase characters to corresponding lowercase ones.  */\n      for (i = 0; i < CHAR_SET_SIZE; i++)\n        preg->translate[i] = isupper (i) ? tolower (i) : i;\n    }\n  else\n    preg->translate = 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n\n  preg->no_sub = !!(cflags & REG_NOSUB);\n\n  /* POSIX says a null character in the pattern terminates it, so we\n     can use strlen here in compiling the pattern.  */\n  preg->re_nsub = 0;\n  preg->start = 0;\n  preg->se_params = 0;\n  preg->rx.nodec = 0;\n  preg->rx.epsnodec = 0;\n  preg->rx.instruction_table = 0;\n  preg->rx.nfa_states = 0;\n  preg->rx.local_cset_size = 256;\n  preg->rx.start = 0;\n  preg->rx.se_list_cmp = posix_se_list_order;\n  preg->rx.start_set = 0;\n  ret = rx_compile (pattern, strlen (pattern), syntax, preg);\n  alloca (0);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN) ret = REG_EPAREN;\n\n  return (int) ret;\n}\n\n\n/* regexec searches for a given pattern, specified by PREG, in the\n   string STRING.\n\n   If NMATCH is zero or REG_NOSUB was set in the cflags argument to\n   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at\n   least NMATCH elements, and we set them to the offsets of the\n   corresponding matched substrings.\n\n   EFLAGS specifies `execution flags' which affect matching: if\n   REG_NOTBOL is set, then ^ does not match at the beginning of the\n   string; if REG_NOTEOL is set, then $ does not match at the end.\n\n   We return 0 if we find a match and REG_NOMATCH if not.  */\n\n#ifdef __STDC__\nint\nregexec (const regex_t *preg, const char *string,\n\t size_t nmatch, regmatch_t pmatch[],\n\t int eflags)\n#else\nint\nregexec (preg, string, nmatch, pmatch, eflags)\n    const regex_t *preg;\n    const char *string;\n    size_t nmatch;\n    regmatch_t pmatch[];\n    int eflags;\n#endif\n{\n  int ret;\n  struct re_registers regs;\n  regex_t private_preg;\n  int len = strlen (string);\n  boolean want_reg_info = !preg->no_sub && nmatch > 0;\n\n  private_preg = *preg;\n\n  private_preg.not_bol = !!(eflags & REG_NOTBOL);\n  private_preg.not_eol = !!(eflags & REG_NOTEOL);\n\n  /* The user has told us exactly how many registers to return\n   * information about, via `nmatch'.  We have to pass that on to the\n   * matching routines.\n   */\n  private_preg.regs_allocated = REGS_FIXED;\n\n  if (want_reg_info)\n    {\n      regs.num_regs = nmatch;\n      regs.start = TALLOC (nmatch, regoff_t);\n      regs.end = TALLOC (nmatch, regoff_t);\n      if (regs.start == 0 || regs.end == 0)\n        return (int) REG_NOMATCH;\n    }\n\n  /* Perform the searching operation.  */\n  ret = re_search (&private_preg,\n\t\t   string, len,\n                   /* start: */ 0,\n\t\t   /* range: */ len,\n                   want_reg_info ? &regs : (struct re_registers *) 0);\n\n  /* Copy the register information to the POSIX structure.  */\n  if (want_reg_info)\n    {\n      if (ret >= 0)\n        {\n          unsigned r;\n\n          for (r = 0; r < nmatch; r++)\n            {\n              pmatch[r].rm_so = regs.start[r];\n              pmatch[r].rm_eo = regs.end[r];\n            }\n        }\n\n      /* If we needed the temporary register info, free the space now.  */\n      free (regs.start);\n      free (regs.end);\n    }\n\n  /* We want zero return to mean success, unlike `re_search'.  */\n  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;\n}\n\n\n/* Returns a message corresponding to an error code, ERRCODE, returned\n   from either regcomp or regexec.   */\n\n#ifdef __STDC__\nsize_t\nregerror (int errcode, const regex_t *preg,\n\t  char *errbuf, size_t errbuf_size)\n#else\nsize_t\nregerror (errcode, preg, errbuf, errbuf_size)\n    int errcode;\n    const regex_t *preg;\n    char *errbuf;\n    size_t errbuf_size;\n#endif\n{\n  const char *msg\n    = rx_error_msg[errcode] == 0 ? \"Success\" : rx_error_msg[errcode];\n  size_t msg_size = strlen (msg) + 1; /* Includes the 0.  */\n\n  if (errbuf_size != 0)\n    {\n      if (msg_size > errbuf_size)\n        {\n          strncpy (errbuf, msg, errbuf_size - 1);\n          errbuf[errbuf_size - 1] = 0;\n        }\n      else\n        strcpy (errbuf, msg);\n    }\n\n  return msg_size;\n}\n\n\n/* Free dynamically allocated space used by PREG.  */\n\n#ifdef __STDC__\nvoid\nregfree (regex_t *preg)\n#else\nvoid\nregfree (preg)\n    regex_t *preg;\n#endif\n{\n  if (preg->buffer != 0)\n    free (preg->buffer);\n  preg->buffer = 0;\n  preg->allocated = 0;\n\n  if (preg->fastmap != 0)\n    free (preg->fastmap);\n  preg->fastmap = 0;\n  preg->fastmap_accurate = 0;\n\n   if (preg->translate != 0)\n    free (preg->translate);\n  preg->translate = 0;\n}\n\n#endif /* not emacs  */\n\n\n\n\n\n/* Getopt for GNU.\n   NOTE: getopt is now part of the C library, so if you don't know what\n   \"Keep this file name-space clean\" means, talk to roland@gnu.ai.mit.edu\n   before changing it!\n\n   Copyright (C) 1987, 1988, 1989, 1990, 1991, 1992, 1993\n   \tFree Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\f\n/* NOTE!!!  AIX requires this to be the first thing in the file.\n   Do not put ANYTHING before it!  */\n#if !defined (__GNUC__) && defined (_AIX)\n #pragma alloca\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef __GNUC__\n#ifndef alloca\n#define alloca __builtin_alloca\n#endif /* not alloca */\n#else /* not __GNUC__ */\n#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))\n#include <alloca.h>\n#else\n#ifndef _AIX\nchar *alloca ();\n#endif\n#endif /* alloca.h */\n#endif /* not __GNUC__ */\n\n#if !__STDC__ && !defined(const) && IN_GCC\n#define const\n#endif\n\n/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */\n#ifndef _NO_PROTO\n#define _NO_PROTO\n#endif\n\n#include <stdio.h>\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#if defined (_LIBC) || !defined (__GNU_LIBRARY__)\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef\t__GNU_LIBRARY__\n#undef\talloca\n/* Don't include stdlib.h for non-GNU C libraries because some of them\n   contain conflicting prototypes for getopt.  */\n#include <stdlib.h>\n#else\t/* Not GNU C library.  */\n#define\t__alloca\talloca\n#endif\t/* GNU C library.  */\n\n/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a\n   long-named option.  Because this is not POSIX.2 compliant, it is\n   being phased out.  */\n/* #define GETOPT_COMPAT */\n\n/* This version of `getopt' appears to the caller like standard Unix `getopt'\n   but it behaves differently for the user, since it allows the user\n   to intersperse the options with the other arguments.\n\n   As `getopt' works, it permutes the elements of ARGV so that,\n   when it is done, all the options precede everything else.  Thus\n   all application programs are extended to handle flexible argument order.\n\n   Setting the environment variable POSIXLY_CORRECT disables permutation.\n   Then the behavior is completely standard.\n\n   GNU application programs can use a third alternative mode in which\n   they can distinguish the relative order of options and other arguments.  */\n\n#include \"getopt.h\"\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nchar *optarg = 0;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns EOF, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\n/* XXX 1003.2 says this must be 1 before any call.  */\nint optind = 0;\n\n/* The next char to be scanned in the option-element\n   in which the last option character we returned was found.\n   This allows us to pick up the scan where we left off.\n\n   If this is zero, or a null string, it means resume the scan\n   by advancing to the next ARGV-element.  */\n\nstatic char *nextchar;\n\n/* Callers store zero here to inhibit the error message\n   for unrecognized options.  */\n\nint opterr = 1;\n\n/* Set to an option character which was unrecognized.\n   This must be initialized on some systems to avoid linking in the\n   system's own getopt implementation.  */\n\nint optopt = '?';\n\n/* Describe how to deal with options that follow non-option ARGV-elements.\n\n   If the caller did not specify anything,\n   the default is REQUIRE_ORDER if the environment variable\n   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n\n   REQUIRE_ORDER means don't recognize them as options;\n   stop option processing when the first non-option is seen.\n   This is what Unix does.\n   This mode of operation is selected by either setting the environment\n   variable POSIXLY_CORRECT, or using `+' as the first character\n   of the list of option characters.\n\n   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n   so that eventually all the non-options are at the end.  This allows options\n   to be given in any order, even with programs that were not written to\n   expect this.\n\n   RETURN_IN_ORDER is an option available to programs that were written\n   to expect options and other ARGV-elements in any order and that care about\n   the ordering of the two.  We describe each non-option ARGV-element\n   as if it were the argument of an option with character code 1.\n   Using `-' as the first character of the list of option characters\n   selects this mode of operation.\n\n   The special argument `--' forces an end of option-scanning regardless\n   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */\n\nstatic enum\n{\n  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n} ordering;\n\f\n#ifdef\t__GNU_LIBRARY__\n/* We want to avoid inclusion of string.h with non-GNU libraries\n   because there are many ways it can cause trouble.\n   On some systems, it contains special magic macros that don't work\n   in GCC.  */\n#include <string.h>\n#define\tmy_index\tstrchr\n#define\tmy_bcopy(src, dst, n)\tmemcpy ((dst), (src), (n))\n#else\n\n/* Avoid depending on library functions or files\n   whose names are inconsistent.  */\n\nchar *getenv ();\n\nstatic char *\nmy_index (str, chr)\n     const char *str;\n     int chr;\n{\n  while (*str)\n    {\n      if (*str == chr)\n\treturn (char *) str;\n      str++;\n    }\n  return 0;\n}\n\nstatic void\nmy_bcopy (from, to, size)\n     const char *from;\n     char *to;\n     int size;\n{\n  int i;\n  for (i = 0; i < size; i++)\n    to[i] = from[i];\n}\n#endif\t\t\t\t/* GNU C library.  */\n\f\n/* Handle permutation of arguments.  */\n\n/* Describe the part of ARGV that contains non-options that have\n   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n   `last_nonopt' is the index after the last of them.  */\n\nstatic int first_nonopt;\nstatic int last_nonopt;\n\n/* Exchange two adjacent subsequences of ARGV.\n   One subsequence is elements [first_nonopt,last_nonopt)\n   which contains all the non-options that have been skipped so far.\n   The other is elements [last_nonopt,optind), which contains all\n   the options processed since those non-options were skipped.\n\n   `first_nonopt' and `last_nonopt' are relocated so that they describe\n   the new indices of the non-options in ARGV after they are moved.  */\n\nstatic void\nexchange (argv)\n     char **argv;\n{\n  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);\n  char **temp = (char **) __alloca (nonopts_size);\n\n  /* Interchange the two blocks of data in ARGV.  */\n\n  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);\n  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],\n\t    (optind - last_nonopt) * sizeof (char *));\n  my_bcopy ((char *) temp,\n\t    (char *) &argv[first_nonopt + optind - last_nonopt],\n\t    nonopts_size);\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  first_nonopt += (optind - last_nonopt);\n  last_nonopt = optind;\n}\n\f\n/* Scan elements of ARGV (whose length is ARGC) for option characters\n   given in OPTSTRING.\n\n   If an element of ARGV starts with '-', and is not exactly \"-\" or \"--\",\n   then it is an option element.  The characters of this element\n   (aside from the initial '-') are option characters.  If `getopt'\n   is called repeatedly, it returns successively each of the option characters\n   from each of the option elements.\n\n   If `getopt' finds another option character, it returns that character,\n   updating `optind' and `nextchar' so that the next call to `getopt' can\n   resume the scan with the following option character or ARGV-element.\n\n   If there are no more option characters, `getopt' returns `EOF'.\n   Then `optind' is the index in ARGV of the first ARGV-element\n   that is not an option.  (The ARGV-elements have been permuted\n   so that those that are not options now come last.)\n\n   OPTSTRING is a string containing the legitimate option characters.\n   If an option character is seen that is not listed in OPTSTRING,\n   return '?' after printing an error message.  If you set `opterr' to\n   zero, the error message is suppressed but we still return '?'.\n\n   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n   so the following text in the same ARGV-element, or the text of the following\n   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n   wants an optional arg; if there is text in the current ARGV-element,\n   it is returned in `optarg', otherwise `optarg' is set to zero.\n\n   If OPTSTRING starts with `-' or `+', it requests different methods of\n   handling the non-option ARGV-elements.\n   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n\n   Long-named options begin with `--' instead of `-'.\n   Their names may be abbreviated as long as the abbreviation is unique\n   or is an exact match for some defined option.  If they have an\n   argument, it follows the option name in the same ARGV-element, separated\n   from the option name by a `=', or else the in next ARGV-element.\n   When `getopt' finds a long-named option, it returns 0 if that option's\n   `flag' field is nonzero, the value of the option's `val' field\n   if the `flag' field is zero.\n\n   The elements of ARGV aren't really const, because we permute them.\n   But we pretend they're const in the prototype to be compatible\n   with other systems.\n\n   LONGOPTS is a vector of `struct option' terminated by an\n   element containing a name which is zero.\n\n   LONGIND returns the index in LONGOPT of the long-named option found.\n   It is only valid when a long-named option has been found by the most\n   recent call.\n\n   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n   long-named options.  */\n\nint\n_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n     const struct option *longopts;\n     int *longind;\n     int long_only;\n{\n  int option_index;\n\n  optarg = 0;\n\n  /* Initialize the internal data when the first call is made.\n     Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  if (optind == 0)\n    {\n      first_nonopt = last_nonopt = optind = 1;\n\n      nextchar = NULL;\n\n      /* Determine how to handle the ordering of options and nonoptions.  */\n\n      if (optstring[0] == '-')\n\t{\n\t  ordering = RETURN_IN_ORDER;\n\t  ++optstring;\n\t}\n      else if (optstring[0] == '+')\n\t{\n\t  ordering = REQUIRE_ORDER;\n\t  ++optstring;\n\t}\n      else if (getenv (\"POSIXLY_CORRECT\") != NULL)\n\tordering = REQUIRE_ORDER;\n      else\n\tordering = PERMUTE;\n    }\n\n  if (nextchar == NULL || *nextchar == '\\0')\n    {\n      if (ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (last_nonopt != optind)\n\t    first_nonopt = optind;\n\n\t  /* Now skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (optind < argc\n\t\t && (argv[optind][0] != '-' || argv[optind][1] == '\\0')\n#ifdef GETOPT_COMPAT\n\t\t && (longopts == NULL\n\t\t     || argv[optind][0] != '+' || argv[optind][1] == '\\0')\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t\t )\n\t    optind++;\n\t  last_nonopt = optind;\n\t}\n\n      /* Special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv[optind], \"--\"))\n\t{\n\t  optind++;\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (first_nonopt == last_nonopt)\n\t    first_nonopt = optind;\n\t  last_nonopt = argc;\n\n\t  optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (first_nonopt != last_nonopt)\n\t    optind = first_nonopt;\n\t  return EOF;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if ((argv[optind][0] != '-' || argv[optind][1] == '\\0')\n#ifdef GETOPT_COMPAT\n\t  && (longopts == NULL\n\t      || argv[optind][0] != '+' || argv[optind][1] == '\\0')\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  )\n\t{\n\t  if (ordering == REQUIRE_ORDER)\n\t    return EOF;\n\t  optarg = argv[optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Start decoding its characters.  */\n\n      nextchar = (argv[optind] + 1\n\t\t  + (longopts != NULL && argv[optind][1] == '-'));\n    }\n\n  if (longopts != NULL\n      && ((argv[optind][0] == '-'\n\t   && (argv[optind][1] == '-' || long_only))\n#ifdef GETOPT_COMPAT\n\t  || argv[optind][0] == '+'\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  ))\n    {\n      const struct option *p;\n      char *s = nextchar;\n      int exact = 0;\n      int ambig = 0;\n      const struct option *pfound = NULL;\n      int indfound;\n\n      while (*s && *s != '=')\n\ts++;\n\n      /* Test all options for either exact match or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name;\n\t   p++, option_index++)\n\tif (!strncmp (p->name, nextchar, s - nextchar))\n\t  {\n\t    if (s - nextchar == strlen (p->name))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else\n\t      /* Second nonexact match found.  */\n\t      ambig = 1;\n\t  }\n\n      if (ambig && !exact)\n\t{\n\t  if (opterr)\n\t    fprintf (stderr, \"%s: option `%s' is ambiguous\\n\",\n\t\t     myname, argv[optind]);\n\t  nextchar += strlen (nextchar);\n\t  optind++;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  optind++;\n\t  if (*s)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\toptarg = s + 1;\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    {\n\t\t      if (argv[optind - 1][1] == '-')\n\t\t\t/* --option */\n\t\t\tfprintf (stderr,\n\t\t\t\t \"%s: option `--%s' doesn't allow an argument\\n\",\n\t\t\t\t myname, pfound->name);\n\t\t      else\n\t\t\t/* +option or -option */\n\t\t\tfprintf (stderr,\n\t\t\t     \"%s: option `%c%s' doesn't allow an argument\\n\",\n\t\t\t     myname, argv[optind - 1][0], pfound->name);\n\t\t    }\n\t\t  nextchar += strlen (nextchar);\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (optind < argc)\n\t\toptarg = argv[optind++];\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    fprintf (stderr, \"%s: option `%s' requires an argument\\n\",\n\t\t\t     myname, argv[optind - 1]);\n\t\t  nextchar += strlen (nextchar);\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  nextchar += strlen (nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[optind][1] == '-'\n#ifdef GETOPT_COMPAT\n\t  || argv[optind][0] == '+'\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  || my_index (optstring, *nextchar) == NULL)\n\t{\n\t  if (opterr)\n\t    {\n\t      if (argv[optind][1] == '-')\n\t\t/* --option */\n\t\tfprintf (stderr, \"%s: unrecognized option `--%s'\\n\",\n\t\t\t myname, nextchar);\n\t      else\n\t\t/* +option or -option */\n\t\tfprintf (stderr, \"%s: unrecognized option `%c%s'\\n\",\n\t\t\t myname, argv[optind][0], nextchar);\n\t    }\n\t  nextchar = (char *) \"\";\n\t  optind++;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = my_index (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n\tif (opterr)\n\t  {\n#if 0\n\t    if (c < 040 || c >= 0177)\n\t      fprintf (stderr, \"%s: unrecognized option, character code 0%o\\n\",\n\t\t       myname, c);\n\t    else\n\t      fprintf (stderr, \"%s: unrecognized option `-%c'\\n\", myname, c);\n#else\n\t    /* 1003.2 specifies the format of this message.  */\n\t    fprintf (stderr, \"%s: illegal option -- %c\\n\", myname, c);\n#endif\n\t  }\n\toptopt = c;\n\treturn '?';\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\toptind++;\n\t      }\n\t    else\n\t      optarg = 0;\n\t    nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\toptind++;\n\t      }\n\t    else if (optind == argc)\n\t      {\n\t\tif (opterr)\n\t\t  {\n#if 0\n\t\t    fprintf (stderr, \"%s: option `-%c' requires an argument\\n\",\n\t\t\t     myname, c);\n#else\n\t\t    /* 1003.2 specifies the format of this message.  */\n\t\t    fprintf (stderr, \"%s: option requires an argument -- %c\\n\",\n\t\t\t     myname, c);\n#endif\n\t\t  }\n\t\toptopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      optarg = argv[optind++];\n\t    nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}\n\nint\ngetopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0);\n}\n\n#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n\f\n#ifdef TEST\n\n/* Compile with -DTEST to make an executable for use in testing\n   the above definition of `getopt'.  */\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == EOF)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}\n\n#endif /* TEST */\n/* getopt_long and getopt_long_only entry points for GNU getopt.\n   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993\n\tFree Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\f\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"getopt.h\"\n\n#if !__STDC__ && !defined(const) && IN_GCC\n#define const\n#endif\n\n#include <stdio.h>\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#if defined (_LIBC) || !defined (__GNU_LIBRARY__)\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef __GNU_LIBRARY__\n#include <stdlib.h>\n#else\nchar *getenv ();\n#endif\n\n#ifndef\tNULL\n#define NULL 0\n#endif\n\nint\ngetopt_long (argc, argv, options, long_options, opt_index)\n     int argc;\n     char *const *argv;\n     const char *options;\n     const struct option *long_options;\n     int *opt_index;\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);\n}\n\n/* Like getopt_long, but '-' as well as '--' can indicate a long option.\n   If an option that starts with '-' (not '--') doesn't match a long option,\n   but does match a short option, it is parsed as a short option\n   instead.  */\n\nint\ngetopt_long_only (argc, argv, options, long_options, opt_index)\n     int argc;\n     char *const *argv;\n     const char *options;\n     const struct option *long_options;\n     int *opt_index;\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);\n}\n\n\n#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n\f\n#ifdef TEST\n\n#include <stdio.h>\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == EOF)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}\n\n#endif /* TEST */\n"}}, "framework": {"brandingInformation": {"homepageUrl": "https://github.com/mull-project/mull"}, "name": "Mull", "version": "0.17.1, LLVM 12.0.0"}, "mutationScore": 100, "schemaVersion": "1.7", "thresholds": {"high": 80, "low": 60}}