{"config": {"Build Date": "20 Jan 2022", "Commit": "ab159cd", "LLVM Version": "12.0.0", "Mull Version": "0.15.0", "URL": "https://github.com/mull-project/mull"}, "files": {"/__w/mutation-lab-class-2/mutation-lab-class-2/programs/grep/v0/grep.c": {"language": "cpp", "mutants": [{"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 246}, "start": {"column": 20, "line": 246}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 250}, "start": {"column": 32, "line": 250}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 28, "line": 258}, "start": {"column": 27, "line": 258}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 28, "line": 258}, "start": {"column": 27, "line": 258}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 283}, "start": {"column": 16, "line": 283}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 53, "line": 283}, "start": {"column": 51, "line": 283}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 286}, "start": {"column": 12, "line": 286}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 286}, "start": {"column": 12, "line": 286}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 288}, "start": {"column": 19, "line": 288}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 288}, "start": {"column": 19, "line": 288}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 290}, "start": {"column": 20, "line": 290}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 34, "line": 291}, "start": {"column": 33, "line": 291}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 298}, "start": {"column": 15, "line": 298}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 299}, "start": {"column": 28, "line": 299}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 310}, "start": {"column": 30, "line": 310}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 310}, "start": {"column": 41, "line": 310}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 311}, "start": {"column": 26, "line": 311}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 40, "line": 311}, "start": {"column": 38, "line": 311}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 40, "line": 311}, "start": {"column": 38, "line": 311}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 51, "line": 311}, "start": {"column": 50, "line": 311}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 314}, "start": {"column": 36, "line": 314}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 316}, "start": {"column": 17, "line": 316}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 22, "line": 328}, "start": {"column": 21, "line": 328}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 56, "line": 342}, "start": {"column": 55, "line": 342}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 11, "line": 347}, "start": {"column": 10, "line": 347}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 11, "line": 347}, "start": {"column": 10, "line": 347}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 27, "line": 378}, "start": {"column": 26, "line": 378}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 27, "line": 378}, "start": {"column": 26, "line": 378}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 379}, "start": {"column": 14, "line": 379}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 380}, "start": {"column": 7, "line": 380}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 395}, "start": {"column": 22, "line": 395}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 399}, "start": {"column": 29, "line": 399}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 399}, "start": {"column": 36, "line": 399}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 400}, "start": {"column": 22, "line": 400}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 415}, "start": {"column": 18, "line": 415}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 415}, "start": {"column": 18, "line": 415}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 415}, "start": {"column": 33, "line": 415}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 415}, "start": {"column": 33, "line": 415}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 418}, "start": {"column": 43, "line": 418}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 57, "line": 418}, "start": {"column": 55, "line": 418}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 30, "line": 438}, "start": {"column": 29, "line": 438}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 30, "line": 438}, "start": {"column": 29, "line": 438}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 448}, "start": {"column": 21, "line": 448}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 448}, "start": {"column": 21, "line": 448}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 448}, "start": {"column": 35, "line": 448}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 9, "line": 449}, "start": {"column": 8, "line": 449}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 9, "line": 449}, "start": {"column": 8, "line": 449}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 452}, "start": {"column": 13, "line": 452}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 452}, "start": {"column": 13, "line": 452}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 452}, "start": {"column": 27, "line": 452}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 52, "line": 456}, "start": {"column": 50, "line": 456}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 459}, "start": {"column": 16, "line": 459}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 459}, "start": {"column": 16, "line": 459}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 461}, "start": {"column": 29, "line": 461}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 470}, "start": {"column": 21, "line": 470}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 470}, "start": {"column": 21, "line": 470}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 470}, "start": {"column": 28, "line": 470}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 35, "line": 472}, "start": {"column": 34, "line": 472}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 42, "line": 472}, "start": {"column": 40, "line": 472}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 34, "line": 504}, "start": {"column": 33, "line": 504}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 48, "line": 504}, "start": {"column": 46, "line": 504}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 507}, "start": {"column": 13, "line": 507}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 28, "line": 507}, "start": {"column": 27, "line": 507}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 28, "line": 507}, "start": {"column": 27, "line": 507}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 507}, "start": {"column": 42, "line": 507}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 58, "line": 507}, "start": {"column": 56, "line": 507}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 514}, "start": {"column": 18, "line": 514}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 514}, "start": {"column": 18, "line": 514}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 24, "line": 521}, "start": {"column": 23, "line": 521}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 24, "line": 521}, "start": {"column": 23, "line": 521}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 551}, "start": {"column": 25, "line": 551}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 551}, "start": {"column": 25, "line": 551}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 559}, "start": {"column": 18, "line": 559}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 559}, "start": {"column": 27, "line": 559}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 561}, "start": {"column": 27, "line": 561}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 31, "line": 562}, "start": {"column": 30, "line": 562}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 31, "line": 562}, "start": {"column": 30, "line": 562}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 49, "line": 562}, "start": {"column": 47, "line": 562}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 564}, "start": {"column": 24, "line": 564}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 565}, "start": {"column": 15, "line": 565}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 565}, "start": {"column": 15, "line": 565}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 573}, "start": {"column": 16, "line": 573}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 573}, "start": {"column": 16, "line": 573}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 37, "line": 573}, "start": {"column": 36, "line": 573}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 37, "line": 573}, "start": {"column": 36, "line": 573}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 54, "line": 573}, "start": {"column": 52, "line": 573}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 7, "line": 575}, "start": {"column": 4, "line": 575}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 578}, "start": {"column": 15, "line": 578}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 578}, "start": {"column": 15, "line": 578}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 578}, "start": {"column": 35, "line": 578}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 580}, "start": {"column": 15, "line": 580}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 582}, "start": {"column": 28, "line": 582}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 583}, "start": {"column": 25, "line": 583}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 35, "line": 583}, "start": {"column": 34, "line": 583}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 589}, "start": {"column": 39, "line": 589}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 616}, "start": {"column": 33, "line": 616}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 617}, "start": {"column": 40, "line": 617}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 5, "line": 655}, "start": {"column": 3, "line": 655}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 668}, "start": {"column": 18, "line": 668}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 32, "line": 668}, "start": {"column": 31, "line": 668}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 668}, "start": {"column": 37, "line": 668}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 669}, "start": {"column": 17, "line": 669}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 669}, "start": {"column": 29, "line": 669}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 669}, "start": {"column": 35, "line": 669}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 673}, "start": {"column": 16, "line": 673}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 673}, "start": {"column": 16, "line": 673}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 678}, "start": {"column": 17, "line": 678}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 678}, "start": {"column": 17, "line": 678}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 44, "line": 685}, "start": {"column": 42, "line": 685}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 44, "line": 690}, "start": {"column": 42, "line": 690}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 695}, "start": {"column": 41, "line": 695}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 31, "line": 716}, "start": {"column": 30, "line": 716}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 36, "line": 716}, "start": {"column": 35, "line": 716}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 718}, "start": {"column": 14, "line": 718}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 724}, "start": {"column": 27, "line": 724}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 32, "line": 727}, "start": {"column": 30, "line": 727}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 32, "line": 727}, "start": {"column": 30, "line": 727}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 732}, "start": {"column": 14, "line": 732}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 51, "line": 734}, "start": {"column": 50, "line": 734}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 65, "line": 734}, "start": {"column": 64, "line": 734}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 65, "line": 734}, "start": {"column": 64, "line": 734}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 737}, "start": {"column": 16, "line": 737}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 11, "line": 740}, "start": {"column": 9, "line": 740}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 13, "line": 743}, "start": {"column": 12, "line": 743}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 743}, "start": {"column": 20, "line": 743}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 743}, "start": {"column": 20, "line": 743}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 39, "line": 743}, "start": {"column": 38, "line": 743}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 743}, "start": {"column": 43, "line": 743}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 788}, "start": {"column": 16, "line": 788}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 788}, "start": {"column": 16, "line": 788}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 22, "line": 790}, "start": {"column": 20, "line": 790}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 13, "line": 804}, "start": {"column": 12, "line": 804}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 22, "line": 804}, "start": {"column": 21, "line": 804}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 22, "line": 804}, "start": {"column": 21, "line": 804}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 809}, "start": {"column": 14, "line": 809}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 809}, "start": {"column": 14, "line": 809}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 810}, "start": {"column": 19, "line": 810}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 810}, "start": {"column": 19, "line": 810}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 813}, "start": {"column": 11, "line": 813}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 813}, "start": {"column": 11, "line": 813}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 820}, "start": {"column": 22, "line": 820}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 831}, "start": {"column": 18, "line": 831}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 834}, "start": {"column": 26, "line": 834}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 837}, "start": {"column": 11, "line": 837}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 839}, "start": {"column": 2, "line": 839}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 850}, "start": {"column": 19, "line": 850}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 853}, "start": {"column": 27, "line": 853}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 1716}, "start": {"column": 20, "line": 1716}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 1716}, "start": {"column": 20, "line": 1716}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 1716}, "start": {"column": 29, "line": 1716}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 1719}, "start": {"column": 20, "line": 1719}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 1719}, "start": {"column": 20, "line": 1719}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 1719}, "start": {"column": 29, "line": 1719}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 1722}, "start": {"column": 20, "line": 1722}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 1722}, "start": {"column": 20, "line": 1722}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 31, "line": 1722}, "start": {"column": 29, "line": 1722}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 2781}, "start": {"column": 27, "line": 2781}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 2805}, "start": {"column": 23, "line": 2805}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 14, "line": 2825}, "start": {"column": 12, "line": 2825}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 2834}, "start": {"column": 22, "line": 2834}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 2849}, "start": {"column": 22, "line": 2849}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 2891}, "start": {"column": 36, "line": 2891}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 38, "line": 2892}, "start": {"column": 36, "line": 2892}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 2894}, "start": {"column": 23, "line": 2894}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 2899}, "start": {"column": 23, "line": 2899}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 59, "line": 2900}, "start": {"column": 57, "line": 2900}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 71, "line": 2900}, "start": {"column": 69, "line": 2900}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 58, "line": 2903}, "start": {"column": 56, "line": 2903}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 2905}, "start": {"column": 27, "line": 2905}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 2908}, "start": {"column": 30, "line": 2908}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 2908}, "start": {"column": 43, "line": 2908}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 2954}, "start": {"column": 42, "line": 2954}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 27, "line": 2956}, "start": {"column": 26, "line": 2956}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 27, "line": 2956}, "start": {"column": 26, "line": 2956}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 53, "line": 2956}, "start": {"column": 51, "line": 2956}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 3004}, "start": {"column": 19, "line": 3004}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 3015}, "start": {"column": 20, "line": 3015}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 39, "line": 3028}, "start": {"column": 37, "line": 3028}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 3035}, "start": {"column": 23, "line": 3035}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 68, "line": 3040}, "start": {"column": 66, "line": 3040}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 3042}, "start": {"column": 27, "line": 3042}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 3052}, "start": {"column": 23, "line": 3052}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 3052}, "start": {"column": 35, "line": 3052}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 3057}, "start": {"column": 41, "line": 3057}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 56, "line": 3057}, "start": {"column": 54, "line": 3057}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 3064}, "start": {"column": 23, "line": 3064}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 34, "line": 3065}, "start": {"column": 32, "line": 3065}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 34, "line": 3065}, "start": {"column": 32, "line": 3065}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 3065}, "start": {"column": 52, "line": 3065}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 34, "line": 3066}, "start": {"column": 32, "line": 3066}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 34, "line": 3066}, "start": {"column": 32, "line": 3066}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 3066}, "start": {"column": 52, "line": 3066}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 70, "line": 3066}, "start": {"column": 68, "line": 3066}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 3067}, "start": {"column": 27, "line": 3067}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 3071}, "start": {"column": 29, "line": 3071}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 3074}, "start": {"column": 31, "line": 3074}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 48, "line": 3074}, "start": {"column": 46, "line": 3074}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 3082}, "start": {"column": 29, "line": 3082}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 58, "line": 3088}, "start": {"column": 56, "line": 3088}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 71, "line": 3088}, "start": {"column": 69, "line": 3088}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 3096}, "start": {"column": 27, "line": 3096}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 3101}, "start": {"column": 31, "line": 3101}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 3101}, "start": {"column": 43, "line": 3101}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 57, "line": 3101}, "start": {"column": 55, "line": 3101}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 3102}, "start": {"column": 35, "line": 3102}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 33, "line": 3104}, "start": {"column": 31, "line": 3104}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 3111}, "start": {"column": 27, "line": 3111}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 3111}, "start": {"column": 40, "line": 3111}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 3133}, "start": {"column": 31, "line": 3133}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 42, "line": 3135}, "start": {"column": 41, "line": 3135}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 42, "line": 3135}, "start": {"column": 41, "line": 3135}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 63, "line": 3135}, "start": {"column": 61, "line": 3135}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 3155}, "start": {"column": 27, "line": 3155}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 33, "line": 3172}, "start": {"column": 32, "line": 3172}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 33, "line": 3172}, "start": {"column": 32, "line": 3172}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 48, "line": 3172}, "start": {"column": 47, "line": 3172}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 3172}, "start": {"column": 52, "line": 3172}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 3215}, "start": {"column": 17, "line": 3215}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 30, "line": 3229}, "start": {"column": 28, "line": 3229}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 23, "line": 3230}, "start": {"column": 21, "line": 3230}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 3236}, "start": {"column": 43, "line": 3236}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 57, "line": 3245}, "start": {"column": 56, "line": 3245}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 52, "line": 3247}, "start": {"column": 51, "line": 3247}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 67, "line": 3247}, "start": {"column": 66, "line": 3247}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 55, "line": 3248}, "start": {"column": 54, "line": 3248}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 28, "line": 3255}, "start": {"column": 26, "line": 3255}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 28, "line": 3255}, "start": {"column": 26, "line": 3255}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 61, "line": 3257}, "start": {"column": 60, "line": 3257}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 76, "line": 3257}, "start": {"column": 75, "line": 3257}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 36, "line": 3261}, "start": {"column": 34, "line": 3261}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 41, "line": 3326}, "start": {"column": 39, "line": 3326}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 41, "line": 3326}, "start": {"column": 39, "line": 3326}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 48, "line": 3331}, "start": {"column": 47, "line": 3331}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 3390}, "start": {"column": 29, "line": 3390}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 3390}, "start": {"column": 47, "line": 3390}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 3402}, "start": {"column": 23, "line": 3402}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 3412}, "start": {"column": 23, "line": 3412}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 38, "line": 3415}, "start": {"column": 37, "line": 3415}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 38, "line": 3415}, "start": {"column": 37, "line": 3415}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 3421}, "start": {"column": 33, "line": 3421}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 3421}, "start": {"column": 33, "line": 3421}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 53, "line": 3421}, "start": {"column": 52, "line": 3421}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 53, "line": 3421}, "start": {"column": 52, "line": 3421}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 37, "line": 3422}, "start": {"column": 36, "line": 3422}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 37, "line": 3422}, "start": {"column": 36, "line": 3422}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 3432}, "start": {"column": 27, "line": 3432}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 3437}, "start": {"column": 23, "line": 3437}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 3461}, "start": {"column": 34, "line": 3461}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 44, "line": 3480}, "start": {"column": 43, "line": 3480}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 59, "line": 3480}, "start": {"column": 58, "line": 3480}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 59, "line": 3480}, "start": {"column": 58, "line": 3480}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 64, "line": 3480}, "start": {"column": 63, "line": 3480}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 39, "line": 3501}, "start": {"column": 38, "line": 3501}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 39, "line": 3501}, "start": {"column": 38, "line": 3501}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 67, "line": 3527}, "start": {"column": 66, "line": 3527}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 51, "line": 3528}, "start": {"column": 50, "line": 3528}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 27, "line": 3548}, "start": {"column": 26, "line": 3548}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 27, "line": 3548}, "start": {"column": 26, "line": 3548}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 3548}, "start": {"column": 47, "line": 3548}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 3615}, "start": {"column": 22, "line": 3615}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 3617}, "start": {"column": 22, "line": 3617}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 3617}, "start": {"column": 22, "line": 3617}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 55, "line": 3654}, "start": {"column": 53, "line": 3654}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 3657}, "start": {"column": 26, "line": 3657}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 3660}, "start": {"column": 21, "line": 3660}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 3660}, "start": {"column": 34, "line": 3660}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 3662}, "start": {"column": 10, "line": 3662}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 3662}, "start": {"column": 27, "line": 3662}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 3662}, "start": {"column": 42, "line": 3662}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 3663}, "start": {"column": 11, "line": 3663}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 3663}, "start": {"column": 24, "line": 3663}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 3666}, "start": {"column": 14, "line": 3666}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 3667}, "start": {"column": 31, "line": 3667}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 3667}, "start": {"column": 47, "line": 3667}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 29, "line": 3678}, "start": {"column": 27, "line": 3678}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 3695}, "start": {"column": 18, "line": 3695}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 3750}, "start": {"column": 16, "line": 3750}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 3769}, "start": {"column": 16, "line": 3769}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 39, "line": 3786}, "start": {"column": 38, "line": 3786}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 39, "line": 3786}, "start": {"column": 38, "line": 3786}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 62, "line": 3786}, "start": {"column": 60, "line": 3786}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 3790}, "start": {"column": 15, "line": 3790}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 3792}, "start": {"column": 15, "line": 3792}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 3805}, "start": {"column": 34, "line": 3805}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 3806}, "start": {"column": 33, "line": 3806}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 3806}, "start": {"column": 33, "line": 3806}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 3810}, "start": {"column": 42, "line": 3810}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 3811}, "start": {"column": 53, "line": 3811}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 3813}, "start": {"column": 40, "line": 3813}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 3814}, "start": {"column": 53, "line": 3814}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 3828}, "start": {"column": 43, "line": 3828}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 23, "line": 3829}, "start": {"column": 21, "line": 3829}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 23, "line": 3829}, "start": {"column": 21, "line": 3829}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 3831}, "start": {"column": 50, "line": 3831}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 3861}, "start": {"column": 9, "line": 3861}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 3879}, "start": {"column": 19, "line": 3879}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 3879}, "start": {"column": 19, "line": 3879}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 45, "line": 3886}, "start": {"column": 43, "line": 3886}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 45, "line": 3886}, "start": {"column": 43, "line": 3886}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 68, "line": 3886}, "start": {"column": 66, "line": 3886}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 14, "line": 4215}, "start": {"column": 12, "line": 4215}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 4217}, "start": {"column": 13, "line": 4217}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 26, "line": 4256}, "start": {"column": 25, "line": 4256}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 4256}, "start": {"column": 37, "line": 4256}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 46, "line": 4256}, "start": {"column": 44, "line": 4256}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 46, "line": 4256}, "start": {"column": 44, "line": 4256}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 15, "line": 4257}, "start": {"column": 14, "line": 4257}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 39, "line": 4257}, "start": {"column": 38, "line": 4257}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 17, "line": 4264}, "start": {"column": 16, "line": 4264}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 32, "line": 4264}, "start": {"column": 31, "line": 4264}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 32, "line": 4264}, "start": {"column": 31, "line": 4264}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 54, "line": 4264}, "start": {"column": 52, "line": 4264}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 4267}, "start": {"column": 18, "line": 4267}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 4267}, "start": {"column": 30, "line": 4267}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 39, "line": 4267}, "start": {"column": 37, "line": 4267}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 39, "line": 4267}, "start": {"column": 37, "line": 4267}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 17, "line": 4268}, "start": {"column": 16, "line": 4268}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 41, "line": 4268}, "start": {"column": 40, "line": 4268}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 4274}, "start": {"column": 18, "line": 4274}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 4274}, "start": {"column": 18, "line": 4274}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 4274}, "start": {"column": 39, "line": 4274}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 4275}, "start": {"column": 21, "line": 4275}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 4281}, "start": {"column": 18, "line": 4281}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 4281}, "start": {"column": 18, "line": 4281}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 4281}, "start": {"column": 39, "line": 4281}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 4282}, "start": {"column": 21, "line": 4282}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 4289}, "start": {"column": 18, "line": 4289}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 4289}, "start": {"column": 18, "line": 4289}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 4289}, "start": {"column": 39, "line": 4289}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 11, "line": 4354}, "start": {"column": 10, "line": 4354}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 11, "line": 4354}, "start": {"column": 10, "line": 4354}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 34, "line": 4362}, "start": {"column": 32, "line": 4362}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 4363}, "start": {"column": 28, "line": 4363}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 46, "line": 4372}, "start": {"column": 45, "line": 4372}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 4372}, "start": {"column": 50, "line": 4372}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 4390}, "start": {"column": 21, "line": 4390}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 4390}, "start": {"column": 21, "line": 4390}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 4413}, "start": {"column": 17, "line": 4413}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 4539}, "start": {"column": 26, "line": 4539}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 4540}, "start": {"column": 25, "line": 4540}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 4543}, "start": {"column": 16, "line": 4543}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 4543}, "start": {"column": 16, "line": 4543}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 33, "line": 4543}, "start": {"column": 32, "line": 4543}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 33, "line": 4543}, "start": {"column": 32, "line": 4543}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 4548}, "start": {"column": 14, "line": 4548}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 4548}, "start": {"column": 14, "line": 4548}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 4549}, "start": {"column": 16, "line": 4549}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 4550}, "start": {"column": 19, "line": 4550}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 4550}, "start": {"column": 19, "line": 4550}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 4551}, "start": {"column": 24, "line": 4551}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 4555}, "start": {"column": 18, "line": 4555}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 4555}, "start": {"column": 18, "line": 4555}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 57, "line": 4555}, "start": {"column": 55, "line": 4555}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 75, "line": 4555}, "start": {"column": 74, "line": 4555}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 75, "line": 4555}, "start": {"column": 74, "line": 4555}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 4557}, "start": {"column": 20, "line": 4557}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 4557}, "start": {"column": 20, "line": 4557}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 4565}, "start": {"column": 35, "line": 4565}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 32, "line": 4575}, "start": {"column": 31, "line": 4575}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 32, "line": 4575}, "start": {"column": 31, "line": 4575}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 4577}, "start": {"column": 14, "line": 4577}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 4577}, "start": {"column": 14, "line": 4577}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 29, "line": 4583}, "start": {"column": 28, "line": 4583}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 29, "line": 4583}, "start": {"column": 28, "line": 4583}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 49, "line": 4583}, "start": {"column": 48, "line": 4583}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 58, "line": 4583}, "start": {"column": 56, "line": 4583}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 58, "line": 4583}, "start": {"column": 56, "line": 4583}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 30, "line": 4584}, "start": {"column": 29, "line": 4584}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 39, "line": 4584}, "start": {"column": 38, "line": 4584}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 24, "line": 4586}, "start": {"column": 22, "line": 4586}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 24, "line": 4586}, "start": {"column": 22, "line": 4586}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 42, "line": 4586}, "start": {"column": 41, "line": 4586}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 31, "line": 4591}, "start": {"column": 30, "line": 4591}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 31, "line": 4591}, "start": {"column": 30, "line": 4591}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 31, "line": 4596}, "start": {"column": 30, "line": 4596}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 31, "line": 4596}, "start": {"column": 30, "line": 4596}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 4599}, "start": {"column": 27, "line": 4599}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 4603}, "start": {"column": 33, "line": 4603}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 52, "line": 4603}, "start": {"column": 50, "line": 4603}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 52, "line": 4603}, "start": {"column": 50, "line": 4603}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 54, "line": 4604}, "start": {"column": 53, "line": 4604}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 4613}, "start": {"column": 17, "line": 4613}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 4613}, "start": {"column": 17, "line": 4613}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 4613}, "start": {"column": 34, "line": 4613}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 4619}, "start": {"column": 15, "line": 4619}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 4619}, "start": {"column": 15, "line": 4619}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 4622}, "start": {"column": 15, "line": 4622}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 4628}, "start": {"column": 22, "line": 4628}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 4628}, "start": {"column": 22, "line": 4628}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 21, "line": 4631}, "start": {"column": 19, "line": 4631}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 18, "line": 4635}, "start": {"column": 16, "line": 4635}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 38, "line": 4858}, "start": {"column": 37, "line": 4858}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 4954}, "start": {"column": 11, "line": 4954}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 4954}, "start": {"column": 11, "line": 4954}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 4954}, "start": {"column": 22, "line": 4954}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 4954}, "start": {"column": 22, "line": 4954}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 31, "line": 4954}, "start": {"column": 30, "line": 4954}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 24, "line": 4963}, "start": {"column": 23, "line": 4963}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 24, "line": 4963}, "start": {"column": 23, "line": 4963}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 4963}, "start": {"column": 39, "line": 4963}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 4976}, "start": {"column": 13, "line": 4976}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 4976}, "start": {"column": 29, "line": 4976}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 14, "line": 4987}, "start": {"column": 12, "line": 4987}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 14, "line": 4987}, "start": {"column": 12, "line": 4987}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 4995}, "start": {"column": 36, "line": 4995}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 5004}, "start": {"column": 13, "line": 5004}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 5004}, "start": {"column": 13, "line": 5004}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 26, "line": 5004}, "start": {"column": 24, "line": 5004}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 26, "line": 5004}, "start": {"column": 24, "line": 5004}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 5011}, "start": {"column": 25, "line": 5011}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5028}, "start": {"column": 13, "line": 5028}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 5034}, "start": {"column": 17, "line": 5034}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 5041}, "start": {"column": 27, "line": 5041}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 44, "line": 5045}, "start": {"column": 43, "line": 5045}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 44, "line": 5045}, "start": {"column": 43, "line": 5045}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 44, "line": 5053}, "start": {"column": 43, "line": 5053}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 44, "line": 5053}, "start": {"column": 43, "line": 5053}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 61, "line": 5053}, "start": {"column": 59, "line": 5053}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 32, "line": 5074}, "start": {"column": 30, "line": 5074}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 32, "line": 5074}, "start": {"column": 30, "line": 5074}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 48, "line": 5074}, "start": {"column": 46, "line": 5074}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 48, "line": 5074}, "start": {"column": 46, "line": 5074}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 5077}, "start": {"column": 25, "line": 5077}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 5077}, "start": {"column": 25, "line": 5077}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 43, "line": 5077}, "start": {"column": 41, "line": 5077}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 5091}, "start": {"column": 40, "line": 5091}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 5098}, "start": {"column": 35, "line": 5098}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 58, "line": 5098}, "start": {"column": 56, "line": 5098}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 47, "line": 5102}, "start": {"column": 45, "line": 5102}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 39, "line": 5106}, "start": {"column": 38, "line": 5106}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 39, "line": 5106}, "start": {"column": 38, "line": 5106}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 50, "line": 5106}, "start": {"column": 49, "line": 5106}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 50, "line": 5108}, "start": {"column": 49, "line": 5108}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 41, "line": 5111}, "start": {"column": 39, "line": 5111}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 62, "line": 5111}, "start": {"column": 60, "line": 5111}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 35, "line": 5125}, "start": {"column": 34, "line": 5125}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 35, "line": 5125}, "start": {"column": 34, "line": 5125}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 65, "line": 5128}, "start": {"column": 64, "line": 5128}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 5129}, "start": {"column": 18, "line": 5129}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 5129}, "start": {"column": 28, "line": 5129}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 29, "line": 5134}, "start": {"column": 28, "line": 5134}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 29, "line": 5134}, "start": {"column": 28, "line": 5134}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 68, "line": 5134}, "start": {"column": 66, "line": 5134}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 43, "line": 5150}, "start": {"column": 42, "line": 5150}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 43, "line": 5150}, "start": {"column": 42, "line": 5150}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 66, "line": 5150}, "start": {"column": 64, "line": 5150}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 21, "line": 5160}, "start": {"column": 20, "line": 5160}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 5160}, "start": {"column": 26, "line": 5160}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 5162}, "start": {"column": 18, "line": 5162}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 5197}, "start": {"column": 41, "line": 5197}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 5207}, "start": {"column": 14, "line": 5207}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 69, "line": 5221}, "start": {"column": 67, "line": 5221}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 70, "line": 5222}, "start": {"column": 68, "line": 5222}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 5235}, "start": {"column": 43, "line": 5235}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 5244}, "start": {"column": 12, "line": 5244}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 5244}, "start": {"column": 12, "line": 5244}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 30, "line": 5244}, "start": {"column": 29, "line": 5244}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 11, "line": 5245}, "start": {"column": 10, "line": 5245}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 15, "line": 5245}, "start": {"column": 14, "line": 5245}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 39, "line": 5245}, "start": {"column": 38, "line": 5245}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 14, "line": 5248}, "start": {"column": 13, "line": 5248}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 5269}, "start": {"column": 54, "line": 5269}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 5295}, "start": {"column": 33, "line": 5295}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 35, "line": 5328}, "start": {"column": 33, "line": 5328}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 37, "line": 5338}, "start": {"column": 36, "line": 5338}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 25, "line": 5339}, "start": {"column": 24, "line": 5339}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 25, "line": 5339}, "start": {"column": 24, "line": 5339}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 5349}, "start": {"column": 14, "line": 5349}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 41, "line": 5364}, "start": {"column": 39, "line": 5364}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 5365}, "start": {"column": 19, "line": 5365}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 5365}, "start": {"column": 19, "line": 5365}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 5394}, "start": {"column": 24, "line": 5394}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 5394}, "start": {"column": 24, "line": 5394}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 51, "line": 5394}, "start": {"column": 49, "line": 5394}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 5395}, "start": {"column": 42, "line": 5395}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 69, "line": 5395}, "start": {"column": 67, "line": 5395}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 39, "line": 5414}, "start": {"column": 38, "line": 5414}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 39, "line": 5414}, "start": {"column": 38, "line": 5414}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 44, "line": 5414}, "start": {"column": 43, "line": 5414}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 58, "line": 5414}, "start": {"column": 56, "line": 5414}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 53, "line": 5419}, "start": {"column": 51, "line": 5419}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 53, "line": 5419}, "start": {"column": 51, "line": 5419}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 11, "line": 5457}, "start": {"column": 9, "line": 5457}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 5463}, "start": {"column": 13, "line": 5463}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 5465}, "start": {"column": 17, "line": 5465}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 5466}, "start": {"column": 17, "line": 5466}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 5473}, "start": {"column": 10, "line": 5473}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 5479}, "start": {"column": 15, "line": 5479}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 27, "line": 5483}, "start": {"column": 26, "line": 5483}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 27, "line": 5483}, "start": {"column": 26, "line": 5483}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 35, "line": 5483}, "start": {"column": 34, "line": 5483}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 5484}, "start": {"column": 18, "line": 5484}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 5508}, "start": {"column": 26, "line": 5508}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 5526}, "start": {"column": 23, "line": 5526}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 5526}, "start": {"column": 48, "line": 5526}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 5610}, "start": {"column": 21, "line": 5610}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 5610}, "start": {"column": 21, "line": 5610}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 51, "line": 5610}, "start": {"column": 49, "line": 5610}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 5613}, "start": {"column": 18, "line": 5613}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 5613}, "start": {"column": 18, "line": 5613}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 48, "line": 5613}, "start": {"column": 46, "line": 5613}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 47, "line": 5619}, "start": {"column": 46, "line": 5619}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 39, "line": 5620}, "start": {"column": 37, "line": 5620}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 5651}, "start": {"column": 20, "line": 5651}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 5651}, "start": {"column": 20, "line": 5651}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 5652}, "start": {"column": 28, "line": 5652}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 5653}, "start": {"column": 31, "line": 5653}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 5657}, "start": {"column": 20, "line": 5657}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 5667}, "start": {"column": 40, "line": 5667}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 5668}, "start": {"column": 54, "line": 5668}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 27, "line": 5671}, "start": {"column": 25, "line": 5671}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 5677}, "start": {"column": 41, "line": 5677}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 62, "line": 5677}, "start": {"column": 60, "line": 5677}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 5684}, "start": {"column": 32, "line": 5684}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 5685}, "start": {"column": 28, "line": 5685}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 39, "line": 5687}, "start": {"column": 37, "line": 5687}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 5689}, "start": {"column": 13, "line": 5689}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 5689}, "start": {"column": 13, "line": 5689}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 39, "line": 5689}, "start": {"column": 38, "line": 5689}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 13, "line": 5690}, "start": {"column": 12, "line": 5690}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 17, "line": 5690}, "start": {"column": 16, "line": 5690}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 41, "line": 5690}, "start": {"column": 40, "line": 5690}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 5704}, "start": {"column": 28, "line": 5704}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 5788}, "start": {"column": 20, "line": 5788}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 5788}, "start": {"column": 20, "line": 5788}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 5795}, "start": {"column": 18, "line": 5795}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 5955}, "start": {"column": 17, "line": 5955}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 5955}, "start": {"column": 17, "line": 5955}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 59, "line": 5972}, "start": {"column": 57, "line": 5972}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 5974}, "start": {"column": 48, "line": 5974}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 19, "line": 5982}, "start": {"column": 17, "line": 5982}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 19, "line": 5982}, "start": {"column": 17, "line": 5982}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 35, "line": 5982}, "start": {"column": 33, "line": 5982}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 35, "line": 5982}, "start": {"column": 33, "line": 5982}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 6019}, "start": {"column": 13, "line": 6019}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 6019}, "start": {"column": 13, "line": 6019}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 6035}, "start": {"column": 13, "line": 6035}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 6035}, "start": {"column": 13, "line": 6035}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 6055}, "start": {"column": 43, "line": 6055}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 6055}, "start": {"column": 47, "line": 6055}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 43, "line": 6071}, "start": {"column": 41, "line": 6071}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 45, "line": 6078}, "start": {"column": 44, "line": 6078}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 50, "line": 6078}, "start": {"column": 48, "line": 6078}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 6127}, "start": {"column": 13, "line": 6127}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 6127}, "start": {"column": 13, "line": 6127}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 6192}, "start": {"column": 54, "line": 6192}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 18, "line": 6202}, "start": {"column": 16, "line": 6202}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 18, "line": 6202}, "start": {"column": 16, "line": 6202}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 6213}, "start": {"column": 16, "line": 6213}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 6253}, "start": {"column": 28, "line": 6253}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 29, "line": 6416}, "start": {"column": 27, "line": 6416}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 6420}, "start": {"column": 21, "line": 6420}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 6420}, "start": {"column": 21, "line": 6420}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 6420}, "start": {"column": 39, "line": 6420}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 6445}, "start": {"column": 11, "line": 6445}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 52, "line": 6477}, "start": {"column": 51, "line": 6477}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 52, "line": 6477}, "start": {"column": 51, "line": 6477}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 6494}, "start": {"column": 22, "line": 6494}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 6494}, "start": {"column": 42, "line": 6494}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 6506}, "start": {"column": 15, "line": 6506}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 6506}, "start": {"column": 15, "line": 6506}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 6510}, "start": {"column": 25, "line": 6510}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 6510}, "start": {"column": 25, "line": 6510}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 38, "line": 6510}, "start": {"column": 36, "line": 6510}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 16, "line": 6523}, "start": {"column": 14, "line": 6523}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 16, "line": 6523}, "start": {"column": 14, "line": 6523}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 6540}, "start": {"column": 15, "line": 6540}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 6540}, "start": {"column": 15, "line": 6540}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 6541}, "start": {"column": 18, "line": 6541}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 6541}, "start": {"column": 18, "line": 6541}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 28, "line": 6555}, "start": {"column": 27, "line": 6555}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 6557}, "start": {"column": 19, "line": 6557}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 6559}, "start": {"column": 20, "line": 6559}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 6559}, "start": {"column": 20, "line": 6559}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 46, "line": 6561}, "start": {"column": 45, "line": 6561}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 6562}, "start": {"column": 30, "line": 6562}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 6578}, "start": {"column": 20, "line": 6578}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 6585}, "start": {"column": 21, "line": 6585}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 6590}, "start": {"column": 23, "line": 6590}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 15, "line": 6806}, "start": {"column": 14, "line": 6806}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 35, "line": 6806}, "start": {"column": 34, "line": 6806}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 8, "line": 6814}, "start": {"column": 7, "line": 6814}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 29, "line": 6814}, "start": {"column": 28, "line": 6814}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 8, "line": 6822}, "start": {"column": 7, "line": 6822}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_rem_to_div", "location": {"end": {"column": 31, "line": 6822}, "start": {"column": 30, "line": 6822}}, "mutatorName": "Replaced % with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6832}, "start": {"column": 17, "line": 6832}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6832}, "start": {"column": 17, "line": 6832}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 6832}, "start": {"column": 35, "line": 6832}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6842}, "start": {"column": 17, "line": 6842}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6842}, "start": {"column": 17, "line": 6842}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 6842}, "start": {"column": 35, "line": 6842}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6852}, "start": {"column": 17, "line": 6852}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6852}, "start": {"column": 17, "line": 6852}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 6852}, "start": {"column": 35, "line": 6852}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6863}, "start": {"column": 17, "line": 6863}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6863}, "start": {"column": 17, "line": 6863}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 6863}, "start": {"column": 35, "line": 6863}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 6864}, "start": {"column": 15, "line": 6864}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6879}, "start": {"column": 17, "line": 6879}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6879}, "start": {"column": 17, "line": 6879}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 6879}, "start": {"column": 32, "line": 6879}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 6883}, "start": {"column": 3, "line": 6883}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 6973}, "start": {"column": 15, "line": 6973}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 6973}, "start": {"column": 15, "line": 6973}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 36, "line": 6975}, "start": {"column": 34, "line": 6975}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 6992}, "start": {"column": 17, "line": 6992}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 6992}, "start": {"column": 17, "line": 6992}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 25, "line": 6992}, "start": {"column": 22, "line": 6992}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 7000}, "start": {"column": 16, "line": 7000}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 7009}, "start": {"column": 19, "line": 7009}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 7010}, "start": {"column": 19, "line": 7010}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 7011}, "start": {"column": 19, "line": 7011}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 7019}, "start": {"column": 19, "line": 7019}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 7021}, "start": {"column": 15, "line": 7021}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 7021}, "start": {"column": 15, "line": 7021}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 7021}, "start": {"column": 30, "line": 7021}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 7022}, "start": {"column": 15, "line": 7022}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 7022}, "start": {"column": 15, "line": 7022}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 7022}, "start": {"column": 32, "line": 7022}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 7022}, "start": {"column": 53, "line": 7022}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 7024}, "start": {"column": 15, "line": 7024}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 7024}, "start": {"column": 15, "line": 7024}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 7024}, "start": {"column": 30, "line": 7024}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 7025}, "start": {"column": 15, "line": 7025}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 7025}, "start": {"column": 15, "line": 7025}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 7025}, "start": {"column": 32, "line": 7025}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 55, "line": 7025}, "start": {"column": 53, "line": 7025}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 7027}, "start": {"column": 23, "line": 7027}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 7027}, "start": {"column": 23, "line": 7027}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 7027}, "start": {"column": 38, "line": 7027}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7070}, "start": {"column": 18, "line": 7070}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 54, "line": 7070}, "start": {"column": 52, "line": 7070}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7086}, "start": {"column": 18, "line": 7086}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 54, "line": 7086}, "start": {"column": 52, "line": 7086}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7095}, "start": {"column": 18, "line": 7095}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 7095}, "start": {"column": 54, "line": 7095}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 7106}, "start": {"column": 19, "line": 7106}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 7112}, "start": {"column": 17, "line": 7112}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 7112}, "start": {"column": 26, "line": 7112}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 7112}, "start": {"column": 30, "line": 7112}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 7115}, "start": {"column": 15, "line": 7115}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 7117}, "start": {"column": 10, "line": 7117}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 16, "line": 7123}, "start": {"column": 15, "line": 7123}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 7123}, "start": {"column": 24, "line": 7123}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 7123}, "start": {"column": 28, "line": 7123}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 7129}, "start": {"column": 14, "line": 7129}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 12, "line": 7133}, "start": {"column": 10, "line": 7133}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7141}, "start": {"column": 18, "line": 7141}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 54, "line": 7141}, "start": {"column": 52, "line": 7141}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7155}, "start": {"column": 18, "line": 7155}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 7155}, "start": {"column": 54, "line": 7155}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 12, "line": 7157}, "start": {"column": 4, "line": 7157}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 7162}, "start": {"column": 18, "line": 7162}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 56, "line": 7162}, "start": {"column": 54, "line": 7162}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 7164}, "start": {"column": 15, "line": 7164}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 7180}, "start": {"column": 26, "line": 7180}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 7187}, "start": {"column": 20, "line": 7187}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 7187}, "start": {"column": 20, "line": 7187}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 7187}, "start": {"column": 31, "line": 7187}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 7190}, "start": {"column": 10, "line": 7190}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 7193}, "start": {"column": 26, "line": 7193}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 7200}, "start": {"column": 10, "line": 7200}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7215}, "start": {"column": 14, "line": 7215}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 7216}, "start": {"column": 36, "line": 7216}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 26, "line": 7219}, "start": {"column": 25, "line": 7219}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 26, "line": 7219}, "start": {"column": 25, "line": 7219}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 40, "line": 7219}, "start": {"column": 36, "line": 7219}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7227}, "start": {"column": 14, "line": 7227}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 7230}, "start": {"column": 15, "line": 7230}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 7233}, "start": {"column": 12, "line": 7233}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 18, "line": 7238}, "start": {"column": 9, "line": 7238}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 7243}, "start": {"column": 16, "line": 7243}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 7251}, "start": {"column": 17, "line": 7251}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 7251}, "start": {"column": 17, "line": 7251}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 8, "line": 7259}, "start": {"column": 5, "line": 7259}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 7264}, "start": {"column": 20, "line": 7264}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 27, "line": 7272}, "start": {"column": 26, "line": 7272}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 31, "line": 7285}, "start": {"column": 30, "line": 7285}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 28, "line": 7312}, "start": {"column": 26, "line": 7312}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 21, "line": 7328}, "start": {"column": 7, "line": 7328}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 7330}, "start": {"column": 7, "line": 7330}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 14, "line": 7333}, "start": {"column": 13, "line": 7333}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 14, "line": 7333}, "start": {"column": 13, "line": 7333}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 14, "line": 7376}, "start": {"column": 12, "line": 7376}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 14, "line": 7376}, "start": {"column": 12, "line": 7376}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 7376}, "start": {"column": 24, "line": 7376}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 7376}, "start": {"column": 24, "line": 7376}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 44, "line": 7376}, "start": {"column": 42, "line": 7376}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 44, "line": 7376}, "start": {"column": 42, "line": 7376}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 59, "line": 7376}, "start": {"column": 57, "line": 7376}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7377}, "start": {"column": 14, "line": 7377}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 7377}, "start": {"column": 32, "line": 7377}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 7377}, "start": {"column": 50, "line": 7377}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7378}, "start": {"column": 14, "line": 7378}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 34, "line": 7378}, "start": {"column": 32, "line": 7378}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 7378}, "start": {"column": 50, "line": 7378}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 7383}, "start": {"column": 16, "line": 7383}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 7387}, "start": {"column": 15, "line": 7387}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 7401}, "start": {"column": 30, "line": 7401}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 17, "line": 7408}, "start": {"column": 16, "line": 7408}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 35, "line": 7408}, "start": {"column": 34, "line": 7408}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 33, "line": 7412}, "start": {"column": 32, "line": 7412}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 17, "line": 7413}, "start": {"column": 16, "line": 7413}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 7413}, "start": {"column": 25, "line": 7413}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 44, "line": 7413}, "start": {"column": 43, "line": 7413}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 48, "line": 7413}, "start": {"column": 47, "line": 7413}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7424}, "start": {"column": 17, "line": 7424}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7424}, "start": {"column": 17, "line": 7424}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 7424}, "start": {"column": 28, "line": 7424}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 32, "line": 7425}, "start": {"column": 31, "line": 7425}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7434}, "start": {"column": 14, "line": 7434}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 7434}, "start": {"column": 30, "line": 7434}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 47, "line": 7434}, "start": {"column": 45, "line": 7434}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 62, "line": 7434}, "start": {"column": 60, "line": 7434}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 7435}, "start": {"column": 13, "line": 7435}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 24, "line": 7438}, "start": {"column": 23, "line": 7438}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 7439}, "start": {"column": 13, "line": 7439}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 7441}, "start": {"column": 13, "line": 7441}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 7443}, "start": {"column": 16, "line": 7443}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 7443}, "start": {"column": 16, "line": 7443}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 7443}, "start": {"column": 26, "line": 7443}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 7448}, "start": {"column": 11, "line": 7448}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 7448}, "start": {"column": 11, "line": 7448}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 24, "line": 7448}, "start": {"column": 21, "line": 7448}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 7467}, "start": {"column": 14, "line": 7467}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 7467}, "start": {"column": 31, "line": 7467}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 46, "line": 7467}, "start": {"column": 44, "line": 7467}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 46, "line": 7467}, "start": {"column": 44, "line": 7467}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 7479}, "start": {"column": 14, "line": 7479}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 7515}, "start": {"column": 11, "line": 7515}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 7518}, "start": {"column": 14, "line": 7518}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 16, "line": 7524}, "start": {"column": 3, "line": 7524}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7537}, "start": {"column": 17, "line": 7537}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7537}, "start": {"column": 17, "line": 7537}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 7537}, "start": {"column": 31, "line": 7537}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7554}, "start": {"column": 17, "line": 7554}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7554}, "start": {"column": 17, "line": 7554}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 40, "line": 7554}, "start": {"column": 39, "line": 7554}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 40, "line": 7554}, "start": {"column": 39, "line": 7554}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 63, "line": 7554}, "start": {"column": 60, "line": 7554}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 10, "line": 7556}, "start": {"column": 9, "line": 7556}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 10, "line": 7556}, "start": {"column": 9, "line": 7556}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 7556}, "start": {"column": 31, "line": 7556}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 7561}, "start": {"column": 7, "line": 7561}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 7562}, "start": {"column": 16, "line": 7562}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 7562}, "start": {"column": 16, "line": 7562}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 16, "line": 7565}, "start": {"column": 14, "line": 7565}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 7582}, "start": {"column": 12, "line": 7582}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 7582}, "start": {"column": 12, "line": 7582}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 30, "line": 7582}, "start": {"column": 29, "line": 7582}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 30, "line": 7582}, "start": {"column": 29, "line": 7582}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 29, "line": 7583}, "start": {"column": 28, "line": 7583}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 29, "line": 7583}, "start": {"column": 28, "line": 7583}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 26, "line": 7584}, "start": {"column": 24, "line": 7584}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 43, "line": 7584}, "start": {"column": 41, "line": 7584}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 7585}, "start": {"column": 33, "line": 7585}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 7585}, "start": {"column": 33, "line": 7585}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 26, "line": 7586}, "start": {"column": 24, "line": 7586}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 43, "line": 7586}, "start": {"column": 41, "line": 7586}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 36, "line": 7589}, "start": {"column": 34, "line": 7589}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 21, "line": 7590}, "start": {"column": 19, "line": 7590}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 50, "line": 7590}, "start": {"column": 48, "line": 7590}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 7592}, "start": {"column": 12, "line": 7592}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 7592}, "start": {"column": 12, "line": 7592}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 24, "line": 7593}, "start": {"column": 22, "line": 7593}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 7593}, "start": {"column": 39, "line": 7593}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 7594}, "start": {"column": 12, "line": 7594}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 7594}, "start": {"column": 12, "line": 7594}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 24, "line": 7595}, "start": {"column": 22, "line": 7595}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 41, "line": 7595}, "start": {"column": 39, "line": 7595}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7606}, "start": {"column": 17, "line": 7606}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7606}, "start": {"column": 17, "line": 7606}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 7606}, "start": {"column": 29, "line": 7606}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 7607}, "start": {"column": 17, "line": 7607}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 10, "line": 7609}, "start": {"column": 9, "line": 7609}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 10, "line": 7609}, "start": {"column": 9, "line": 7609}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 25, "line": 7610}, "start": {"column": 24, "line": 7610}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 25, "line": 7610}, "start": {"column": 24, "line": 7610}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 7610}, "start": {"column": 36, "line": 7610}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 33, "line": 7611}, "start": {"column": 32, "line": 7611}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7632}, "start": {"column": 17, "line": 7632}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7632}, "start": {"column": 17, "line": 7632}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 7632}, "start": {"column": 29, "line": 7632}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 32, "line": 7633}, "start": {"column": 31, "line": 7633}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7636}, "start": {"column": 17, "line": 7636}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7636}, "start": {"column": 17, "line": 7636}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7636}, "start": {"column": 30, "line": 7636}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 7638}, "start": {"column": 16, "line": 7638}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 51, "line": 7638}, "start": {"column": 49, "line": 7638}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 17, "line": 7639}, "start": {"column": 15, "line": 7639}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 51, "line": 7639}, "start": {"column": 49, "line": 7639}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 7641}, "start": {"column": 21, "line": 7641}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 7641}, "start": {"column": 21, "line": 7641}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 7641}, "start": {"column": 33, "line": 7641}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 8, "line": 7643}, "start": {"column": 6, "line": 7643}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 29, "line": 7644}, "start": {"column": 27, "line": 7644}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 7646}, "start": {"column": 13, "line": 7646}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7660}, "start": {"column": 17, "line": 7660}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7660}, "start": {"column": 17, "line": 7660}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 7660}, "start": {"column": 29, "line": 7660}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 39, "line": 7661}, "start": {"column": 38, "line": 7661}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 39, "line": 7661}, "start": {"column": 38, "line": 7661}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 45, "line": 7672}, "start": {"column": 43, "line": 7672}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 7678}, "start": {"column": 3, "line": 7678}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7698}, "start": {"column": 17, "line": 7698}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7698}, "start": {"column": 17, "line": 7698}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7698}, "start": {"column": 30, "line": 7698}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7701}, "start": {"column": 17, "line": 7701}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7701}, "start": {"column": 17, "line": 7701}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 32, "line": 7701}, "start": {"column": 29, "line": 7701}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 40, "line": 7702}, "start": {"column": 38, "line": 7702}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 40, "line": 7702}, "start": {"column": 38, "line": 7702}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 7703}, "start": {"column": 34, "line": 7703}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 35, "line": 7704}, "start": {"column": 34, "line": 7704}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 35, "line": 7704}, "start": {"column": 34, "line": 7704}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 7738}, "start": {"column": 16, "line": 7738}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 7738}, "start": {"column": 16, "line": 7738}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 50, "line": 7738}, "start": {"column": 47, "line": 7738}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7845}, "start": {"column": 17, "line": 7845}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7845}, "start": {"column": 17, "line": 7845}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7845}, "start": {"column": 30, "line": 7845}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7851}, "start": {"column": 17, "line": 7851}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7851}, "start": {"column": 17, "line": 7851}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7851}, "start": {"column": 30, "line": 7851}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 7872}, "start": {"column": 16, "line": 7872}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 7872}, "start": {"column": 16, "line": 7872}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 7872}, "start": {"column": 32, "line": 7872}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 21, "line": 7882}, "start": {"column": 19, "line": 7882}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 7892}, "start": {"column": 16, "line": 7892}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 7892}, "start": {"column": 16, "line": 7892}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 7892}, "start": {"column": 32, "line": 7892}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 7915}, "start": {"column": 28, "line": 7915}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 37, "line": 7915}, "start": {"column": 35, "line": 7915}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 37, "line": 7915}, "start": {"column": 35, "line": 7915}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 7948}, "start": {"column": 29, "line": 7948}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 7985}, "start": {"column": 17, "line": 7985}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 7985}, "start": {"column": 17, "line": 7985}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 7985}, "start": {"column": 30, "line": 7985}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 23, "line": 7986}, "start": {"column": 22, "line": 7986}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 23, "line": 7986}, "start": {"column": 22, "line": 7986}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 50, "line": 7986}, "start": {"column": 48, "line": 7986}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 7987}, "start": {"column": 18, "line": 7987}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 7987}, "start": {"column": 18, "line": 7987}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 27, "line": 8002}, "start": {"column": 26, "line": 8002}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 27, "line": 8002}, "start": {"column": 26, "line": 8002}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8010}, "start": {"column": 17, "line": 8010}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8010}, "start": {"column": 17, "line": 8010}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 37, "line": 8010}, "start": {"column": 34, "line": 8010}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8016}, "start": {"column": 17, "line": 8016}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8016}, "start": {"column": 17, "line": 8016}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 8016}, "start": {"column": 33, "line": 8016}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8097}, "start": {"column": 21, "line": 8097}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8097}, "start": {"column": 21, "line": 8097}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 8097}, "start": {"column": 32, "line": 8097}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8105}, "start": {"column": 17, "line": 8105}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8105}, "start": {"column": 17, "line": 8105}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 48, "line": 8105}, "start": {"column": 45, "line": 8105}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 34, "line": 8108}, "start": {"column": 32, "line": 8108}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 34, "line": 8108}, "start": {"column": 32, "line": 8108}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 62, "line": 8108}, "start": {"column": 61, "line": 8108}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 62, "line": 8108}, "start": {"column": 61, "line": 8108}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 39, "line": 8110}, "start": {"column": 37, "line": 8110}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 39, "line": 8110}, "start": {"column": 37, "line": 8110}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 47, "line": 8111}, "start": {"column": 46, "line": 8111}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 28, "line": 8117}, "start": {"column": 26, "line": 8117}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 8124}, "start": {"column": 20, "line": 8124}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 8124}, "start": {"column": 20, "line": 8124}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 8124}, "start": {"column": 38, "line": 8124}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 8128}, "start": {"column": 20, "line": 8128}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 8128}, "start": {"column": 20, "line": 8128}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 8128}, "start": {"column": 38, "line": 8128}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 8132}, "start": {"column": 20, "line": 8132}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 8132}, "start": {"column": 20, "line": 8132}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 8132}, "start": {"column": 38, "line": 8132}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 8136}, "start": {"column": 18, "line": 8136}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 8136}, "start": {"column": 18, "line": 8136}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 54, "line": 8136}, "start": {"column": 51, "line": 8136}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 8138}, "start": {"column": 10, "line": 8138}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8142}, "start": {"column": 21, "line": 8142}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8142}, "start": {"column": 21, "line": 8142}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 8142}, "start": {"column": 30, "line": 8142}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 31, "line": 8147}, "start": {"column": 29, "line": 8147}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 31, "line": 8147}, "start": {"column": 29, "line": 8147}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 59, "line": 8147}, "start": {"column": 58, "line": 8147}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 59, "line": 8147}, "start": {"column": 58, "line": 8147}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 8154}, "start": {"column": 18, "line": 8154}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 8154}, "start": {"column": 18, "line": 8154}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 8154}, "start": {"column": 36, "line": 8154}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 8161}, "start": {"column": 18, "line": 8161}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 8161}, "start": {"column": 18, "line": 8161}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 8161}, "start": {"column": 36, "line": 8161}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 8177}, "start": {"column": 8, "line": 8177}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 33, "line": 8182}, "start": {"column": 31, "line": 8182}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 8192}, "start": {"column": 13, "line": 8192}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 8199}, "start": {"column": 4, "line": 8199}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8213}, "start": {"column": 21, "line": 8213}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8213}, "start": {"column": 21, "line": 8213}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 52, "line": 8213}, "start": {"column": 49, "line": 8213}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8230}, "start": {"column": 21, "line": 8230}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8230}, "start": {"column": 21, "line": 8230}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 8230}, "start": {"column": 32, "line": 8230}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 10, "line": 8231}, "start": {"column": 8, "line": 8231}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 8239}, "start": {"column": 19, "line": 8239}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 8239}, "start": {"column": 19, "line": 8239}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 8239}, "start": {"column": 30, "line": 8239}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8242}, "start": {"column": 17, "line": 8242}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8242}, "start": {"column": 17, "line": 8242}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 8242}, "start": {"column": 26, "line": 8242}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8248}, "start": {"column": 21, "line": 8248}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8248}, "start": {"column": 21, "line": 8248}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 41, "line": 8248}, "start": {"column": 38, "line": 8248}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8249}, "start": {"column": 16, "line": 8249}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8249}, "start": {"column": 16, "line": 8249}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 63, "line": 8249}, "start": {"column": 60, "line": 8249}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8255}, "start": {"column": 16, "line": 8255}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8255}, "start": {"column": 16, "line": 8255}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 47, "line": 8255}, "start": {"column": 44, "line": 8255}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8261}, "start": {"column": 16, "line": 8261}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8261}, "start": {"column": 16, "line": 8261}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 8261}, "start": {"column": 33, "line": 8261}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8266}, "start": {"column": 21, "line": 8266}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8266}, "start": {"column": 21, "line": 8266}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 42, "line": 8266}, "start": {"column": 39, "line": 8266}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 8269}, "start": {"column": 13, "line": 8269}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 8269}, "start": {"column": 13, "line": 8269}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8270}, "start": {"column": 16, "line": 8270}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8270}, "start": {"column": 16, "line": 8270}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 8270}, "start": {"column": 33, "line": 8270}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8286}, "start": {"column": 21, "line": 8286}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8286}, "start": {"column": 21, "line": 8286}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 42, "line": 8286}, "start": {"column": 39, "line": 8286}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 8287}, "start": {"column": 16, "line": 8287}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 8287}, "start": {"column": 16, "line": 8287}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 30, "line": 8287}, "start": {"column": 27, "line": 8287}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 19, "line": 8290}, "start": {"column": 18, "line": 8290}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 29, "line": 8290}, "start": {"column": 28, "line": 8290}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 8292}, "start": {"column": 14, "line": 8292}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 8296}, "start": {"column": 19, "line": 8296}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 8296}, "start": {"column": 19, "line": 8296}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8301}, "start": {"column": 17, "line": 8301}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8301}, "start": {"column": 17, "line": 8301}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 29, "line": 8301}, "start": {"column": 26, "line": 8301}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 8326}, "start": {"column": 18, "line": 8326}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 8326}, "start": {"column": 18, "line": 8326}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8328}, "start": {"column": 21, "line": 8328}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8328}, "start": {"column": 21, "line": 8328}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 8328}, "start": {"column": 35, "line": 8328}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 8342}, "start": {"column": 3, "line": 8342}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8362}, "start": {"column": 17, "line": 8362}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8362}, "start": {"column": 17, "line": 8362}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8362}, "start": {"column": 28, "line": 8362}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 8363}, "start": {"column": 18, "line": 8363}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 8363}, "start": {"column": 18, "line": 8363}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 20, "line": 8367}, "start": {"column": 18, "line": 8367}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 20, "line": 8367}, "start": {"column": 18, "line": 8367}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 8374}, "start": {"column": 18, "line": 8374}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 8374}, "start": {"column": 18, "line": 8374}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 25, "line": 8377}, "start": {"column": 23, "line": 8377}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8440}, "start": {"column": 21, "line": 8440}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8440}, "start": {"column": 21, "line": 8440}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 35, "line": 8440}, "start": {"column": 32, "line": 8440}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 10, "line": 8441}, "start": {"column": 8, "line": 8441}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 28, "line": 8460}, "start": {"column": 26, "line": 8460}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 8468}, "start": {"column": 31, "line": 8468}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 8474}, "start": {"column": 13, "line": 8474}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 8474}, "start": {"column": 13, "line": 8474}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 25, "line": 8474}, "start": {"column": 23, "line": 8474}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 25, "line": 8474}, "start": {"column": 23, "line": 8474}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 33, "line": 8492}, "start": {"column": 31, "line": 8492}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 33, "line": 8492}, "start": {"column": 31, "line": 8492}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 49, "line": 8492}, "start": {"column": 47, "line": 8492}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 8493}, "start": {"column": 2, "line": 8493}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 23, "line": 8496}, "start": {"column": 22, "line": 8496}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 23, "line": 8496}, "start": {"column": 22, "line": 8496}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 15, "line": 8499}, "start": {"column": 13, "line": 8499}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 15, "line": 8499}, "start": {"column": 13, "line": 8499}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 8506}, "start": {"column": 17, "line": 8506}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 8555}, "start": {"column": 21, "line": 8555}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 8555}, "start": {"column": 21, "line": 8555}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 8555}, "start": {"column": 28, "line": 8555}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8589}, "start": {"column": 17, "line": 8589}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8589}, "start": {"column": 17, "line": 8589}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 8589}, "start": {"column": 30, "line": 8589}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8592}, "start": {"column": 17, "line": 8592}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8592}, "start": {"column": 17, "line": 8592}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 8592}, "start": {"column": 30, "line": 8592}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 18, "line": 8596}, "start": {"column": 17, "line": 8596}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 18, "line": 8596}, "start": {"column": 17, "line": 8596}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 8596}, "start": {"column": 31, "line": 8596}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 8700}, "start": {"column": 18, "line": 8700}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8701}, "start": {"column": 11, "line": 8701}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 8703}, "start": {"column": 20, "line": 8703}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8706}, "start": {"column": 11, "line": 8706}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 39, "line": 8707}, "start": {"column": 38, "line": 8707}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 54, "line": 8709}, "start": {"column": 53, "line": 8709}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 64, "line": 8709}, "start": {"column": 63, "line": 8709}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 16, "line": 8710}, "start": {"column": 14, "line": 8710}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 8710}, "start": {"column": 29, "line": 8710}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 8731}, "start": {"column": 25, "line": 8731}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 37, "line": 8732}, "start": {"column": 35, "line": 8732}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 12, "line": 8741}, "start": {"column": 10, "line": 8741}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8751}, "start": {"column": 11, "line": 8751}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 24, "line": 8753}, "start": {"column": 22, "line": 8753}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 8753}, "start": {"column": 31, "line": 8753}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8768}, "start": {"column": 11, "line": 8768}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 8770}, "start": {"column": 30, "line": 8770}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 24, "line": 8777}, "start": {"column": 22, "line": 8777}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 8777}, "start": {"column": 31, "line": 8777}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 8778}, "start": {"column": 30, "line": 8778}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 19, "line": 8785}, "start": {"column": 17, "line": 8785}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 32, "line": 8786}, "start": {"column": 30, "line": 8786}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 10, "line": 8787}, "start": {"column": 7, "line": 8787}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 8791}, "start": {"column": 10, "line": 8791}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 45, "line": 8797}, "start": {"column": 44, "line": 8797}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 50, "line": 8797}, "start": {"column": 49, "line": 8797}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8798}, "start": {"column": 11, "line": 8798}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 10, "line": 8801}, "start": {"column": 9, "line": 8801}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 8818}, "start": {"column": 12, "line": 8818}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 8818}, "start": {"column": 29, "line": 8818}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8821}, "start": {"column": 11, "line": 8821}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 8824}, "start": {"column": 25, "line": 8824}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 20, "line": 8828}, "start": {"column": 18, "line": 8828}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 25, "line": 8830}, "start": {"column": 23, "line": 8830}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 8830}, "start": {"column": 41, "line": 8830}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 55, "line": 8830}, "start": {"column": 52, "line": 8830}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 11, "line": 8832}, "start": {"column": 10, "line": 8832}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 11, "line": 8832}, "start": {"column": 10, "line": 8832}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 8836}, "start": {"column": 15, "line": 8836}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 8838}, "start": {"column": 41, "line": 8838}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 8851}, "start": {"column": 11, "line": 8851}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 28, "line": 8851}, "start": {"column": 26, "line": 8851}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 24, "line": 8853}, "start": {"column": 22, "line": 8853}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 34, "line": 8853}, "start": {"column": 31, "line": 8853}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 8856}, "start": {"column": 15, "line": 8856}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 8873}, "start": {"column": 12, "line": 8873}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 31, "line": 8873}, "start": {"column": 29, "line": 8873}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 8876}, "start": {"column": 12, "line": 8876}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 8879}, "start": {"column": 29, "line": 8879}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 44, "line": 8879}, "start": {"column": 38, "line": 8879}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 8881}, "start": {"column": 34, "line": 8881}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 49, "line": 8881}, "start": {"column": 43, "line": 8881}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 8884}, "start": {"column": 13, "line": 8884}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 8891}, "start": {"column": 13, "line": 8891}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 41, "line": 8930}, "start": {"column": 40, "line": 8930}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 46, "line": 8930}, "start": {"column": 45, "line": 8930}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 15, "line": 8931}, "start": {"column": 13, "line": 8931}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8934}, "start": {"column": 17, "line": 8934}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8934}, "start": {"column": 17, "line": 8934}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 8934}, "start": {"column": 33, "line": 8934}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 8936}, "start": {"column": 17, "line": 8936}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 8936}, "start": {"column": 17, "line": 8936}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 8936}, "start": {"column": 33, "line": 8936}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 8942}, "start": {"column": 20, "line": 8942}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 44, "line": 8942}, "start": {"column": 42, "line": 8942}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 8943}, "start": {"column": 16, "line": 8943}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 8943}, "start": {"column": 36, "line": 8943}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 8957}, "start": {"column": 19, "line": 8957}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 8957}, "start": {"column": 19, "line": 8957}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 38, "line": 8957}, "start": {"column": 34, "line": 8957}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 13, "line": 8976}, "start": {"column": 11, "line": 8976}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 13, "line": 8976}, "start": {"column": 11, "line": 8976}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 8983}, "start": {"column": 11, "line": 8983}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 8983}, "start": {"column": 11, "line": 8983}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 8994}, "start": {"column": 35, "line": 8994}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 28, "line": 8998}, "start": {"column": 26, "line": 8998}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 52, "line": 8998}, "start": {"column": 50, "line": 8998}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 11, "line": 8999}, "start": {"column": 8, "line": 8999}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 9005}, "start": {"column": 12, "line": 9005}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 9005}, "start": {"column": 12, "line": 9005}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 9007}, "start": {"column": 20, "line": 9007}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 9007}, "start": {"column": 20, "line": 9007}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 9007}, "start": {"column": 25, "line": 9007}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 27, "line": 9008}, "start": {"column": 26, "line": 9008}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 31, "line": 9008}, "start": {"column": 30, "line": 9008}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 37, "line": 9008}, "start": {"column": 35, "line": 9008}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 53, "line": 9008}, "start": {"column": 52, "line": 9008}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 57, "line": 9008}, "start": {"column": 56, "line": 9008}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 9010}, "start": {"column": 20, "line": 9010}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 9010}, "start": {"column": 20, "line": 9010}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 9010}, "start": {"column": 25, "line": 9010}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 40, "line": 9011}, "start": {"column": 39, "line": 9011}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 45, "line": 9011}, "start": {"column": 44, "line": 9011}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 9014}, "start": {"column": 14, "line": 9014}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 13, "line": 9022}, "start": {"column": 11, "line": 9022}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 13, "line": 9022}, "start": {"column": 11, "line": 9022}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 13, "line": 9028}, "start": {"column": 11, "line": 9028}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 9030}, "start": {"column": 31, "line": 9030}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 43, "line": 9030}, "start": {"column": 40, "line": 9030}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 34, "line": 9031}, "start": {"column": 33, "line": 9031}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 34, "line": 9031}, "start": {"column": 33, "line": 9031}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 38, "line": 9033}, "start": {"column": 36, "line": 9033}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 9037}, "start": {"column": 11, "line": 9037}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 9037}, "start": {"column": 11, "line": 9037}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 9049}, "start": {"column": 18, "line": 9049}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 9051}, "start": {"column": 24, "line": 9051}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 18, "line": 9052}, "start": {"column": 16, "line": 9052}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9057}, "start": {"column": 10, "line": 9057}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 12, "line": 9060}, "start": {"column": 10, "line": 9060}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9065}, "start": {"column": 15, "line": 9065}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 9069}, "start": {"column": 21, "line": 9069}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 9073}, "start": {"column": 17, "line": 9073}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 9077}, "start": {"column": 21, "line": 9077}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 23, "line": 9080}, "start": {"column": 21, "line": 9080}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 9083}, "start": {"column": 21, "line": 9083}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 45, "line": 9083}, "start": {"column": 43, "line": 9083}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9086}, "start": {"column": 15, "line": 9086}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 11, "line": 9094}, "start": {"column": 10, "line": 9094}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 11, "line": 9094}, "start": {"column": 10, "line": 9094}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 9099}, "start": {"column": 15, "line": 9099}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 17, "line": 9104}, "start": {"column": 15, "line": 9104}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 17, "line": 9104}, "start": {"column": 15, "line": 9104}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 21, "line": 9116}, "start": {"column": 19, "line": 9116}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 41, "line": 9138}, "start": {"column": 40, "line": 9138}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 19, "line": 9144}, "start": {"column": 17, "line": 9144}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 19, "line": 9144}, "start": {"column": 17, "line": 9144}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 36, "line": 9144}, "start": {"column": 33, "line": 9144}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 30, "line": 9347}, "start": {"column": 28, "line": 9347}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 9350}, "start": {"column": 14, "line": 9350}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 9350}, "start": {"column": 14, "line": 9350}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 18, "line": 9351}, "start": {"column": 16, "line": 9351}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_post_inc_to_post_dec", "location": {"end": {"column": 18, "line": 9353}, "start": {"column": 16, "line": 9353}}, "mutatorName": "Replaced x++ with x--", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 9376}, "start": {"column": 36, "line": 9376}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 24, "line": 9382}, "start": {"column": 22, "line": 9382}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 26, "line": 9390}, "start": {"column": 24, "line": 9390}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 26, "line": 9393}, "start": {"column": 3, "line": 9393}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 33, "line": 9398}, "start": {"column": 31, "line": 9398}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 9399}, "start": {"column": 20, "line": 9399}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 51, "line": 9399}, "start": {"column": 28, "line": 9399}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 9404}, "start": {"column": 24, "line": 9404}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 35, "line": 9415}, "start": {"column": 33, "line": 9415}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 35, "line": 9416}, "start": {"column": 33, "line": 9416}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 25, "line": 9422}, "start": {"column": 24, "line": 9422}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 35, "line": 9433}, "start": {"column": 33, "line": 9433}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 35, "line": 9434}, "start": {"column": 33, "line": 9434}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 24, "line": 9441}, "start": {"column": 23, "line": 9441}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 30, "line": 9441}, "start": {"column": 28, "line": 9441}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 9442}, "start": {"column": 15, "line": 9442}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 16, "line": 9444}, "start": {"column": 15, "line": 9444}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 26, "line": 9454}, "start": {"column": 25, "line": 9454}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 30, "line": 9454}, "start": {"column": 29, "line": 9454}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 17, "line": 9455}, "start": {"column": 3, "line": 9455}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9458}, "start": {"column": 19, "line": 9458}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9458}, "start": {"column": 19, "line": 9458}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 20, "line": 9460}, "start": {"column": 19, "line": 9460}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 20, "line": 9460}, "start": {"column": 19, "line": 9460}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 9502}, "start": {"column": 34, "line": 9502}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 9503}, "start": {"column": 18, "line": 9503}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 9503}, "start": {"column": 18, "line": 9503}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 14, "line": 9530}, "start": {"column": 13, "line": 9530}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 14, "line": 9530}, "start": {"column": 13, "line": 9530}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 26, "line": 9546}, "start": {"column": 24, "line": 9546}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 9547}, "start": {"column": 18, "line": 9547}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 9547}, "start": {"column": 18, "line": 9547}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9586}, "start": {"column": 19, "line": 9586}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9586}, "start": {"column": 19, "line": 9586}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9587}, "start": {"column": 19, "line": 9587}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9587}, "start": {"column": 19, "line": 9587}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 9587}, "start": {"column": 28, "line": 9587}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9590}, "start": {"column": 19, "line": 9590}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9590}, "start": {"column": 19, "line": 9590}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 9590}, "start": {"column": 28, "line": 9590}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 9595}, "start": {"column": 20, "line": 9595}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 9595}, "start": {"column": 41, "line": 9595}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 9599}, "start": {"column": 28, "line": 9599}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 57, "line": 9599}, "start": {"column": 55, "line": 9599}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 57, "line": 9599}, "start": {"column": 55, "line": 9599}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 9605}, "start": {"column": 21, "line": 9605}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 9605}, "start": {"column": 21, "line": 9605}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 39, "line": 9605}, "start": {"column": 36, "line": 9605}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 57, "line": 9606}, "start": {"column": 56, "line": 9606}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 62, "line": 9606}, "start": {"column": 61, "line": 9606}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 9610}, "start": {"column": 21, "line": 9610}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 9610}, "start": {"column": 21, "line": 9610}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 9610}, "start": {"column": 35, "line": 9610}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 43, "line": 9610}, "start": {"column": 40, "line": 9610}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 25, "line": 9611}, "start": {"column": 23, "line": 9611}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 53, "line": 9611}, "start": {"column": 52, "line": 9611}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 32, "line": 9612}, "start": {"column": 31, "line": 9612}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 37, "line": 9612}, "start": {"column": 36, "line": 9612}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 20, "line": 9640}, "start": {"column": 19, "line": 9640}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 34, "line": 9640}, "start": {"column": 33, "line": 9640}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 34, "line": 9640}, "start": {"column": 33, "line": 9640}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 32, "line": 9641}, "start": {"column": 31, "line": 9641}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 47, "line": 9646}, "start": {"column": 46, "line": 9646}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 47, "line": 9646}, "start": {"column": 46, "line": 9646}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 61, "line": 9646}, "start": {"column": 60, "line": 9646}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 33, "line": 9647}, "start": {"column": 32, "line": 9647}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 24, "line": 9655}, "start": {"column": 23, "line": 9655}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 24, "line": 9655}, "start": {"column": 23, "line": 9655}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 21, "line": 9657}, "start": {"column": 20, "line": 9657}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 21, "line": 9657}, "start": {"column": 20, "line": 9657}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 22, "line": 9663}, "start": {"column": 21, "line": 9663}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 22, "line": 9663}, "start": {"column": 21, "line": 9663}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 33, "line": 9663}, "start": {"column": 30, "line": 9663}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 9667}, "start": {"column": 34, "line": 9667}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 9668}, "start": {"column": 16, "line": 9668}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 9668}, "start": {"column": 16, "line": 9668}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 9668}, "start": {"column": 25, "line": 9668}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 17, "line": 9671}, "start": {"column": 16, "line": 9671}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 17, "line": 9671}, "start": {"column": 16, "line": 9671}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 28, "line": 9671}, "start": {"column": 25, "line": 9671}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 9676}, "start": {"column": 30, "line": 9676}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9677}, "start": {"column": 19, "line": 9677}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9677}, "start": {"column": 19, "line": 9677}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 9677}, "start": {"column": 28, "line": 9677}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 9680}, "start": {"column": 19, "line": 9680}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 9680}, "start": {"column": 19, "line": 9680}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 9680}, "start": {"column": 28, "line": 9680}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 9703}, "start": {"column": 11, "line": 9703}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 12, "line": 9705}, "start": {"column": 11, "line": 9705}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 12, "line": 9705}, "start": {"column": 11, "line": 9705}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 13, "line": 9707}, "start": {"column": 11, "line": 9707}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 9717}, "start": {"column": 12, "line": 9717}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 9717}, "start": {"column": 12, "line": 9717}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 18, "line": 9717}, "start": {"column": 17, "line": 9717}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 28, "line": 9719}, "start": {"column": 27, "line": 9719}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 33, "line": 9719}, "start": {"column": 32, "line": 9719}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 14, "line": 9721}, "start": {"column": 12, "line": 9721}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 14, "line": 9721}, "start": {"column": 12, "line": 9721}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 9725}, "start": {"column": 12, "line": 9725}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 9730}, "start": {"column": 12, "line": 9730}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 14, "line": 9735}, "start": {"column": 12, "line": 9735}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 18, "line": 9742}, "start": {"column": 16, "line": 9742}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 22, "line": 9744}, "start": {"column": 20, "line": 9744}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 22, "line": 9744}, "start": {"column": 20, "line": 9744}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 42, "line": 9744}, "start": {"column": 40, "line": 9744}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 57, "line": 9744}, "start": {"column": 54, "line": 9744}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 9746}, "start": {"column": 12, "line": 9746}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 9746}, "start": {"column": 12, "line": 9746}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 9747}, "start": {"column": 18, "line": 9747}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 14, "line": 9756}, "start": {"column": 12, "line": 9756}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 14, "line": 9756}, "start": {"column": 12, "line": 9756}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 19, "line": 9756}, "start": {"column": 18, "line": 9756}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 15, "line": 9759}, "start": {"column": 13, "line": 9759}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 20, "line": 9761}, "start": {"column": 18, "line": 9761}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 20, "line": 9763}, "start": {"column": 18, "line": 9763}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 20, "line": 9763}, "start": {"column": 18, "line": 9763}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 9763}, "start": {"column": 38, "line": 9763}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 55, "line": 9763}, "start": {"column": 52, "line": 9763}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 11, "line": 9765}, "start": {"column": 10, "line": 9765}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 11, "line": 9765}, "start": {"column": 10, "line": 9765}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 9766}, "start": {"column": 16, "line": 9766}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 12, "line": 9793}, "start": {"column": 11, "line": 9793}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 12, "line": 9793}, "start": {"column": 11, "line": 9793}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 27, "line": 9800}, "start": {"column": 25, "line": 9800}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 13, "line": 9808}, "start": {"column": 11, "line": 9808}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 13, "line": 9808}, "start": {"column": 11, "line": 9808}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 17, "line": 9808}, "start": {"column": 16, "line": 9808}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 17, "line": 9809}, "start": {"column": 16, "line": 9809}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_mul_to_div", "location": {"end": {"column": 21, "line": 9809}, "start": {"column": 20, "line": 9809}}, "mutatorName": "Replaced * with /", "replacement": "/", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 9813}, "start": {"column": 14, "line": 9813}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 22, "line": 9813}, "start": {"column": 20, "line": 9813}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 22, "line": 9813}, "start": {"column": 20, "line": 9813}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 25, "line": 9815}, "start": {"column": 23, "line": 9815}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 25, "line": 9815}, "start": {"column": 23, "line": 9815}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 14, "line": 9817}, "start": {"column": 13, "line": 9817}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 41, "line": 9818}, "start": {"column": 40, "line": 9818}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 41, "line": 9818}, "start": {"column": 40, "line": 9818}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 9838}, "start": {"column": 18, "line": 9838}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 9838}, "start": {"column": 18, "line": 9838}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 9842}, "start": {"column": 21, "line": 9842}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 9843}, "start": {"column": 12, "line": 9843}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 9843}, "start": {"column": 12, "line": 9843}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 12, "line": 9869}, "start": {"column": 11, "line": 9869}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 18, "line": 9869}, "start": {"column": 17, "line": 9869}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 18, "line": 9869}, "start": {"column": 17, "line": 9869}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 15, "line": 9873}, "start": {"column": 14, "line": 9873}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 22, "line": 9873}, "start": {"column": 20, "line": 9873}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 22, "line": 9873}, "start": {"column": 20, "line": 9873}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 45, "line": 9875}, "start": {"column": 43, "line": 9875}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 36, "line": 9883}, "start": {"column": 34, "line": 9883}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 36, "line": 9883}, "start": {"column": 34, "line": 9883}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 19, "line": 9889}, "start": {"column": 18, "line": 9889}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 19, "line": 9889}, "start": {"column": 18, "line": 9889}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 23, "line": 9893}, "start": {"column": 21, "line": 9893}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 13, "line": 9894}, "start": {"column": 12, "line": 9894}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 13, "line": 9894}, "start": {"column": 12, "line": 9894}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 37, "line": 9901}, "start": {"column": 35, "line": 9901}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 37, "line": 9901}, "start": {"column": 35, "line": 9901}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_div_to_mul", "location": {"end": {"column": 44, "line": 9922}, "start": {"column": 43, "line": 9922}}, "mutatorName": "Replaced / with *", "replacement": "*", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 22, "line": 9947}, "start": {"column": 20, "line": 9947}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 43, "line": 9947}, "start": {"column": 41, "line": 9947}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 22, "line": 9950}, "start": {"column": 20, "line": 9950}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 34, "line": 9950}, "start": {"column": 32, "line": 9950}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 10573}, "start": {"column": 19, "line": 10573}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 10573}, "start": {"column": 19, "line": 10573}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 31, "line": 10573}, "start": {"column": 28, "line": 10573}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 15, "line": 10600}, "start": {"column": 4, "line": 10600}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 61, "line": 10601}, "start": {"column": 59, "line": 10601}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 61, "line": 10610}, "start": {"column": 59, "line": 10610}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 36, "line": 10613}, "start": {"column": 34, "line": 10613}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 59, "line": 10631}, "start": {"column": 57, "line": 10631}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 10648}, "start": {"column": 29, "line": 10648}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 40, "line": 10686}, "start": {"column": 38, "line": 10686}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 59, "line": 10697}, "start": {"column": 57, "line": 10697}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 30, "line": 10714}, "start": {"column": 29, "line": 10714}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 30, "line": 10756}, "start": {"column": 29, "line": 10756}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 30, "line": 10756}, "start": {"column": 29, "line": 10756}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 38, "line": 10761}, "start": {"column": 37, "line": 10761}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 10766}, "start": {"column": 35, "line": 10766}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 10769}, "start": {"column": 15, "line": 10769}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 10769}, "start": {"column": 15, "line": 10769}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 34, "line": 10769}, "start": {"column": 32, "line": 10769}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 20, "line": 10772}, "start": {"column": 19, "line": 10772}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 20, "line": 10772}, "start": {"column": 19, "line": 10772}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 36, "line": 10793}, "start": {"column": 35, "line": 10793}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 16, "line": 10796}, "start": {"column": 15, "line": 10796}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 16, "line": 10796}, "start": {"column": 15, "line": 10796}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 34, "line": 10796}, "start": {"column": 32, "line": 10796}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 48, "line": 10805}, "start": {"column": 47, "line": 10805}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 62, "line": 10805}, "start": {"column": 61, "line": 10805}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 78, "line": 10805}, "start": {"column": 76, "line": 10805}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 78, "line": 10805}, "start": {"column": 76, "line": 10805}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 10807}, "start": {"column": 22, "line": 10807}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 61, "line": 10808}, "start": {"column": 59, "line": 10808}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 67, "line": 10808}, "start": {"column": 66, "line": 10808}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ge_to_gt", "location": {"end": {"column": 21, "line": 10817}, "start": {"column": 19, "line": 10817}}, "mutatorName": "Replaced >= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_ge_to_lt", "location": {"end": {"column": 21, "line": 10817}, "start": {"column": 19, "line": 10817}}, "mutatorName": "Replaced >= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 16, "line": 10819}, "start": {"column": 14, "line": 10819}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 17, "line": 10820}, "start": {"column": 15, "line": 10820}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 10820}, "start": {"column": 22, "line": 10820}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 12, "line": 10822}, "start": {"column": 11, "line": 10822}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 12, "line": 10822}, "start": {"column": 11, "line": 10822}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_add_to_sub", "location": {"end": {"column": 42, "line": 10827}, "start": {"column": 41, "line": 10827}}, "mutatorName": "Replaced + with -", "replacement": "-", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 13, "line": 10829}, "start": {"column": 11, "line": 10829}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 13, "line": 10829}, "start": {"column": 11, "line": 10829}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_eq_to_ne", "location": {"end": {"column": 19, "line": 10832}, "start": {"column": 17, "line": 10832}}, "mutatorName": "Replaced == with !=", "replacement": "!=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 25, "line": 10832}, "start": {"column": 24, "line": 10832}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_pre_inc_to_pre_dec", "location": {"end": {"column": 14, "line": 10834}, "start": {"column": 7, "line": 10834}}, "mutatorName": "Replaced ++x with --x", "replacement": "--", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 43, "line": 10836}, "start": {"column": 42, "line": 10836}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 23, "line": 10837}, "start": {"column": 22, "line": 10837}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 29, "line": 10837}, "start": {"column": 28, "line": 10837}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 26, "line": 10838}, "start": {"column": 25, "line": 10838}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 10848}, "start": {"column": 15, "line": 10848}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 10848}, "start": {"column": 15, "line": 10848}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 28, "line": 10863}, "start": {"column": 27, "line": 10863}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 28, "line": 10863}, "start": {"column": 27, "line": 10863}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 54, "line": 10863}, "start": {"column": 52, "line": 10863}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 43, "line": 10865}, "start": {"column": 42, "line": 10865}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 52, "line": 10865}, "start": {"column": 50, "line": 10865}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 16, "line": 10867}, "start": {"column": 15, "line": 10867}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 16, "line": 10867}, "start": {"column": 15, "line": 10867}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 15, "line": 10871}, "start": {"column": 14, "line": 10871}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 15, "line": 10871}, "start": {"column": 14, "line": 10871}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 32, "line": 10873}, "start": {"column": 30, "line": 10873}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_le_to_gt", "location": {"end": {"column": 25, "line": 10887}, "start": {"column": 23, "line": 10887}}, "mutatorName": "Replaced <= with >", "replacement": ">", "status": "Killed"}, {"id": "cxx_le_to_lt", "location": {"end": {"column": 25, "line": 10887}, "start": {"column": 23, "line": 10887}}, "mutatorName": "Replaced <= with <", "replacement": "<", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 51, "line": 10889}, "start": {"column": 50, "line": 10889}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 13, "line": 10894}, "start": {"column": 12, "line": 10894}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 13, "line": 10894}, "start": {"column": 12, "line": 10894}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 31, "line": 10894}, "start": {"column": 29, "line": 10894}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 19, "line": 10896}, "start": {"column": 18, "line": 10896}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 19, "line": 10896}, "start": {"column": 18, "line": 10896}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 45, "line": 10896}, "start": {"column": 43, "line": 10896}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 10903}, "start": {"column": 14, "line": 10903}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 10903}, "start": {"column": 14, "line": 10903}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_lt_to_ge", "location": {"end": {"column": 21, "line": 10905}, "start": {"column": 20, "line": 10905}}, "mutatorName": "Replaced < with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_lt_to_le", "location": {"end": {"column": 21, "line": 10905}, "start": {"column": 20, "line": 10905}}, "mutatorName": "Replaced < with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_sub_to_add", "location": {"end": {"column": 52, "line": 10920}, "start": {"column": 51, "line": 10920}}, "mutatorName": "Replaced - with +", "replacement": "+", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 69, "line": 10920}, "start": {"column": 67, "line": 10920}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}, {"id": "cxx_gt_to_ge", "location": {"end": {"column": 15, "line": 10925}, "start": {"column": 14, "line": 10925}}, "mutatorName": "Replaced > with >=", "replacement": ">=", "status": "Killed"}, {"id": "cxx_gt_to_le", "location": {"end": {"column": 15, "line": 10925}, "start": {"column": 14, "line": 10925}}, "mutatorName": "Replaced > with <=", "replacement": "<=", "status": "Killed"}, {"id": "cxx_ne_to_eq", "location": {"end": {"column": 33, "line": 10925}, "start": {"column": 31, "line": 10925}}, "mutatorName": "Replaced != with ==", "replacement": "==", "status": "Killed"}], "source": "/* grep.c - main driver file for grep.\n   Copyright (C) 1992 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n   Written July 1992 by Mike Haertel.  */\n\n/* I added a series define from makefile here in order to run cfe */\n#define GREP 1\n#define STDC_HEADERS 1\n#define HAVE_STRING_H 1\n#define HAVE_SYS_PARAM_H 1\n#define HAVE_UNISTD_H 1\n#define HAVE_ALLOCA_H 1\n#define HAVE_GETPAGESIZE 1\n#define HAVE_MEMCHR 1\n#define HAVE_STRERROR 1\n#define HAVE_VALLOC 1\n#define HAVE_WORKING_MMAP 1\n/*** end of cfe purpose **/\n\n#include <errno.h>\n#include <stdio.h>\n\n/*******IMPORTANT CHANGE for let stderr redirect to a file *******/\n#undef stderr\n#define stderr stdout\n/******* FINISH IMPORTANT CHANGE *********/\n\n#ifndef errno\nextern int errno;\n#endif\n\n#ifdef STDC_HEADERS\n#include <stdlib.h>\n#define flag_stdlib 1\n#else\n#include <sys/types.h>\n#define flag_systypes 1\nextern char *malloc(), *realloc();\nextern void free();\n#endif\n\n#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)\n#include <string.h>\n#define flag_string 1\n#ifdef NEED_MEMORY_H\n#include <memory.h>\n#define flag_memory 1\n#endif\n#else\n#include <strings.h>\n#define flag_strings 1\n#ifdef __STDC__\nextern void *memchr();\n#else\nextern char *memchr();\n#endif\n#define strrchr rindex\n#endif\n\n#ifdef HAVE_UNISTD_H\n#if flag_systypes==0\n#include <sys/types.h>\n#define flag_systypes 1\n#endif\n#include <fcntl.h>\n#include <unistd.h>\n#else\n#define O_RDONLY 0\nextern int open(), read(), close();\n#endif\n\n#include \"getpagesize.h\"\n#include \"grep.h\"\n\n#undef MAX\n#define MAX(A,B) ((A) > (B) ? (A) : (B))\n\n/* Provide missing ANSI features if necessary. */\n\n#ifndef HAVE_STRERROR\nextern int sys_nerr;\nextern char *sys_errlist[];\n#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : \"bogus error number\")\n#endif\n\n#ifndef HAVE_MEMCHR\n#ifdef __STDC__\n#define VOID void\n#else\n#define VOID char\n#endif\nVOID *\nmemchr(vp, c, n)\n     VOID *vp;\n     int c;\n     size_t n;\n{\n  unsigned char *p;\n\n  for (p = (unsigned char *) vp; n--; ++p)\n    if (*p == c)\n      return (VOID *) p;\n  return 0;\n}\n#endif\n    \n/* Define flags declared in grep.h. */\nchar *matcher;\nint match_icase;\nint match_words;\nint match_lines;\n\n/* Functions we'll use to search. */\nstatic void (*compile)();\nstatic char *(*execute)();\n\n/* For error messages. */\nstatic char *prog;\nstatic char *filename;\nstatic int errseen;\n\n/* Print a message and possibly an error string.  Remember\n   that something awful happened. */\nstatic void\nerror(mesg, errnum)\n#ifdef __STDC__\n     const\n#endif\n     char *mesg;\n     int errnum;\n{\n  if (errnum)\n    fprintf(stderr, \"%s: %s: %s\\n\", prog, mesg, strerror(errnum));\n  else\n    fprintf(stderr, \"%s: %s\\n\", prog, mesg);\n  errseen = 1;\n}\n\n/* Like error(), but die horribly after printing. */\nvoid\nfatal(mesg, errnum)\n#ifdef __STDC__\n     const\n#endif\n     char *mesg;\n     int errnum;\n{\n  error(mesg, errnum);\n  exit(2);\n}\n\n/* Interface to handle errors and fix library lossage. */\nchar *\nxmalloc(size)\n     size_t size;\n{\n  char *result;\n\n  result = malloc(size);\n  if (size && !result)\n    fatal(\"memory exhausted\", 0);\n  return result;\n}\n\n/* Interface to handle errors and fix some library lossage. */\nchar *\nxrealloc(ptr, size)\n     char *ptr;\n     size_t size;\n{\n  char *result;\n\n  if (ptr)\n    result = realloc(ptr, size);\n  else\n    result = malloc(size);\n  if (size && !result)\n    fatal(\"memory exhausted\", 0);\n  return result;\n}\n\n#if !defined(HAVE_VALLOC)\n#define valloc malloc\n#else\n#ifdef __STDC__\nextern void *valloc(size_t);\n#else\nextern char *valloc();\n#endif\n#endif\n\n/* Hairy buffering mechanism for grep.  The intent is to keep\n   all reads aligned on a page boundary and multiples of the\n   page size. */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufsalloc;\t/* Allocated size of buffer save region. */\nstatic size_t bufalloc;\t\t/* Total buffer size. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\n\n#if defined(HAVE_WORKING_MMAP)\n#if flag_systypes==0\n#include <sys/types.h>\n#define flag_systypes 1\n#endif\n#include <sys/stat.h>\n#include <sys/mman.h>\n\nstatic int bufmapped;\t\t/* True for ordinary files. */\nstatic struct stat bufstat;\t/* From fstat(). */\nstatic off_t bufoffset;\t\t/* What read() normally remembers. */\n#endif\n\n/* Reset the buffer for a new file.  Initialize\n   on the first time through. */\nvoid\nreset(fd)\n     int fd;\n{\n  static int initialized;\n\n  if (!initialized)\n    {\n      initialized = 1;\n#ifndef BUFSALLOC\n      bufsalloc = MAX(8192, getpagesize());\n#else\n      bufsalloc = BUFSALLOC;\n#endif\n      bufalloc = 5 * bufsalloc;\n      /* The 1 byte of overflow is a kludge for dfaexec(), which\n\t inserts a sentinel newline at the end of the buffer\n\t being searched.  There's gotta be a better way... */\n      buffer = valloc(bufalloc + 1);\n      if (!buffer)\n\tfatal(\"memory exhausted\", 0);\n      bufbeg = buffer;\n      buflim = buffer;\n    }\n  bufdesc = fd;\n#if defined(HAVE_WORKING_MMAP)\n  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))\n    bufmapped = 0;\n  else\n    {\n      bufmapped = 1;\n      bufoffset = lseek(fd, 0, 1);\n    }\n#endif\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return count of new stuff. */\nstatic int\nfillbuf(save)\n     size_t save;\n{\n  char *nbuffer, *dp, *sp;\n  int cc;\n#if defined(HAVE_WORKING_MMAP)\n  caddr_t maddr;\n#endif\n  static int pagesize;\n\n  if (pagesize == 0 && (pagesize = getpagesize()) == 0)\n    abort();\n\n  if (save > bufsalloc)\n    {\n      while (save > bufsalloc)\n\tbufsalloc *= 2;\n      bufalloc = 5 * bufsalloc;\n      nbuffer = valloc(bufalloc + 1);\n      if (!nbuffer)\n\tfatal(\"memory exhausted\", 0);\n    }\n  else\n    nbuffer = buffer;\n\n  sp = buflim - save;\n  dp = nbuffer + bufsalloc - save;\n  bufbeg = dp;\n  while (save--)\n    *dp++ = *sp++;\n\n  /* We may have allocated a new, larger buffer.  Since\n     there is no portable vfree(), we just have to forget\n     about the old one.  Sorry. */\n  buffer = nbuffer;\n\n#if defined(HAVE_WORKING_MMAP)\n  if (bufmapped && bufoffset % pagesize == 0\n      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)\n    {\n      maddr = buffer + bufsalloc;\n      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,\n\t\t   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);\n      if (maddr == (caddr_t) -1)\n\t{\n\t  fprintf(stderr, \"%s: warning: %s: %s\\n\", filename,\n\t\t  strerror(errno));\n\t  goto tryread;\n\t}\n#if 0\n      /* You might thing this (or MADV_WILLNEED) would help,\n\t but it doesn't, at least not on a Sun running 4.1.\n\t In fact, it actually slows us down about 30%! */\n      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);\n#endif\n      cc = bufalloc - bufsalloc;\n      bufoffset += cc;\n    }\n  else\n    {\n    tryread:\n      /* We come here when we're not going to use mmap() any more.\n\t Note that we need to synchronize the file offset the\n\t first time through. */\n      if (bufmapped)\n\t{\n\t  bufmapped = 0;\n\t  lseek(bufdesc, bufoffset, 0);\n\t}\n      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);\n    }\n#else\n  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);\n#endif\n  if (cc > 0)\n    buflim = buffer + bufsalloc + cc;\n  else\n    buflim = buffer + bufsalloc;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n\n/* Internal variables to keep track of byte count, context, etc. */\nstatic size_t totalcc;\t\t/* Total character count before bufbeg. */\nstatic char *lastnl;\t\t/* Pointer after last newline counted. */\nstatic char *lastout;\t\t/* Pointer after last character output;\n\t\t\t\t   NULL if no character has been output\n\t\t\t\t   or if it's conceptually before bufbeg. */\nstatic size_t totalnl;\t\t/* Total newline count before lastnl. */\nstatic int pending;\t\t/* Pending lines of output. */\n\nstatic void\nnlscan(lim)\n     char *lim;\n{\n  char *beg;\n\n  for (beg = lastnl; beg < lim; ++beg)\n    if (*beg == '\\n')\n      ++totalnl;\n  lastnl = beg;\n}\n\nstatic void\nprline(beg, lim, sep)\n     char *beg;\n     char *lim;\n     char sep;\n{\n  if (out_file)\n    printf(\"%s%c\", filename, sep);\n  if (out_line)\n    {\n      nlscan(beg);\n      printf(\"%d%c\", ++totalnl, sep);\n      lastnl = lim;\n    }\n  if (out_byte)\n    printf(\"%lu%c\", totalcc + (beg - bufbeg), sep);\n  fwrite(beg, 1, lim - beg, stdout);\n  if (ferror(stdout))\n    error(\"writing output\", errno);\n  lastout = lim;\n}\n\n/* Print pending lines of trailing context prior to LIM. */\nstatic void\nprpending(lim)\n     char *lim;\n{\n  char *nl;\n\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      --pending;\n      if ((nl = memchr(lastout, '\\n', lim - lastout)) != 0)\n\t++nl;\n      else\n\tnl = lim;\n      prline(lastout, nl, '-');\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM. */\nstatic void\nprtext(beg, lim, nlinesp)\n     char *beg;\n     char *lim;\n     int *nlinesp;\n{\n  static int used;\t\t/* avoid printing \"--\" before any output */\n  char *bp, *p, *nl;\n  int i, n;\n\n  if (!out_quiet && pending > 0)\n    prpending(beg);\n\n  p = beg;\n\n  if (!out_quiet)\n    {\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n\tif (p > bp)\n\t  do\n\t    --p;\n\t  while (p > bp && p[-1] != '\\n');\n\n      /* We only print the \"--\" separator if our output is\n\t discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout)\n\tputs(\"--\");\n\n      while (p < beg)\n\t{\n\t  nl = memchr(p, '\\n', beg - p);\n\t  prline(p, nl + 1, '-');\n\t  p = nl + 1;\n\t}\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim; ++n)\n\t{\n\t  if ((nl = memchr(p, '\\n', lim - p)) != 0)\n\t    ++nl;\n\t  else\n\t    nl = lim;\n\t  if (!out_quiet)\n\t    prline(p, nl, ':');\n\t  p = nl;\n\t}\n      *nlinesp = n;\n    }\n  else\n    if (!out_quiet)\n      prline(beg, lim, ':');\n\n  pending = out_after;\n  used = 1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf(beg, lim)\n     char *beg;\n     char *lim;\n{\n  int nlines, n;\n  register char *p, *b;\n  char *endp;\n\n  nlines = 0;\n  p = beg;\n  while ((b = (*execute)(p, lim - p, &endp)) != 0)\n    {\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim && ((b > beg && b[-1] == '\\n') || b == beg))\n\tbreak;\n      if (!out_invert)\n\t{\n\t  prtext(b, endp, (int *) 0);\n\t  nlines += 1;\n\t}\n      else if (p < b)\n\t{\n\t  prtext(p, b, &n);\n\t  nlines += n;\n\t}\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext(p, lim, &n);\n      nlines += n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Return a count of lines printed. */\nstatic int\ngrep(fd)\n     int fd;\n{\n  int nlines, i;\n  size_t residue, save;\n  char *beg, *lim;\n\n  reset(fd);\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  for (;;)\n    {\n      if (fillbuf(save) < 0)\n\t{\n\t  error(filename, errno);\n\t  return nlines;\n\t}\n      lastnl = bufbeg;\n      if (lastout)\n\tlastout = bufbeg;\n      if (buflim - bufbeg == save)\n\tbreak;\n      beg = bufbeg + save - residue;\n      for (lim = buflim; lim > beg && lim[-1] != '\\n'; --lim)\n\t;\n      residue = buflim - lim;\n      if (beg < lim)\n\t{\n\t  nlines += grepbuf(beg, lim);\n\t  if (pending)\n\t    prpending(lim);\n\t}\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n\t{\n\t  ++i;\n\t  do\n\t    --beg;\n\t  while (beg > bufbeg && beg[-1] != '\\n');\n\t}\n      if (beg != lastout)\n\tlastout = 0;\n      save = residue + lim - beg;\n      totalcc += buflim - bufbeg - save;\n      if (out_line)\n\tnlscan(beg);\n    }\n  if (residue)\n    {\n      nlines += grepbuf(bufbeg + save - residue, buflim);\n      if (pending)\n\tprpending(buflim);\n    }\n  return nlines;\n}\n\nstatic char version[] = \"GNU grep version 2.0\";\n\n#define USAGE \\\n  \"usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\\n\"\n\nstatic void\nusage()\n{\n  fprintf(stderr, USAGE, prog);\n  exit(2);\n}\n\n/* Go through the matchers vector and look for the specified matcher.\n   If we find it, install it in compile and execute, and return 1.  */\nint\nsetmatcher(name)\n     char *name;\n{\n  int i;\n\n  for (i = 0; matchers[i].name; ++i)\n    if (strcmp(name, matchers[i].name) == 0)\n      {\n\tcompile = matchers[i].compile;\n\texecute = matchers[i].execute;\n\treturn 1;\n      }\n  return 0;\n}  \n\nint\nmain(argc, argv)\n     int argc;\n     char *argv[];\n{\n  char *keys;\n  size_t keycc, oldcc, keyalloc;\n  int keyfound, count_matches, no_filenames, list_files, suppress_errors;\n  int opt, cc, desc, count, status;\n  FILE *fp;\n  extern char *optarg;\n  extern int optind;\n  /* add this line for diff between *.c and *.int.c */\n  argv[0] = \"target\";\n\n  prog = argv[0];\n  if (prog && strrchr(prog, '/'))\n    prog = strrchr(prog, '/') + 1;\n\n  keys = NULL;\n  keycc = 0;\n  keyfound = 0;\n  count_matches = 0;\n  no_filenames = 0;\n  list_files = 0;\n  suppress_errors = 0;\n  matcher = NULL;\n\n  while ((opt = getopt(argc, argv, \"0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy\"))\n\t != EOF)\n    switch (opt)\n      {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n\tout_before = 10 * out_before + opt - '0';\n\tout_after = 10 * out_after + opt - '0';\n\tbreak;\n      case 'A':\n\tout_after = atoi(optarg);\n\tif (out_after < 0)\n\t  usage();\n\tbreak;\n      case 'B':\n\tout_before = atoi(optarg);\n\tif (out_before < 0)\n\t  usage();\n\tbreak;\n      case 'C':\n\tout_before = out_after = 2;\n\tbreak;\n      case 'E':\n\tif (matcher && strcmp(matcher, \"egrep\") != 0)\n\t  fatal(\"you may specify only one of -E, -F, or -G\", 0);\n\tmatcher = \"posix-egrep\";\n\tbreak;\n      case 'F':\n\tif (matcher && strcmp(matcher, \"fgrep\") != 0)\n\t  fatal(\"you may specify only one of -E, -F, or -G\", 0);;\n\tmatcher = \"fgrep\";\n\tbreak;\n      case 'G':\n\tif (matcher && strcmp(matcher, \"grep\") != 0)\n\t  fatal(\"you may specify only one of -E, -F, or -G\", 0);\n\tmatcher = \"grep\";\n\tbreak;\n      case 'V':\n\tfprintf(stderr, \"%s\\n\", version);\n\tbreak;\n      case 'X':\n\tif (matcher)\n\t  fatal(\"matcher already specified\", 0);\n\tmatcher = optarg;\n\tbreak;\n      case 'b':\n\tout_byte = 1;\n\tbreak;\n      case 'c':\n\tout_quiet = 1;\n\tcount_matches = 1;\n\tbreak;\n      case 'e':\n\tcc = strlen(optarg);\n\tkeys = xrealloc(keys, keycc + cc + 1);\n\tif (keyfound)\n\t  keys[keycc++] = '\\n';\n\tstrcpy(&keys[keycc], optarg);\n\tkeycc += cc;\n\tkeyfound = 1;\n\tbreak;\n      case 'f':\n\tfp = strcmp(optarg, \"-\") != 0 ? fopen(optarg, \"r\") : stdin;\n\tif (!fp)\n\t  fatal(optarg, errno);\n\tfor (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)\n\t  ;\n\tkeys = xrealloc(keys, keyalloc);\n\toldcc = keycc;\n\tif (keyfound)\n\t  keys[keycc++] = '\\n';\n\twhile (!feof(fp)\n\t       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)\n\t  {\n\t    keycc += cc;\n\t    if (keycc == keyalloc)\n\t      keys = xrealloc(keys, keyalloc *= 2);\n\t  }\n\tif (fp != stdin)\n\t  fclose(fp);\n\t/* Nuke the final newline to avoid matching a null string. */\n\tif (keycc - oldcc > 0 && keys[keycc - 1] == '\\n')\n\t  --keycc;\n\tkeyfound = 1;\n\tbreak;\n      case 'h':\n\tno_filenames = 1;\n\tbreak;\n      case 'i':\n      case 'y':\t\t\t/* For old-timers . . . */\n\tmatch_icase = 1;\n\tbreak;\n      case 'L':\n\t/* Like -l, except list files that don't contain matches.\n\t   Inspired by the same option in Hume's gre. */\n\tout_quiet = 1;\n\tlist_files = -1;\n\tbreak;\n      case 'l':\n\tout_quiet = 1;\n\tlist_files = 1;\n\tbreak;\n      case 'n':\n\tout_line = 1;\n\tbreak;\n      case 'q':\n\tout_quiet = 1;\n\tbreak;\n      case 's':\n\tsuppress_errors = 1;\n\tbreak;\n      case 'v':\n\tout_invert = 1;\n\tbreak;\n      case 'w':\n\tmatch_words = 1;\n\tbreak;\n      case 'x':\n\tmatch_lines = 1;\n\tbreak;\n      default:\n\tusage();\n\tbreak;\n      }\n\n  if (!keyfound)\n    if (optind < argc)\n      {\n\tkeys = argv[optind++];\n\tkeycc = strlen(keys);\n      }\n    else\n      usage();\n\n  if (!matcher)\n    matcher = prog;\n\n  if (!setmatcher(matcher) && !setmatcher(\"default\"))\n    abort();\n\n  (*compile)(keys, keycc);\n\n  if (argc - optind > 1 && !no_filenames)\n    out_file = 1;\n\n  status = 1;\n\n  if (optind < argc)\n    while (optind < argc)\n      {\n\tdesc = strcmp(argv[optind], \"-\") ? open(argv[optind], O_RDONLY) : 0;\n\tif (desc < 0)\n\t  {\n\t    if (!suppress_errors)\n\t      error(argv[optind], errno);\n\t  }\n\telse\n\t  {\n\t    filename = desc == 0 ? \"(standard input)\" : argv[optind];\n\t    count = grep(desc);\n\t    if (count_matches)\n\t      {\n\t\tif (out_file)\n\t\t  printf(\"%s:\", filename);\n\t\tprintf(\"%d\\n\", count);\n\t      }\n\t    if (count)\n\t      {\n\t\tstatus = 0;\n\t\tif (list_files == 1)\n\t\t  printf(\"%s\\n\", filename);\n\t      }\n\t    else if (list_files == -1)\n\t      printf(\"%s\\n\", filename);\n\t  }\n\tif (desc != 0)\n\t  close(desc);\n\t++optind;\n      }\n  else\n    {\n      filename = \"(standard input)\";\n      count = grep(0);\n      if (count_matches)\n\tprintf(\"%d\\n\", count);\n      if (count)\n\t{\n\t  status = 0;\n\t  if (list_files == 1)\n\t    printf(\"(standard input)\\n\");\n\t}\n      else if (list_files == -1)\n\tprintf(\"(standard input)\\n\");\n    }\n\n  exit(errseen ? 2 : status);\n}\n/* Getopt for GNU.\n   NOTE: getopt is now part of the C library, so if you don't know what\n   \"Keep this file name-space clean\" means, talk to roland@gnu.ai.mit.edu\n   before changing it!\n\n   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993\n   \tFree Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\f\n/* NOTE!!!  AIX requires this to be the first thing in the file.\n   Do not put ANYTHING before it!  */\n#if !defined (__GNUC__) && defined (_AIX)\n #pragma alloca\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#define flag_config 1\n#endif\n\n#ifdef __GNUC__\n#define alloca __builtin_alloca\n#else /* not __GNUC__ */\n#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))\n#include <alloca.h>\n#define flag_alloca 1\n#else\n#ifndef _AIX\nchar *alloca ();\n#endif\n#endif /* alloca.h */\n#endif /* not __GNUC__ */\n\n#if !__STDC__ && !defined(const) && IN_GCC\n#define const\n#endif\n\n/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */\n#ifndef _NO_PROTO\n#define _NO_PROTO\n#endif\n\n/*#include <stdio.h> */\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#if defined (_LIBC) || !defined (__GNU_LIBRARY__)\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef\t__GNU_LIBRARY__\n#undef\talloca\n/* Don't include stdlib.h for non-GNU C libraries because some of them\n   contain conflicting prototypes for getopt.  */\n#if flag_stdlib==0   \n#include <stdlib.h>\n#define flag_stdlib 1\n#endif\n#else\t/* Not GNU C library.  */\n#define\t__alloca\talloca\n#endif\t/* GNU C library.  */\n\n/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a\n   long-named option.  Because this is not POSIX.2 compliant, it is\n   being phased out.  */\n/* #define GETOPT_COMPAT */\n\n/* This version of `getopt' appears to the caller like standard Unix `getopt'\n   but it behaves differently for the user, since it allows the user\n   to intersperse the options with the other arguments.\n\n   As `getopt' works, it permutes the elements of ARGV so that,\n   when it is done, all the options precede everything else.  Thus\n   all application programs are extended to handle flexible argument order.\n\n   Setting the environment variable POSIXLY_CORRECT disables permutation.\n   Then the behavior is completely standard.\n\n   GNU application programs can use a third alternative mode in which\n   they can distinguish the relative order of options and other arguments.  */\n\n#include \"getopt.h\"\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nchar *optarg = 0;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns EOF, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\n/* XXX 1003.2 says this must be 1 before any call.  */\nint optind = 0;\n\n/* The next char to be scanned in the option-element\n   in which the last option character we returned was found.\n   This allows us to pick up the scan where we left off.\n\n   If this is zero, or a null string, it means resume the scan\n   by advancing to the next ARGV-element.  */\n\nstatic char *nextchar;\n\n/* Callers store zero here to inhibit the error message\n   for unrecognized options.  */\n\nint opterr = 1;\n\n/* Set to an option character which was unrecognized.\n   This must be initialized on some systems to avoid linking in the\n   system's own getopt implementation.  */\n\nint optopt = '?';\n\n/* Describe how to deal with options that follow non-option ARGV-elements.\n\n   If the caller did not specify anything,\n   the default is REQUIRE_ORDER if the environment variable\n   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n\n   REQUIRE_ORDER means don't recognize them as options;\n   stop option processing when the first non-option is seen.\n   This is what Unix does.\n   This mode of operation is selected by either setting the environment\n   variable POSIXLY_CORRECT, or using `+' as the first character\n   of the list of option characters.\n\n   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n   so that eventually all the non-options are at the end.  This allows options\n   to be given in any order, even with programs that were not written to\n   expect this.\n\n   RETURN_IN_ORDER is an option available to programs that were written\n   to expect options and other ARGV-elements in any order and that care about\n   the ordering of the two.  We describe each non-option ARGV-element\n   as if it were the argument of an option with character code 1.\n   Using `-' as the first character of the list of option characters\n   selects this mode of operation.\n\n   The special argument `--' forces an end of option-scanning regardless\n   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */\n\nstatic enum\n{\n  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n} ordering;\n\f\n#ifdef\t__GNU_LIBRARY__\n/* We want to avoid inclusion of string.h with non-GNU libraries\n   because there are many ways it can cause trouble.\n   On some systems, it contains special magic macros that don't work\n   in GCC.  */\n#if flag_string==0   \n#include <string.h>\n#define flag_string 1\n#endif\n#define\tmy_index\tstrchr\n#define\tmy_bcopy(src, dst, n)\tmemcpy ((dst), (src), (n))\n#else\n\n/* Avoid depending on library functions or files\n   whose names are inconsistent.  */\n\nchar *getenv ();\n\nstatic char *\nmy_index (str, chr)\n     const char *str;\n     int chr;\n{\n  while (*str)\n    {\n      if (*str == chr)\n\treturn (char *) str;\n      str++;\n    }\n  return 0;\n}\n\nstatic void\nmy_bcopy (from, to, size)\n     const char *from;\n     char *to;\n     int size;\n{\n  int i;\n  for (i = 0; i < size; i++)\n    to[i] = from[i];\n}\n#endif\t\t\t\t/* GNU C library.  */\n\f\n/* Handle permutation of arguments.  */\n\n/* Describe the part of ARGV that contains non-options that have\n   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n   `last_nonopt' is the index after the last of them.  */\n\nstatic int first_nonopt;\nstatic int last_nonopt;\n\n/* Exchange two adjacent subsequences of ARGV.\n   One subsequence is elements [first_nonopt,last_nonopt)\n   which contains all the non-options that have been skipped so far.\n   The other is elements [last_nonopt,optind), which contains all\n   the options processed since those non-options were skipped.\n\n   `first_nonopt' and `last_nonopt' are relocated so that they describe\n   the new indices of the non-options in ARGV after they are moved.  */\n\nstatic void\nexchange (argv)\n     char **argv;\n{\n  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);\n  char **temp = (char **) __alloca (nonopts_size);\n\n  /* Interchange the two blocks of data in ARGV.  */\n\n  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);\n  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],\n\t    (optind - last_nonopt) * sizeof (char *));\n  my_bcopy ((char *) temp,\n\t    (char *) &argv[first_nonopt + optind - last_nonopt],\n\t    nonopts_size);\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  first_nonopt += (optind - last_nonopt);\n  last_nonopt = optind;\n}\n\f\n/* Scan elements of ARGV (whose length is ARGC) for option characters\n   given in OPTSTRING.\n\n   If an element of ARGV starts with '-', and is not exactly \"-\" or \"--\",\n   then it is an option element.  The characters of this element\n   (aside from the initial '-') are option characters.  If `getopt'\n   is called repeatedly, it returns successively each of the option characters\n   from each of the option elements.\n\n   If `getopt' finds another option character, it returns that character,\n   updating `optind' and `nextchar' so that the next call to `getopt' can\n   resume the scan with the following option character or ARGV-element.\n\n   If there are no more option characters, `getopt' returns `EOF'.\n   Then `optind' is the index in ARGV of the first ARGV-element\n   that is not an option.  (The ARGV-elements have been permuted\n   so that those that are not options now come last.)\n\n   OPTSTRING is a string containing the legitimate option characters.\n   If an option character is seen that is not listed in OPTSTRING,\n   return '?' after printing an error message.  If you set `opterr' to\n   zero, the error message is suppressed but we still return '?'.\n\n   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n   so the following text in the same ARGV-element, or the text of the following\n   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n   wants an optional arg; if there is text in the current ARGV-element,\n   it is returned in `optarg', otherwise `optarg' is set to zero.\n\n   If OPTSTRING starts with `-' or `+', it requests different methods of\n   handling the non-option ARGV-elements.\n   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n\n   Long-named options begin with `--' instead of `-'.\n   Their names may be abbreviated as long as the abbreviation is unique\n   or is an exact match for some defined option.  If they have an\n   argument, it follows the option name in the same ARGV-element, separated\n   from the option name by a `=', or else the in next ARGV-element.\n   When `getopt' finds a long-named option, it returns 0 if that option's\n   `flag' field is nonzero, the value of the option's `val' field\n   if the `flag' field is zero.\n\n   The elements of ARGV aren't really const, because we permute them.\n   But we pretend they're const in the prototype to be compatible\n   with other systems.\n\n   LONGOPTS is a vector of `struct option' terminated by an\n   element containing a name which is zero.\n\n   LONGIND returns the index in LONGOPT of the long-named option found.\n   It is only valid when a long-named option has been found by the most\n   recent call.\n\n   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n   long-named options.  */\n\nint\n_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n     const struct option *longopts;\n     int *longind;\n     int long_only;\n{\n  int option_index;\n\n  optarg = 0;\n\n  /* Initialize the internal data when the first call is made.\n     Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  if (optind == 0)\n    {\n      first_nonopt = last_nonopt = optind = 1;\n\n      nextchar = NULL;\n\n      /* Determine how to handle the ordering of options and nonoptions.  */\n\n      if (optstring[0] == '-')\n\t{\n\t  ordering = RETURN_IN_ORDER;\n\t  ++optstring;\n\t}\n      else if (optstring[0] == '+')\n\t{\n\t  ordering = REQUIRE_ORDER;\n\t  ++optstring;\n\t}\n      else if (getenv (\"POSIXLY_CORRECT\") != NULL)\n\tordering = REQUIRE_ORDER;\n      else\n\tordering = PERMUTE;\n    }\n\n  if (nextchar == NULL || *nextchar == '\\0')\n    {\n      if (ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (last_nonopt != optind)\n\t    first_nonopt = optind;\n\n\t  /* Now skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (optind < argc\n\t\t && (argv[optind][0] != '-' || argv[optind][1] == '\\0')\n#ifdef GETOPT_COMPAT\n\t\t && (longopts == NULL\n\t\t     || argv[optind][0] != '+' || argv[optind][1] == '\\0')\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t\t )\n\t    optind++;\n\t  last_nonopt = optind;\n\t}\n\n      /* Special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv[optind], \"--\"))\n\t{\n\t  optind++;\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (first_nonopt == last_nonopt)\n\t    first_nonopt = optind;\n\t  last_nonopt = argc;\n\n\t  optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (first_nonopt != last_nonopt)\n\t    optind = first_nonopt;\n\t  return EOF;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if ((argv[optind][0] != '-' || argv[optind][1] == '\\0')\n#ifdef GETOPT_COMPAT\n\t  && (longopts == NULL\n\t      || argv[optind][0] != '+' || argv[optind][1] == '\\0')\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  )\n\t{\n\t  if (ordering == REQUIRE_ORDER)\n\t    return EOF;\n\t  optarg = argv[optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Start decoding its characters.  */\n\n      nextchar = (argv[optind] + 1\n\t\t  + (longopts != NULL && argv[optind][1] == '-'));\n    }\n\n  if (longopts != NULL\n      && ((argv[optind][0] == '-'\n\t   && (argv[optind][1] == '-' || long_only))\n#ifdef GETOPT_COMPAT\n\t  || argv[optind][0] == '+'\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  ))\n    {\n      const struct option *p;\n      char *s = nextchar;\n      int exact = 0;\n      int ambig = 0;\n      const struct option *pfound = NULL;\n      int indfound;\n\n      while (*s && *s != '=')\n\ts++;\n\n      /* Test all options for either exact match or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name;\n\t   p++, option_index++)\n\tif (!strncmp (p->name, nextchar, s - nextchar))\n\t  {\n\t    if (s - nextchar == strlen (p->name))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else\n\t      /* Second nonexact match found.  */\n\t      ambig = 1;\n\t  }\n\n      if (ambig && !exact)\n\t{\n\t  if (opterr)\n\t    fprintf (stderr, \"%s: option `%s' is ambiguous\\n\",\n\t\t     argv[0], argv[optind]);\n\t  nextchar += strlen (nextchar);\n\t  optind++;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  optind++;\n\t  if (*s)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\toptarg = s + 1;\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    {\n\t\t      if (argv[optind - 1][1] == '-')\n\t\t\t/* --option */\n\t\t\tfprintf (stderr,\n\t\t\t\t \"%s: option `--%s' doesn't allow an argument\\n\",\n\t\t\t\t argv[0], pfound->name);\n\t\t      else\n\t\t\t/* +option or -option */\n\t\t\tfprintf (stderr,\n\t\t\t     \"%s: option `%c%s' doesn't allow an argument\\n\",\n\t\t\t     argv[0], argv[optind - 1][0], pfound->name);\n\t\t    }\n\t\t  nextchar += strlen (nextchar);\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (optind < argc)\n\t\toptarg = argv[optind++];\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    fprintf (stderr, \"%s: option `%s' requires an argument\\n\",\n\t\t\t     argv[0], argv[optind - 1]);\n\t\t  nextchar += strlen (nextchar);\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  nextchar += strlen (nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[optind][1] == '-'\n#ifdef GETOPT_COMPAT\n\t  || argv[optind][0] == '+'\n#endif\t\t\t\t/* GETOPT_COMPAT */\n\t  || my_index (optstring, *nextchar) == NULL)\n\t{\n\t  if (opterr)\n\t    {\n\t      if (argv[optind][1] == '-')\n\t\t/* --option */\n\t\tfprintf (stderr, \"%s: unrecognized option `--%s'\\n\",\n\t\t\t argv[0], nextchar);\n\t      else\n\t\t/* +option or -option */\n\t\tfprintf (stderr, \"%s: unrecognized option `%c%s'\\n\",\n\t\t\t argv[0], argv[optind][0], nextchar);\n\t    }\n\t  nextchar = (char *) \"\";\n\t  optind++;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = my_index (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n\tif (opterr)\n\t  {\n#if 0\n\t    if (c < 040 || c >= 0177)\n\t      fprintf (stderr, \"%s: unrecognized option, character code 0%o\\n\",\n\t\t       argv[0], c);\n\t    else\n\t      fprintf (stderr, \"%s: unrecognized option `-%c'\\n\", argv[0], c);\n#else\n\t    /* 1003.2 specifies the format of this message.  */\n\t    fprintf (stderr, \"%s: illegal option -- %c\\n\", argv[0], c);\n#endif\n\t  }\n\toptopt = c;\n\treturn '?';\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\toptind++;\n\t      }\n\t    else\n\t      optarg = 0;\n\t    nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\toptind++;\n\t      }\n\t    else if (optind == argc)\n\t      {\n\t\tif (opterr)\n\t\t  {\n#if 0\n\t\t    fprintf (stderr, \"%s: option `-%c' requires an argument\\n\",\n\t\t\t     argv[0], c);\n#else\n\t\t    /* 1003.2 specifies the format of this message.  */\n\t\t    fprintf (stderr, \"%s: option requires an argument -- %c\\n\",\n\t\t\t     argv[0], c);\n#endif\n\t\t  }\n\t\toptopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      optarg = argv[optind++];\n\t    nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}\n\nint\ngetopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0);\n}\n\n#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n\f\n#ifdef TEST\n\n/* Compile with -DTEST to make an executable for use in testing\n   the above definition of `getopt'.  */\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == EOF)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}\n\n#endif /* TEST */\n/* Extended regular expression matching and search library,\n   version 0.12.\n   (Implements POSIX draft P10003.2/D11.2, except for\n   internationalization features.)\n\n   Copyright (C) 1993 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n/* AIX requires this to be the first thing in the file. */\n#if defined (_AIX) && !defined (REGEX_MALLOC)\n  #pragma alloca\n#endif\n\n#define _GNU_SOURCE\n\n/* We need this for `regex.h', and perhaps for the Emacs include files.  */\n#if flag_systypes==0\n#include <sys/types.h>\n#define flag_systypes 1\n#endif\n\n#ifdef HAVE_CONFIG_H\n#if flag_config==0\n#include \"config.h\"\n#define flag_config 1\n#endif\n#endif\n\n/* The `emacs' switch turns on certain matching commands\n   that make sense only in Emacs. */\n#ifdef emacs\n\n#include \"lisp.h\"\n#include \"buffer.h\"\n#include \"syntax.h\"\n\n/* Emacs uses `NULL' as a predicate.  */\n#undef NULL\n\n#else  /* not emacs */\n\n/* We used to test for `BSTRING' here, but only GCC and Emacs define\n   `BSTRING', as far as I know, and neither of them use this code.  */\n#if HAVE_STRING_H || STDC_HEADERS\n#if flag_string==0\n#include <string.h>\n#define flag_string 1\n#endif\n#ifndef bcmp\n#define bcmp(s1, s2, n)\tmemcmp ((s1), (s2), (n))\n#endif\n#ifndef bcopy\n#define bcopy(s, d, n)\tmemcpy ((d), (s), (n))\n#endif\n#ifndef bzero\n#define bzero(s, n)\tmemset ((s), 0, (n))\n#endif\n#else\n#if flag_strings==0\n#include <strings.h>\n#define flag_strings 1\n#endif\n#endif\n\n#ifdef STDC_HEADERS\n#if flag_stdlib==0 \n#include <stdlib.h>\n#define flag_stdlib 1\n#endif\n#else\nchar *malloc ();\nchar *realloc ();\n#endif\n\n\n/* Define the syntax stuff for \\<, \\>, etc.  */\n\n/* This must be nonzero for the wordchar and notwordchar pattern\n   commands in re_match_2.  */\n#ifndef Sword \n#define Sword 1\n#endif\n\n#ifdef SYNTAX_TABLE\n\nextern char *re_syntax_table;\n\n#else /* not SYNTAX_TABLE */\n\n/* How many characters in the character set.  */\n#define CHAR_SET_SIZE 256\n\nstatic char re_syntax_table[CHAR_SET_SIZE];\n\nstatic void\ninit_syntax_once ()\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}\n\n#endif /* not SYNTAX_TABLE */\n\n#define SYNTAX(c) re_syntax_table[c]\n\n#endif /* not emacs */\n\f\n/* Get the interface, including the syntax bits.  */\n#include \"regex.h\"\n\n/* isalpha etc. are used for the character classes.  */\n#include <ctype.h>\n\n/* Jim Meyering writes:\n\n   \"... Some ctype macros are valid only for character codes that\n   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when\n   using /bin/cc or gcc but without giving an ansi option).  So, all\n   ctype uses should be through macros like ISPRINT...  If\n   STDC_HEADERS is defined, then autoconf has verified that the ctype\n   macros don't need to be guarded with references to isascii. ...\n   Defining isascii to 1 should let any compiler worth its salt\n   eliminate the && through constant folding.\"  */\n#if ! defined (isascii) || defined (STDC_HEADERS)\n#undef isascii\n#define isascii(c) 1\n#endif\n\n#ifdef isblank\n#define ISBLANK(c) (isascii (c) && isblank (c))\n#else\n#define ISBLANK(c) ((c) == ' ' || (c) == '\\t')\n#endif\n#ifdef isgraph\n#define ISGRAPH(c) (isascii (c) && isgraph (c))\n#else\n#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))\n#endif\n\n#define ISPRINT(c) (isascii (c) && isprint (c))\n#define ISDIGIT(c) (isascii (c) && isdigit (c))\n#define ISALNUM(c) (isascii (c) && isalnum (c))\n#define ISALPHA(c) (isascii (c) && isalpha (c))\n#define ISCNTRL(c) (isascii (c) && iscntrl (c))\n#define ISLOWER(c) (isascii (c) && islower (c))\n#define ISPUNCT(c) (isascii (c) && ispunct (c))\n#define ISSPACE(c) (isascii (c) && isspace (c))\n#define ISUPPER(c) (isascii (c) && isupper (c))\n#define ISXDIGIT(c) (isascii (c) && isxdigit (c))\n\n#ifndef NULL\n#define NULL 0\n#endif\n\n/* We remove any previous definition of `SIGN_EXTEND_CHAR',\n   since ours (we hope) works properly with all combinations of\n   machines, compilers, `char' and `unsigned char' argument types.\n   (Per Bothner suggested the basic approach.)  */\n#undef SIGN_EXTEND_CHAR\n#if __STDC__\n#define SIGN_EXTEND_CHAR(c) ((signed char) (c))\n#else  /* not __STDC__ */\n/* As in Harbison and Steele.  */\n#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)\n#endif\n\f\n/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we\n   use `alloca' instead of `malloc'.  This is because using malloc in\n   re_search* or re_match* could cause memory leaks when C-g is used in\n   Emacs; also, malloc is slower and causes storage fragmentation.  On\n   the other hand, malloc is more portable, and easier to debug.  \n   \n   Because we sometimes use alloca, some routines have to be macros,\n   not functions -- `alloca'-allocated space disappears at the end of the\n   function it is called in.  */\n\n#ifdef REGEX_MALLOC\n\n#define REGEX_ALLOCATE malloc\n#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)\n\n#else /* not REGEX_MALLOC  */\n\n/* Emacs already defines alloca, sometimes.  */\n#ifndef alloca\n\n/* Make alloca work the best possible way.  */\n#ifdef __GNUC__\n#define alloca __builtin_alloca\n#else /* not __GNUC__ */\n#if HAVE_ALLOCA_H\n#if flag_alloca==0\n#include <alloca.h>\n#define flag_alloca 1\n#endif \n#else /* not __GNUC__ or HAVE_ALLOCA_H */\n#ifndef _AIX /* Already did AIX, up at the top.  */\nchar *alloca ();\n#endif /* not _AIX */\n#endif /* not HAVE_ALLOCA_H */ \n#endif /* not __GNUC__ */\n\n#endif /* not alloca */\n\n#define REGEX_ALLOCATE alloca\n\n/* Assumes a `char *destination' variable.  */\n#define REGEX_REALLOCATE(source, osize, nsize)\t\t\t\t\\\n  (destination = (char *) alloca (nsize),\t\t\t\t\\\n   bcopy (source, destination, osize),\t\t\t\t\t\\\n   destination)\n\n#endif /* not REGEX_MALLOC */\n\n\n/* True if `size1' is non-NULL and PTR is pointing anywhere inside\n   `string1' or just past its end.  This works if PTR is NULL, which is\n   a good thing.  */\n#define FIRST_STRING_P(ptr) \t\t\t\t\t\\\n  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)\n\n/* (Re)Allocate N items of type T using malloc, or fail.  */\n#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))\n#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))\n#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))\n\n#define BYTEWIDTH 8 /* In bits.  */\n\n#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))\n\n#undef MAX               /****** added later *******/\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef char boolean;\n#define false 0\n#define true 1\n\f\n/* These are the command codes that appear in compiled regular\n   expressions.  Some opcodes are followed by argument bytes.  A\n   command code can specify any interpretation whatsoever for its\n   arguments.  Zero bytes may appear in the compiled regular expression.\n\n   The value of `exactn' is needed in search.c (search_buffer) in Emacs.\n   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of\n   `exactn' we use here must also be 1.  */\n\ntypedef enum\n{\n  no_op = 0,\n\n        /* Followed by one byte giving n, then by n literal bytes.  */\n  exactn = 1,\n\n        /* Matches any (more or less) character.  */\n  anychar,\n\n        /* Matches any one char belonging to specified set.  First\n           following byte is number of bitmap bytes.  Then come bytes\n           for a bitmap saying which chars are in.  Bits in each byte\n           are ordered low-bit-first.  A character is in the set if its\n           bit is 1.  A character too large to have a bit in the map is\n           automatically not in the set.  */\n  charset,\n\n        /* Same parameters as charset, but match any character that is\n           not one of those specified.  */\n  charset_not,\n\n        /* Start remembering the text that is matched, for storing in a\n           register.  Followed by one byte with the register number, in\n           the range 0 to one less than the pattern buffer's re_nsub\n           field.  Then followed by one byte with the number of groups\n           inner to this one.  (This last has to be part of the\n           start_memory only because we need it in the on_failure_jump\n           of re_match_2.)  */\n  start_memory,\n\n        /* Stop remembering the text that is matched and store it in a\n           memory register.  Followed by one byte with the register\n           number, in the range 0 to one less than `re_nsub' in the\n           pattern buffer, and one byte with the number of inner groups,\n           just like `start_memory'.  (We need the number of inner\n           groups here because we don't have any easy way of finding the\n           corresponding start_memory when we're at a stop_memory.)  */\n  stop_memory,\n\n        /* Match a duplicate of something remembered. Followed by one\n           byte containing the register number.  */\n  duplicate,\n\n        /* Fail unless at beginning of line.  */\n  begline,\n\n        /* Fail unless at end of line.  */\n  endline,\n\n        /* Succeeds if at beginning of buffer (if emacs) or at beginning\n           of string to be matched (if not).  */\n  begbuf,\n\n        /* Analogously, for end of buffer/string.  */\n  endbuf,\n \n        /* Followed by two byte relative address to which to jump.  */\n  jump, \n\n\t/* Same as jump, but marks the end of an alternative.  */\n  jump_past_alt,\n\n        /* Followed by two-byte relative address of place to resume at\n           in case of failure.  */\n  on_failure_jump,\n\t\n        /* Like on_failure_jump, but pushes a placeholder instead of the\n           current string position when executed.  */\n  on_failure_keep_string_jump,\n  \n        /* Throw away latest failure point and then jump to following\n           two-byte relative address.  */\n  pop_failure_jump,\n\n        /* Change to pop_failure_jump if know won't have to backtrack to\n           match; otherwise change to jump.  This is used to jump\n           back to the beginning of a repeat.  If what follows this jump\n           clearly won't match what the repeat does, such that we can be\n           sure that there is no use backtracking out of repetitions\n           already matched, then we change it to a pop_failure_jump.\n           Followed by two-byte address.  */\n  maybe_pop_jump,\n\n        /* Jump to following two-byte address, and push a dummy failure\n           point. This failure point will be thrown away if an attempt\n           is made to use it for a failure.  A `+' construct makes this\n           before the first repeat.  Also used as an intermediary kind\n           of jump when compiling an alternative.  */\n  dummy_failure_jump,\n\n\t/* Push a dummy failure point and continue.  Used at the end of\n\t   alternatives.  */\n  push_dummy_failure,\n\n        /* Followed by two-byte relative address and two-byte number n.\n           After matching N times, jump to the address upon failure.  */\n  succeed_n,\n\n        /* Followed by two-byte relative address, and two-byte number n.\n           Jump to the address N times, then fail.  */\n  jump_n,\n\n        /* Set the following two-byte relative address to the\n           subsequent two-byte number.  The address *includes* the two\n           bytes of number.  */\n  set_number_at,\n\n  wordchar,\t/* Matches any word-constituent character.  */\n  notwordchar,\t/* Matches any char that is not a word-constituent.  */\n\n  wordbeg,\t/* Succeeds if at word beginning.  */\n  wordend,\t/* Succeeds if at word end.  */\n\n  wordbound,\t/* Succeeds if at a word boundary.  */\n  notwordbound\t/* Succeeds if not at a word boundary.  */\n\n#ifdef emacs\n  ,before_dot,\t/* Succeeds if before point.  */\n  at_dot,\t/* Succeeds if at point.  */\n  after_dot,\t/* Succeeds if after point.  */\n\n\t/* Matches any character whose syntax is specified.  Followed by\n           a byte which contains a syntax code, e.g., Sword.  */\n  syntaxspec,\n\n\t/* Matches any character whose syntax is not that specified.  */\n  notsyntaxspec\n#endif /* emacs */\n} re_opcode_t;\n\f\n/* Common operations on the compiled pattern.  */\n\n/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */\n\n#define STORE_NUMBER(destination, number)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    (destination)[0] = (number) & 0377;\t\t\t\t\t\\\n    (destination)[1] = (number) >> 8;\t\t\t\t\t\\\n  } while (0)\n\n/* Same as STORE_NUMBER, except increment DESTINATION to\n   the byte after where the number is stored.  Therefore, DESTINATION\n   must be an lvalue.  */\n\n#define STORE_NUMBER_AND_INCR(destination, number)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    STORE_NUMBER (destination, number);\t\t\t\t\t\\\n    (destination) += 2;\t\t\t\t\t\t\t\\\n  } while (0)\n\n/* Put into DESTINATION a number stored in two contiguous bytes starting\n   at SOURCE.  */\n\n#define EXTRACT_NUMBER(destination, source)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    (destination) = *(source) & 0377;\t\t\t\t\t\\\n    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;\t\t\\\n  } while (0)\n\n#ifdef DEBUG\nstatic void\nextract_number (dest, source)\n    int *dest;\n    unsigned char *source;\n{\n  int temp = SIGN_EXTEND_CHAR (*(source + 1)); \n  *dest = *source & 0377;\n  *dest += temp << 8;\n}\n\n#ifndef EXTRACT_MACROS /* To debug the macros.  */\n#undef EXTRACT_NUMBER\n#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)\n#endif /* not EXTRACT_MACROS */\n\n#endif /* DEBUG */\n\n/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.\n   SOURCE must be an lvalue.  */\n\n#define EXTRACT_NUMBER_AND_INCR(destination, source)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    EXTRACT_NUMBER (destination, source);\t\t\t\t\\\n    (source) += 2; \t\t\t\t\t\t\t\\\n  } while (0)\n\n#ifdef DEBUG\nstatic void\nextract_number_and_incr (destination, source)\n    int *destination;\n    unsigned char **source;\n{ \n  extract_number (destination, *source);\n  *source += 2;\n}\n\n#ifndef EXTRACT_MACROS\n#undef EXTRACT_NUMBER_AND_INCR\n#define EXTRACT_NUMBER_AND_INCR(dest, src) \\\n  extract_number_and_incr (&dest, &src)\n#endif /* not EXTRACT_MACROS */\n\n#endif /* DEBUG */\n\f\n/* If DEBUG is defined, Regex prints many voluminous messages about what\n   it is doing (if the variable `debug' is nonzero).  If linked with the\n   main program in `iregex.c', you can enter patterns and strings\n   interactively.  And if linked with the main program in `main.c' and\n   the other test files, you can run the already-written tests.  */\n\n#ifdef DEBUG\n\n/* We use standard I/O for debugging.  */\n/*#include <stdio.h>*/\n\n/* It is useful to test things that ``must'' be true when debugging.  */\n#include <assert.h>\n\nstatic int debug = 0;\n\n#define DEBUG_STATEMENT(e) e\n#define DEBUG_PRINT1(x) if (debug) printf (x)\n#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)\n#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)\n#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)\n#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) \t\t\t\t\\\n  if (debug) print_partial_compiled_pattern (s, e)\n#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)\t\t\t\\\n  if (debug) print_double_string (w, s1, sz1, s2, sz2)\n\n\nextern void printchar ();\n\n/* Print the fastmap in human-readable form.  */\n\nvoid\nprint_fastmap (fastmap)\n    char *fastmap;\n{\n  unsigned was_a_range = 0;\n  unsigned i = 0;  \n  \n  while (i < (1 << BYTEWIDTH))\n    {\n      if (fastmap[i++])\n\t{\n\t  was_a_range = 0;\n          printchar (i - 1);\n          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])\n            {\n              was_a_range = 1;\n              i++;\n            }\n\t  if (was_a_range)\n            {\n              printf (\"-\");\n              printchar (i - 1);\n            }\n        }\n    }\n  putchar ('\\n'); \n}\n\n\n/* Print a compiled pattern string in human-readable form, starting at\n   the START pointer into it and ending just before the pointer END.  */\n\nvoid\nprint_partial_compiled_pattern (start, end)\n    unsigned char *start;\n    unsigned char *end;\n{\n  int mcnt, mcnt2;\n  unsigned char *p = start;\n  unsigned char *pend = end;\n\n  if (start == NULL)\n    {\n      printf (\"(null)\\n\");\n      return;\n    }\n    \n  /* Loop over pattern commands.  */\n  while (p < pend)\n    {\n      printf (\"%d:\\t\", p - start);\n\n      switch ((re_opcode_t) *p++)\n\t{\n        case no_op:\n          printf (\"/no_op\");\n          break;\n\n\tcase exactn:\n\t  mcnt = *p++;\n          printf (\"/exactn/%d\", mcnt);\n          do\n\t    {\n              putchar ('/');\n\t      printchar (*p++);\n            }\n          while (--mcnt);\n          break;\n\n\tcase start_memory:\n          mcnt = *p++;\n          printf (\"/start_memory/%d/%d\", mcnt, *p++);\n          break;\n\n\tcase stop_memory:\n          mcnt = *p++;\n\t  printf (\"/stop_memory/%d/%d\", mcnt, *p++);\n          break;\n\n\tcase duplicate:\n\t  printf (\"/duplicate/%d\", *p++);\n\t  break;\n\n\tcase anychar:\n\t  printf (\"/anychar\");\n\t  break;\n\n\tcase charset:\n        case charset_not:\n          {\n            register int c, last = -100;\n\t    register int in_range = 0;\n\n\t    printf (\"/charset [%s\",\n\t            (re_opcode_t) *(p - 1) == charset_not ? \"^\" : \"\");\n            \n            assert (p + *p < pend);\n\n            for (c = 0; c < 256; c++)\n\t      if (c / 8 < *p\n\t\t  && (p[1 + (c/8)] & (1 << (c % 8))))\n\t\t{\n\t\t  /* Are we starting a range?  */\n\t\t  if (last + 1 == c && ! in_range)\n\t\t    {\n\t\t      putchar ('-');\n\t\t      in_range = 1;\n\t\t    }\n\t\t  /* Have we broken a range?  */\n\t\t  else if (last + 1 != c && in_range)\n              {\n\t\t      printchar (last);\n\t\t      in_range = 0;\n\t\t    }\n                \n\t\t  if (! in_range)\n\t\t    printchar (c);\n\n\t\t  last = c;\n              }\n\n\t    if (in_range)\n\t      printchar (last);\n\n\t    putchar (']');\n\n\t    p += 1 + *p;\n\t  }\n\t  break;\n\n\tcase begline:\n\t  printf (\"/begline\");\n          break;\n\n\tcase endline:\n          printf (\"/endline\");\n          break;\n\n\tcase on_failure_jump:\n          extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/on_failure_jump to %d\", p + mcnt - start);\n          break;\n\n\tcase on_failure_keep_string_jump:\n          extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/on_failure_keep_string_jump to %d\", p + mcnt - start);\n          break;\n\n\tcase dummy_failure_jump:\n          extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/dummy_failure_jump to %d\", p + mcnt - start);\n          break;\n\n\tcase push_dummy_failure:\n          printf (\"/push_dummy_failure\");\n          break;\n          \n        case maybe_pop_jump:\n          extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/maybe_pop_jump to %d\", p + mcnt - start);\n\t  break;\n\n        case pop_failure_jump:\n\t  extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/pop_failure_jump to %d\", p + mcnt - start);\n\t  break;          \n          \n        case jump_past_alt:\n\t  extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/jump_past_alt to %d\", p + mcnt - start);\n\t  break;          \n          \n        case jump:\n\t  extract_number_and_incr (&mcnt, &p);\n  \t  printf (\"/jump to %d\", p + mcnt - start);\n\t  break;\n\n        case succeed_n: \n          extract_number_and_incr (&mcnt, &p);\n          extract_number_and_incr (&mcnt2, &p);\n\t  printf (\"/succeed_n to %d, %d times\", p + mcnt - start, mcnt2);\n          break;\n        \n        case jump_n: \n          extract_number_and_incr (&mcnt, &p);\n          extract_number_and_incr (&mcnt2, &p);\n\t  printf (\"/jump_n to %d, %d times\", p + mcnt - start, mcnt2);\n          break;\n        \n        case set_number_at: \n          extract_number_and_incr (&mcnt, &p);\n          extract_number_and_incr (&mcnt2, &p);\n\t  printf (\"/set_number_at location %d to %d\", p + mcnt - start, mcnt2);\n          break;\n        \n        case wordbound:\n\t  printf (\"/wordbound\");\n\t  break;\n\n\tcase notwordbound:\n\t  printf (\"/notwordbound\");\n          break;\n\n\tcase wordbeg:\n\t  printf (\"/wordbeg\");\n\t  break;\n          \n\tcase wordend:\n\t  printf (\"/wordend\");\n          \n#ifdef emacs\n\tcase before_dot:\n\t  printf (\"/before_dot\");\n          break;\n\n\tcase at_dot:\n\t  printf (\"/at_dot\");\n          break;\n\n\tcase after_dot:\n\t  printf (\"/after_dot\");\n          break;\n\n\tcase syntaxspec:\n          printf (\"/syntaxspec\");\n\t  mcnt = *p++;\n\t  printf (\"/%d\", mcnt);\n          break;\n\t  \n\tcase notsyntaxspec:\n          printf (\"/notsyntaxspec\");\n\t  mcnt = *p++;\n\t  printf (\"/%d\", mcnt);\n\t  break;\n#endif /* emacs */\n\n\tcase wordchar:\n\t  printf (\"/wordchar\");\n          break;\n\t  \n\tcase notwordchar:\n\t  printf (\"/notwordchar\");\n          break;\n\n\tcase begbuf:\n\t  printf (\"/begbuf\");\n          break;\n\n\tcase endbuf:\n\t  printf (\"/endbuf\");\n          break;\n\n        default:\n          printf (\"?%d\", *(p-1));\n\t}\n\n      putchar ('\\n');\n    }\n\n  printf (\"%d:\\tend of pattern.\\n\", p - start);\n}\n\n\nvoid\nprint_compiled_pattern (bufp)\n    struct re_pattern_buffer *bufp;\n{\n  unsigned char *buffer = bufp->buffer;\n\n  print_partial_compiled_pattern (buffer, buffer + bufp->used);\n  printf (\"%d bytes used/%d bytes allocated.\\n\", bufp->used, bufp->allocated);\n\n  if (bufp->fastmap_accurate && bufp->fastmap)\n    {\n      printf (\"fastmap: \");\n      print_fastmap (bufp->fastmap);\n    }\n\n  printf (\"re_nsub: %d\\t\", bufp->re_nsub);\n  printf (\"regs_alloc: %d\\t\", bufp->regs_allocated);\n  printf (\"can_be_null: %d\\t\", bufp->can_be_null);\n  printf (\"newline_anchor: %d\\n\", bufp->newline_anchor);\n  printf (\"no_sub: %d\\t\", bufp->no_sub);\n  printf (\"not_bol: %d\\t\", bufp->not_bol);\n  printf (\"not_eol: %d\\t\", bufp->not_eol);\n  printf (\"syntax: %d\\n\", bufp->syntax);\n  /* Perhaps we should print the translate table?  */\n}\n\n\nvoid\nprint_double_string (where, string1, size1, string2, size2)\n    const char *where;\n    const char *string1;\n    const char *string2;\n    int size1;\n    int size2;\n{\n  unsigned this_char;\n  \n  if (where == NULL)\n    printf (\"(null)\");\n  else\n    {\n      if (FIRST_STRING_P (where))\n        {\n          for (this_char = where - string1; this_char < size1; this_char++)\n            printchar (string1[this_char]);\n\n          where = string2;    \n        }\n\n      for (this_char = where - string2; this_char < size2; this_char++)\n        printchar (string2[this_char]);\n    }\n}\n\n#else /* not DEBUG */\n\n#undef assert\n#define assert(e)\n\n#define DEBUG_STATEMENT(e)\n#define DEBUG_PRINT1(x)\n#define DEBUG_PRINT2(x1, x2)\n#define DEBUG_PRINT3(x1, x2, x3)\n#define DEBUG_PRINT4(x1, x2, x3, x4)\n#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)\n#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)\n\n#endif /* not DEBUG */\n\f\n/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can\n   also be assigned to arbitrarily: each pattern buffer stores its own\n   syntax, so it can be changed between regex compilations.  */\nreg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;\n\n\n/* Specify the precise syntax of regexps for compilation.  This provides\n   for compatibility for various utilities which historically have\n   different, incompatible syntaxes.\n\n   The argument SYNTAX is a bit mask comprised of the various bits\n   defined in regex.h.  We return the old syntax.  */\n\nreg_syntax_t\nre_set_syntax (syntax)\n    reg_syntax_t syntax;\n{\n  reg_syntax_t ret = re_syntax_options;\n  \n  re_syntax_options = syntax;\n  return ret;\n}\n\f\n/* This table gives an error message for each of the error codes listed\n   in regex.h.  Obviously the order here has to be same as there.  */\n\nstatic const char *re_error_msg[] =\n  { NULL,\t\t\t\t\t/* REG_NOERROR */\n    \"No match\",\t\t\t\t\t/* REG_NOMATCH */\n    \"Invalid regular expression\",\t\t/* REG_BADPAT */\n    \"Invalid collation character\",\t\t/* REG_ECOLLATE */\n    \"Invalid character class name\",\t\t/* REG_ECTYPE */\n    \"Trailing backslash\",\t\t\t/* REG_EESCAPE */\n    \"Invalid back reference\",\t\t\t/* REG_ESUBREG */\n    \"Unmatched [ or [^\",\t\t\t/* REG_EBRACK */\n    \"Unmatched ( or \\\\(\",\t\t\t/* REG_EPAREN */\n    \"Unmatched \\\\{\",\t\t\t\t/* REG_EBRACE */\n    \"Invalid content of \\\\{\\\\}\",\t\t/* REG_BADBR */\n    \"Invalid range end\",\t\t\t/* REG_ERANGE */\n    \"Memory exhausted\",\t\t\t\t/* REG_ESPACE */\n    \"Invalid preceding regular expression\",\t/* REG_BADRPT */\n    \"Premature end of regular expression\",\t/* REG_EEND */\n    \"Regular expression too big\",\t\t/* REG_ESIZE */\n    \"Unmatched ) or \\\\)\",\t\t\t/* REG_ERPAREN */\n  };\n\f\n/* Subroutine declarations and macros for regex_compile.  */\n\nstatic void store_op1 (), store_op2 ();\nstatic void insert_op1 (), insert_op2 ();\nstatic boolean at_begline_loc_p (), at_endline_loc_p ();\nstatic boolean group_in_compile_stack ();\nstatic reg_errcode_t compile_range ();\n\n/* Fetch the next character in the uncompiled pattern---translating it \n   if necessary.  Also cast from a signed character in the constant\n   string passed to us by the user to an unsigned char that we can use\n   as an array index (in, e.g., `translate').  */\n#define PATFETCH(c)\t\t\t\t\t\t\t\\\n  do {if (p == pend) return REG_EEND;\t\t\t\t\t\\\n    c = (unsigned char) *p++;\t\t\t\t\t\t\\\n    if (translate) c = translate[c]; \t\t\t\t\t\\\n  } while (0)\n\n/* Fetch the next character in the uncompiled pattern, with no\n   translation.  */\n#define PATFETCH_RAW(c)\t\t\t\t\t\t\t\\\n  do {if (p == pend) return REG_EEND;\t\t\t\t\t\\\n    c = (unsigned char) *p++; \t\t\t\t\t\t\\\n  } while (0)\n\n/* Go backwards one character in the pattern.  */\n#define PATUNFETCH p--\n\n\n/* If `translate' is non-null, return translate[D], else just D.  We\n   cast the subscript to translate because some data is declared as\n   `char *', to avoid warnings when a string constant is passed.  But\n   when we use a character as a subscript we must make it unsigned.  */\n#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))\n\n\n/* Macros for outputting the compiled pattern into `buffer'.  */\n\n/* If the buffer isn't allocated when it comes in, use this.  */\n#define INIT_BUF_SIZE  32\n\n/* Make sure we have at least N more bytes of space in buffer.  */\n#define GET_BUFFER_SPACE(n)\t\t\t\t\t\t\\\n    while (b - bufp->buffer + (n) > bufp->allocated)\t\t\t\\\n      EXTEND_BUFFER ()\n\n/* Make sure we have one more byte of buffer space and then add C to it.  */\n#define BUF_PUSH(c)\t\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    GET_BUFFER_SPACE (1);\t\t\t\t\t\t\\\n    *b++ = (unsigned char) (c);\t\t\t\t\t\t\\\n  } while (0)\n\n\n/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */\n#define BUF_PUSH_2(c1, c2)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    GET_BUFFER_SPACE (2);\t\t\t\t\t\t\\\n    *b++ = (unsigned char) (c1);\t\t\t\t\t\\\n    *b++ = (unsigned char) (c2);\t\t\t\t\t\\\n  } while (0)\n\n\n/* As with BUF_PUSH_2, except for three bytes.  */\n#define BUF_PUSH_3(c1, c2, c3)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    GET_BUFFER_SPACE (3);\t\t\t\t\t\t\\\n    *b++ = (unsigned char) (c1);\t\t\t\t\t\\\n    *b++ = (unsigned char) (c2);\t\t\t\t\t\\\n    *b++ = (unsigned char) (c3);\t\t\t\t\t\\\n  } while (0)\n\n\n/* Store a jump with opcode OP at LOC to location TO.  We store a\n   relative address offset by the three bytes the jump itself occupies.  */\n#define STORE_JUMP(op, loc, to) \\\n  store_op1 (op, loc, (to) - (loc) - 3)\n\n/* Likewise, for a two-argument jump.  */\n#define STORE_JUMP2(op, loc, to, arg) \\\n  store_op2 (op, loc, (to) - (loc) - 3, arg)\n\n/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */\n#define INSERT_JUMP(op, loc, to) \\\n  insert_op1 (op, loc, (to) - (loc) - 3, b)\n\n/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */\n#define INSERT_JUMP2(op, loc, to, arg) \\\n  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)\n\n\n/* This is not an arbitrary limit: the arguments which represent offsets\n   into the pattern are two bytes long.  So if 2^16 bytes turns out to\n   be too small, many things would have to change.  */\n#define MAX_BUF_SIZE (1L << 16)\n\n\n/* Extend the buffer by twice its current size via realloc and\n   reset the pointers that pointed into the old block to point to the\n   correct places in the new one.  If extending the buffer results in it\n   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */\n#define EXTEND_BUFFER()\t\t\t\t\t\t\t\\\n  do { \t\t\t\t\t\t\t\t\t\\\n    unsigned char *old_buffer = bufp->buffer;\t\t\t\t\\\n    if (bufp->allocated == MAX_BUF_SIZE) \t\t\t\t\\\n      return REG_ESIZE;\t\t\t\t\t\t\t\\\n    bufp->allocated <<= 1;\t\t\t\t\t\t\\\n    if (bufp->allocated > MAX_BUF_SIZE)\t\t\t\t\t\\\n      bufp->allocated = MAX_BUF_SIZE; \t\t\t\t\t\\\n    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\\\n    if (bufp->buffer == NULL)\t\t\t\t\t\t\\\n      return REG_ESPACE;\t\t\t\t\t\t\\\n    /* If the buffer moved, move all the pointers into it.  */\t\t\\\n    if (old_buffer != bufp->buffer)\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n        b = (b - old_buffer) + bufp->buffer;\t\t\t\t\\\n        begalt = (begalt - old_buffer) + bufp->buffer;\t\t\t\\\n        if (fixup_alt_jump)\t\t\t\t\t\t\\\n          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\\\n        if (laststart)\t\t\t\t\t\t\t\\\n          laststart = (laststart - old_buffer) + bufp->buffer;\t\t\\\n        if (pending_exact)\t\t\t\t\t\t\\\n          pending_exact = (pending_exact - old_buffer) + bufp->buffer;\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n\n/* Since we have one byte reserved for the register number argument to\n   {start,stop}_memory, the maximum number of groups we can report\n   things about is what fits in that byte.  */\n#define MAX_REGNUM 255\n\n/* But patterns can have more than `MAX_REGNUM' registers.  We just\n   ignore the excess.  */\ntypedef unsigned regnum_t;\n\n\n/* Macros for the compile stack.  */\n\n/* Since offsets can go either forwards or backwards, this type needs to\n   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */\ntypedef int pattern_offset_t;\n\ntypedef struct\n{\n  pattern_offset_t begalt_offset;\n  pattern_offset_t fixup_alt_jump;\n  pattern_offset_t inner_group_offset;\n  pattern_offset_t laststart_offset;  \n  regnum_t regnum;\n} compile_stack_elt_t;\n\n\ntypedef struct\n{\n  compile_stack_elt_t *stack;\n  unsigned size;\n  unsigned avail;\t\t\t/* Offset of next open position.  */\n} compile_stack_type;\n\n\n#define INIT_COMPILE_STACK_SIZE 32\n\n#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)\n#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)\n\n/* The next available element.  */\n#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])\n\n\n/* Set the bit for character C in a list.  */\n#define SET_LIST_BIT(c)                               \\\n  (b[((unsigned char) (c)) / BYTEWIDTH]               \\\n   |= 1 << (((unsigned char) c) % BYTEWIDTH))\n\n\n/* Get the next unsigned number in the uncompiled pattern.  */\n#define GET_UNSIGNED_NUMBER(num) \t\t\t\t\t\\\n  { if (p != pend)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       PATFETCH (c); \t\t\t\t\t\t\t\\\n       while (ISDIGIT (c)) \t\t\t\t\t\t\\\n         { \t\t\t\t\t\t\t\t\\\n           if (num < 0)\t\t\t\t\t\t\t\\\n              num = 0;\t\t\t\t\t\t\t\\\n           num = num * 10 + c - '0'; \t\t\t\t\t\\\n           if (p == pend) \t\t\t\t\t\t\\\n              break; \t\t\t\t\t\t\t\\\n           PATFETCH (c);\t\t\t\t\t\t\\\n         } \t\t\t\t\t\t\t\t\\\n       } \t\t\t\t\t\t\t\t\\\n    }\t\t\n\n#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */\n\n#define IS_CHAR_CLASS(string)\t\t\t\t\t\t\\\n   (STREQ (string, \"alpha\") || STREQ (string, \"upper\")\t\t\t\\\n    || STREQ (string, \"lower\") || STREQ (string, \"digit\")\t\t\\\n    || STREQ (string, \"alnum\") || STREQ (string, \"xdigit\")\t\t\\\n    || STREQ (string, \"space\") || STREQ (string, \"print\")\t\t\\\n    || STREQ (string, \"punct\") || STREQ (string, \"graph\")\t\t\\\n    || STREQ (string, \"cntrl\") || STREQ (string, \"blank\"))\n\f\n/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.\n   Returns one of error codes defined in `regex.h', or zero for success.\n\n   Assumes the `allocated' (and perhaps `buffer') and `translate'\n   fields are set in BUFP on entry.\n\n   If it succeeds, results are put in BUFP (if it returns an error, the\n   contents of BUFP are undefined):\n     `buffer' is the compiled pattern;\n     `syntax' is set to SYNTAX;\n     `used' is set to the length of the compiled pattern;\n     `fastmap_accurate' is zero;\n     `re_nsub' is the number of subexpressions in PATTERN;\n     `not_bol' and `not_eol' are zero;\n   \n   The `fastmap' and `newline_anchor' fields are neither\n   examined nor set.  */\n\nstatic reg_errcode_t\nregex_compile (pattern, size, syntax, bufp)\n     const char *pattern;\n     int size;\n     reg_syntax_t syntax;\n     struct re_pattern_buffer *bufp;\n{\n  /* We fetch characters from PATTERN here.  Even though PATTERN is\n     `char *' (i.e., signed), we declare these variables as unsigned, so\n     they can be reliably used as array indices.  */\n  register unsigned char c, c1;\n  \n  /* A random tempory spot in PATTERN.  */\n  const char *p1;\n\n  /* Points to the end of the buffer, where we should append.  */\n  register unsigned char *b;\n  \n  /* Keeps track of unclosed groups.  */\n  compile_stack_type compile_stack;\n\n  /* Points to the current (ending) position in the pattern.  */\n  const char *p = pattern;\n  const char *pend = pattern + size;\n  \n  /* How to translate the characters in the pattern.  */\n  char *translate = bufp->translate;\n\n  /* Address of the count-byte of the most recently inserted `exactn'\n     command.  This makes it possible to tell if a new exact-match\n     character can be added to that command or if the character requires\n     a new `exactn' command.  */\n  unsigned char *pending_exact = 0;\n\n  /* Address of start of the most recently finished expression.\n     This tells, e.g., postfix * where to find the start of its\n     operand.  Reset at the beginning of groups and alternatives.  */\n  unsigned char *laststart = 0;\n\n  /* Address of beginning of regexp, or inside of last group.  */\n  unsigned char *begalt;\n\n  /* Place in the uncompiled pattern (i.e., the {) to\n     which to go back if the interval is invalid.  */\n  const char *beg_interval;\n                \n  /* Address of the place where a forward jump should go to the end of\n     the containing expression.  Each alternative of an `or' -- except the\n     last -- ends with a forward jump of this sort.  */\n  unsigned char *fixup_alt_jump = 0;\n\n  /* Counts open-groups as they are encountered.  Remembered for the\n     matching close-group on the compile stack, so the same register\n     number is put in the stop_memory as the start_memory.  */\n  regnum_t regnum = 0;\n\n#ifdef DEBUG\n  DEBUG_PRINT1 (\"\\nCompiling pattern: \");\n  if (debug)\n    {\n      unsigned debug_count;\n      \n      for (debug_count = 0; debug_count < size; debug_count++)\n        printchar (pattern[debug_count]);\n      putchar ('\\n');\n    }\n#endif /* DEBUG */\n\n  /* Initialize the compile stack.  */\n  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);\n  if (compile_stack.stack == NULL)\n    return REG_ESPACE;\n\n  compile_stack.size = INIT_COMPILE_STACK_SIZE;\n  compile_stack.avail = 0;\n\n  /* Initialize the pattern buffer.  */\n  bufp->syntax = syntax;\n  bufp->fastmap_accurate = 0;\n  bufp->not_bol = bufp->not_eol = 0;\n\n  /* Set `used' to zero, so that if we return an error, the pattern\n     printer (for debugging) will think there's no pattern.  We reset it\n     at the end.  */\n  bufp->used = 0;\n  \n  /* Always count groups, whether or not bufp->no_sub is set.  */\n  bufp->re_nsub = 0;\t\t\t\t\n\n#if !defined (emacs) && !defined (SYNTAX_TABLE)\n  /* Initialize the syntax table.  */\n   init_syntax_once ();\n#endif\n\n  if (bufp->allocated == 0)\n    {\n      if (bufp->buffer)\n\t{ /* If zero allocated, but buffer is non-null, try to realloc\n             enough space.  This loses if buffer's address is bogus, but\n             that is the user's responsibility.  */\n          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);\n        }\n      else\n        { /* Caller did not allocate a buffer.  Do it for them.  */\n          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);\n        }\n      if (!bufp->buffer) return REG_ESPACE;\n\n      bufp->allocated = INIT_BUF_SIZE;\n    }\n\n  begalt = b = bufp->buffer;\n\n  /* Loop through the uncompiled pattern until we're at the end.  */\n  while (p != pend)\n    {\n      PATFETCH (c);\n\n      switch (c)\n        {\n        case '^':\n          {\n            if (   /* If at start of pattern, it's an operator.  */\n                   p == pattern + 1\n                   /* If context independent, it's an operator.  */\n                || syntax & RE_CONTEXT_INDEP_ANCHORS\n                   /* Otherwise, depends on what's come before.  */\n                || at_begline_loc_p (pattern, p, syntax))\n              BUF_PUSH (begline);\n            else\n              goto normal_char;\n          }\n          break;\n\n\n        case '$':\n          {\n            if (   /* If at end of pattern, it's an operator.  */\n                   p == pend \n                   /* If context independent, it's an operator.  */\n                || syntax & RE_CONTEXT_INDEP_ANCHORS\n                   /* Otherwise, depends on what's next.  */\n                || at_endline_loc_p (p, pend, syntax))\n               BUF_PUSH (endline);\n             else\n               goto normal_char;\n           }\n           break;\n\n\n\tcase '+':\n        case '?':\n          if ((syntax & RE_BK_PLUS_QM)\n              || (syntax & RE_LIMITED_OPS))\n            goto normal_char;\n        handle_plus:\n        case '*':\n          /* If there is no previous pattern... */\n          if (!laststart)\n            {\n              if (syntax & RE_CONTEXT_INVALID_OPS)\n                return REG_BADRPT;\n              else if (!(syntax & RE_CONTEXT_INDEP_OPS))\n                goto normal_char;\n            }\n\n          {\n            /* Are we optimizing this jump?  */\n            boolean keep_string_p = false;\n            \n            /* 1 means zero (many) matches is allowed.  */\n            char zero_times_ok = 0, many_times_ok = 0;\n\n            /* If there is a sequence of repetition chars, collapse it\n               down to just one (the right one).  We can't combine\n               interval operators with these because of, e.g., `a{2}*',\n               which should only match an even number of `a's.  */\n\n            for (;;)\n              {\n                zero_times_ok |= c != '+';\n                many_times_ok |= c != '?';\n\n                if (p == pend)\n                  break;\n\n                PATFETCH (c);\n\n                if (c == '*'\n                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))\n                  ;\n\n                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\\\')\n                  {\n                    if (p == pend) return REG_EESCAPE;\n\n                    PATFETCH (c1);\n                    if (!(c1 == '+' || c1 == '?'))\n                      {\n                        PATUNFETCH;\n                        PATUNFETCH;\n                        break;\n                      }\n\n                    c = c1;\n                  }\n                else\n                  {\n                    PATUNFETCH;\n                    break;\n                  }\n\n                /* If we get here, we found another repeat character.  */\n               }\n\n            /* Star, etc. applied to an empty pattern is equivalent\n               to an empty pattern.  */\n            if (!laststart)  \n              break;\n\n            /* Now we know whether or not zero matches is allowed\n               and also whether or not two or more matches is allowed.  */\n            if (many_times_ok)\n              { /* More than one repetition is allowed, so put in at the\n                   end a backward relative jump from `b' to before the next\n                   jump we're going to put in below (which jumps from\n                   laststart to after this jump).  \n\n                   But if we are at the `*' in the exact sequence `.*\\n',\n                   insert an unconditional jump backwards to the .,\n                   instead of the beginning of the loop.  This way we only\n                   push a failure point once, instead of every time\n                   through the loop.  */\n                assert (p - 1 > pattern);\n\n                /* Allocate the space for the jump.  */\n                GET_BUFFER_SPACE (3);\n\n                /* We know we are not at the first character of the pattern,\n                   because laststart was nonzero.  And we've already\n                   incremented `p', by the way, to be the character after\n                   the `*'.  Do we have to do something analogous here\n                   for null bytes, because of RE_DOT_NOT_NULL?  */\n                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')\n\t\t    && zero_times_ok\n                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\\n')\n                    && !(syntax & RE_DOT_NEWLINE))\n                  { /* We have .*\\n.  */\n                    STORE_JUMP (jump, b, laststart);\n                    keep_string_p = true;\n                  }\n                else\n                  /* Anything else.  */\n                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);\n\n                /* We've added more stuff to the buffer.  */\n                b += 3;\n              }\n\n            /* On failure, jump from laststart to b + 3, which will be the\n               end of the buffer after this jump is inserted.  */\n            GET_BUFFER_SPACE (3);\n            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump\n                                       : on_failure_jump,\n                         laststart, b + 3);\n            pending_exact = 0;\n            b += 3;\n\n            if (!zero_times_ok)\n              {\n                /* At least one repetition is required, so insert a\n                   `dummy_failure_jump' before the initial\n                   `on_failure_jump' instruction of the loop. This\n                   effects a skip over that instruction the first time\n                   we hit that loop.  */\n                GET_BUFFER_SPACE (3);\n                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);\n                b += 3;\n              }\n            }\n\t  break;\n\n\n\tcase '.':\n          laststart = b;\n          BUF_PUSH (anychar);\n          break;\n\n\n        case '[':\n          {\n            boolean had_char_class = false;\n\n            if (p == pend) return REG_EBRACK;\n\n            /* Ensure that we have enough space to push a charset: the\n               opcode, the length count, and the bitset; 34 bytes in all.  */\n\t    GET_BUFFER_SPACE (34);\n\n            laststart = b;\n\n            /* We test `*p == '^' twice, instead of using an if\n               statement, so we only need one BUF_PUSH.  */\n            BUF_PUSH (*p == '^' ? charset_not : charset); \n            if (*p == '^')\n              p++;\n\n            /* Remember the first position in the bracket expression.  */\n            p1 = p;\n\n            /* Push the number of bytes in the bitmap.  */\n            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);\n\n            /* Clear the whole map.  */\n            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);\n\n            /* charset_not matches newline according to a syntax bit.  */\n            if ((re_opcode_t) b[-2] == charset_not\n                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))\n              SET_LIST_BIT ('\\n');\n\n            /* Read in characters and ranges, setting map bits.  */\n            for (;;)\n              {\n                if (p == pend) return REG_EBRACK;\n\n                PATFETCH (c);\n\n                /* \\ might escape characters inside [...] and [^...].  */\n                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\\\')\n                  {\n                    if (p == pend) return REG_EESCAPE;\n\n                    PATFETCH (c1);\n                    SET_LIST_BIT (c1);\n                    continue;\n                  }\n\n                /* Could be the end of the bracket expression.  If it's\n                   not (i.e., when the bracket expression is `[]' so\n                   far), the ']' character bit gets set way below.  */\n                if (c == ']' && p != p1 + 1)\n                  break;\n\n                /* Look ahead to see if it's a range when the last thing\n                   was a character class.  */\n                if (had_char_class && c == '-' && *p != ']')\n                  return REG_ERANGE;\n\n                /* Look ahead to see if it's a range when the last thing\n                   was a character: if this is a hyphen not at the\n                   beginning or the end of a list, then it's the range\n                   operator.  */\n                if (c == '-' \n                    && !(p - 2 >= pattern && p[-2] == '[') \n                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')\n                    && *p != ']')\n                  {\n                    reg_errcode_t ret\n                      = compile_range (&p, pend, translate, syntax, b);\n                    if (ret != REG_NOERROR) return ret;\n                  }\n\n                else if (p[0] == '-' && p[1] != ']')\n                  { /* This handles ranges made up of characters only.  */\n                    reg_errcode_t ret;\n\n\t\t    /* Move past the `-'.  */\n                    PATFETCH (c1);\n                    \n                    ret = compile_range (&p, pend, translate, syntax, b);\n                    if (ret != REG_NOERROR) return ret;\n                  }\n\n                /* See if we're at the beginning of a possible character\n                   class.  */\n\n                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')\n                  { /* Leave room for the null.  */\n                    char str[CHAR_CLASS_MAX_LENGTH + 1];\n\n                    PATFETCH (c);\n                    c1 = 0;\n\n                    /* If pattern is `[[:'.  */\n                    if (p == pend) return REG_EBRACK;\n\n                    for (;;)\n                      {\n                        PATFETCH (c);\n                        if (c == ':' || c == ']' || p == pend\n                            || c1 == CHAR_CLASS_MAX_LENGTH)\n                          break;\n                        str[c1++] = c;\n                      }\n                    str[c1] = '\\0';\n\n                    /* If isn't a word bracketed by `[:' and:`]':\n                       undo the ending character, the letters, and leave \n                       the leading `:' and `[' (but set bits for them).  */\n                    if (c == ':' && *p == ']')\n                      {\n                        int ch;\n                        boolean is_alnum = STREQ (str, \"alnum\");\n                        boolean is_alpha = STREQ (str, \"alpha\");\n                        boolean is_blank = STREQ (str, \"blank\");\n                        boolean is_cntrl = STREQ (str, \"cntrl\");\n                        boolean is_digit = STREQ (str, \"digit\");\n                        boolean is_graph = STREQ (str, \"graph\");\n                        boolean is_lower = STREQ (str, \"lower\");\n                        boolean is_print = STREQ (str, \"print\");\n                        boolean is_punct = STREQ (str, \"punct\");\n                        boolean is_space = STREQ (str, \"space\");\n                        boolean is_upper = STREQ (str, \"upper\");\n                        boolean is_xdigit = STREQ (str, \"xdigit\");\n                        \n                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;\n\n                        /* Throw away the ] at the end of the character\n                           class.  */\n                        PATFETCH (c);\t\t\t\t\t\n\n                        if (p == pend) return REG_EBRACK;\n\n                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)\n                          {\n                            if (   (is_alnum  && ISALNUM (ch))\n                                || (is_alpha  && ISALPHA (ch))\n                                || (is_blank  && ISBLANK (ch))\n                                || (is_cntrl  && ISCNTRL (ch))\n                                || (is_digit  && ISDIGIT (ch))\n                                || (is_graph  && ISGRAPH (ch))\n                                || (is_lower  && ISLOWER (ch))\n                                || (is_print  && ISPRINT (ch))\n                                || (is_punct  && ISPUNCT (ch))\n                                || (is_space  && ISSPACE (ch))\n                                || (is_upper  && ISUPPER (ch))\n                                || (is_xdigit && ISXDIGIT (ch)))\n                            SET_LIST_BIT (ch);\n                          }\n                        had_char_class = true;\n                      }\n                    else\n                      {\n                        c1++;\n                        while (c1--)    \n                          PATUNFETCH;\n                        SET_LIST_BIT ('[');\n                        SET_LIST_BIT (':');\n                        had_char_class = false;\n                      }\n                  }\n                else\n                  {\n                    had_char_class = false;\n                    SET_LIST_BIT (c);\n                  }\n              }\n\n            /* Discard any (non)matching list bytes that are all 0 at the\n               end of the map.  Decrease the map-length byte too.  */\n            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) \n              b[-1]--; \n            b += b[-1];\n          }\n          break;\n\n\n\tcase '(':\n          if (syntax & RE_NO_BK_PARENS)\n            goto handle_open;\n          else\n            goto normal_char;\n\n\n        case ')':\n          if (syntax & RE_NO_BK_PARENS)\n            goto handle_close;\n          else\n            goto normal_char;\n\n\n        case '\\n':\n          if (syntax & RE_NEWLINE_ALT)\n            goto handle_alt;\n          else\n            goto normal_char;\n\n\n\tcase '|':\n          if (syntax & RE_NO_BK_VBAR)\n            goto handle_alt;\n          else\n            goto normal_char;\n\n\n        case '{':\n           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)\n             goto handle_interval;\n           else\n             goto normal_char;\n\n\n        case '\\\\':\n          if (p == pend) return REG_EESCAPE;\n\n          /* Do not translate the character after the \\, so that we can\n             distinguish, e.g., \\B from \\b, even if we normally would\n             translate, e.g., B to b.  */\n          PATFETCH_RAW (c);\n\n          switch (c)\n            {\n            case '(':\n              if (syntax & RE_NO_BK_PARENS)\n                goto normal_backslash;\n\n            handle_open:\n              bufp->re_nsub++;\n              regnum++;\n\n              if (COMPILE_STACK_FULL)\n                { \n                  RETALLOC (compile_stack.stack, compile_stack.size << 1,\n                            compile_stack_elt_t);\n                  if (compile_stack.stack == NULL) return REG_ESPACE;\n\n                  compile_stack.size <<= 1;\n                }\n\n              /* These are the values to restore when we hit end of this\n                 group.  They are all relative offsets, so that if the\n                 whole pattern moves because of realloc, they will still\n                 be valid.  */\n              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;\n              COMPILE_STACK_TOP.fixup_alt_jump \n                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;\n              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;\n              COMPILE_STACK_TOP.regnum = regnum;\n\n              /* We will eventually replace the 0 with the number of\n                 groups inner to this one.  But do not push a\n                 start_memory for groups beyond the last one we can\n                 represent in the compiled pattern.  */\n              if (regnum <= MAX_REGNUM)\n                {\n                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;\n                  BUF_PUSH_3 (start_memory, regnum, 0);\n                }\n                \n              compile_stack.avail++;\n\n              fixup_alt_jump = 0;\n              laststart = 0;\n              begalt = b;\n\t      /* If we've reached MAX_REGNUM groups, then this open\n\t\t won't actually generate any code, so we'll have to\n\t\t clear pending_exact explicitly.  */\n\t      pending_exact = 0;\n              break;\n\n\n            case ')':\n              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;\n\n              if (COMPILE_STACK_EMPTY)\n                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)\n                  goto normal_backslash;\n                else\n                  return REG_ERPAREN;\n\n            handle_close:\n              if (fixup_alt_jump)\n                { /* Push a dummy failure point at the end of the\n                     alternative for a possible future\n                     `pop_failure_jump' to pop.  See comments at\n                     `push_dummy_failure' in `re_match_2'.  */\n                  BUF_PUSH (push_dummy_failure);\n                  \n                  /* We allocated space for this jump when we assigned\n                     to `fixup_alt_jump', in the `handle_alt' case below.  */\n                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);\n                }\n\n              /* See similar code for backslashed left paren above.  */\n              if (COMPILE_STACK_EMPTY)\n                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)\n                  goto normal_char;\n                else\n                  return REG_ERPAREN;\n\n              /* Since we just checked for an empty stack above, this\n                 ``can't happen''.  */\n              assert (compile_stack.avail != 0);\n              {\n                /* We don't just want to restore into `regnum', because\n                   later groups should continue to be numbered higher,\n                   as in `(ab)c(de)' -- the second group is #2.  */\n                regnum_t this_group_regnum;\n\n                compile_stack.avail--;\t\t\n                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;\n                fixup_alt_jump\n                  = COMPILE_STACK_TOP.fixup_alt_jump\n                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 \n                    : 0;\n                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;\n                this_group_regnum = COMPILE_STACK_TOP.regnum;\n\t\t/* If we've reached MAX_REGNUM groups, then this open\n\t\t   won't actually generate any code, so we'll have to\n\t\t   clear pending_exact explicitly.  */\n\t\tpending_exact = 0;\n\n                /* We're at the end of the group, so now we know how many\n                   groups were inside this one.  */\n                if (this_group_regnum <= MAX_REGNUM)\n                  {\n                    unsigned char *inner_group_loc\n                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;\n                    \n                    *inner_group_loc = regnum - this_group_regnum;\n                    BUF_PUSH_3 (stop_memory, this_group_regnum,\n                                regnum - this_group_regnum);\n                  }\n              }\n              break;\n\n\n            case '|':\t\t\t\t\t/* `\\|'.  */\n              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)\n                goto normal_backslash;\n            handle_alt:\n              if (syntax & RE_LIMITED_OPS)\n                goto normal_char;\n\n              /* Insert before the previous alternative a jump which\n                 jumps to this alternative if the former fails.  */\n              GET_BUFFER_SPACE (3);\n              INSERT_JUMP (on_failure_jump, begalt, b + 6);\n              pending_exact = 0;\n              b += 3;\n\n              /* The alternative before this one has a jump after it\n                 which gets executed if it gets matched.  Adjust that\n                 jump so it will jump to this alternative's analogous\n                 jump (put in below, which in turn will jump to the next\n                 (if any) alternative's such jump, etc.).  The last such\n                 jump jumps to the correct final destination.  A picture:\n                          _____ _____ \n                          |   | |   |   \n                          |   v |   v \n                         a | b   | c   \n\n                 If we are at `b', then fixup_alt_jump right now points to a\n                 three-byte space after `a'.  We'll put in the jump, set\n                 fixup_alt_jump to right after `b', and leave behind three\n                 bytes which we'll fill in when we get to after `c'.  */\n\n              if (fixup_alt_jump)\n                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);\n\n              /* Mark and leave space for a jump after this alternative,\n                 to be filled in later either by next alternative or\n                 when know we're at the end of a series of alternatives.  */\n              fixup_alt_jump = b;\n              GET_BUFFER_SPACE (3);\n              b += 3;\n\n              laststart = 0;\n              begalt = b;\n              break;\n\n\n            case '{': \n              /* If \\{ is a literal.  */\n              if (!(syntax & RE_INTERVALS)\n                     /* If we're at `\\{' and it's not the open-interval \n                        operator.  */\n                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n                  || (p - 2 == pattern  &&  p == pend))\n                goto normal_backslash;\n\n            handle_interval:\n              {\n                /* If got here, then the syntax allows intervals.  */\n\n                /* At least (most) this many matches must be made.  */\n                int lower_bound = -1, upper_bound = -1;\n\n                beg_interval = p - 1;\n\n                if (p == pend)\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else\n                      return REG_EBRACE;\n                  }\n\n                GET_UNSIGNED_NUMBER (lower_bound);\n\n                if (c == ',')\n                  {\n                    GET_UNSIGNED_NUMBER (upper_bound);\n                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;\n                  }\n                else\n                  /* Interval such as `{1}' => match exactly once. */\n                  upper_bound = lower_bound;\n\n                if (lower_bound < 0 || upper_bound > RE_DUP_MAX\n                    || lower_bound > upper_bound)\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else \n                      return REG_BADBR;\n                  }\n\n                if (!(syntax & RE_NO_BK_BRACES)) \n                  {\n                    if (c != '\\\\') return REG_EBRACE;\n\n                    PATFETCH (c);\n                  }\n\n                if (c != '}')\n                  {\n                    if (syntax & RE_NO_BK_BRACES)\n                      goto unfetch_interval;\n                    else \n                      return REG_BADBR;\n                  }\n\n                /* We just parsed a valid interval.  */\n\n                /* If it's invalid to have no preceding re.  */\n                if (!laststart)\n                  {\n                    if (syntax & RE_CONTEXT_INVALID_OPS)\n                      return REG_BADRPT;\n                    else if (syntax & RE_CONTEXT_INDEP_OPS)\n                      laststart = b;\n                    else\n                      goto unfetch_interval;\n                  }\n\n                /* If the upper bound is zero, don't want to succeed at\n                   all; jump from `laststart' to `b + 3', which will be\n                   the end of the buffer after we insert the jump.  */\n                 if (upper_bound == 0)\n                   {\n                     GET_BUFFER_SPACE (3);\n                     INSERT_JUMP (jump, laststart, b + 3);\n                     b += 3;\n                   }\n\n                 /* Otherwise, we have a nontrivial interval.  When\n                    we're all done, the pattern will look like:\n                      set_number_at <jump count> <upper bound>\n                      set_number_at <succeed_n count> <lower bound>\n                      succeed_n <after jump addr> <succed_n count>\n                      <body of loop>\n                      jump_n <succeed_n addr> <jump count>\n                    (The upper bound and `jump_n' are omitted if\n                    `upper_bound' is 1, though.)  */\n                 else \n                   { /* If the upper bound is > 1, we need to insert\n                        more at the end of the loop.  */\n                     unsigned nbytes = 10 + (upper_bound > 1) * 10;\n\n                     GET_BUFFER_SPACE (nbytes);\n\n                     /* Initialize lower bound of the `succeed_n', even\n                        though it will be set during matching by its\n                        attendant `set_number_at' (inserted next),\n                        because `re_compile_fastmap' needs to know.\n                        Jump to the `jump_n' we might insert below.  */\n                     INSERT_JUMP2 (succeed_n, laststart,\n                                   b + 5 + (upper_bound > 1) * 5,\n                                   lower_bound);\n                     b += 5;\n\n                     /* Code to initialize the lower bound.  Insert \n                        before the `succeed_n'.  The `5' is the last two\n                        bytes of this `set_number_at', plus 3 bytes of\n                        the following `succeed_n'.  */\n                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);\n                     b += 5;\n\n                     if (upper_bound > 1)\n                       { /* More than one repetition is allowed, so\n                            append a backward jump to the `succeed_n'\n                            that starts this interval.\n                            \n                            When we've reached this during matching,\n                            we'll have matched the interval once, so\n                            jump back only `upper_bound - 1' times.  */\n                         STORE_JUMP2 (jump_n, b, laststart + 5,\n                                      upper_bound - 1);\n                         b += 5;\n\n                         /* The location we want to set is the second\n                            parameter of the `jump_n'; that is `b-2' as\n                            an absolute address.  `laststart' will be\n                            the `set_number_at' we're about to insert;\n                            `laststart+3' the number to set, the source\n                            for the relative address.  But we are\n                            inserting into the middle of the pattern --\n                            so everything is getting moved up by 5.\n                            Conclusion: (b - 2) - (laststart + 3) + 5,\n                            i.e., b - laststart.\n                            \n                            We insert this at the beginning of the loop\n                            so that if we fail during matching, we'll\n                            reinitialize the bounds.  */\n                         insert_op2 (set_number_at, laststart, b - laststart,\n                                     upper_bound - 1, b);\n                         b += 5;\n                       }\n                   }\n                pending_exact = 0;\n                beg_interval = NULL;\n              }\n              break;\n\n            unfetch_interval:\n              /* If an invalid interval, match the characters as literals.  */\n               assert (beg_interval);\n               p = beg_interval;\n               beg_interval = NULL;\n\n               /* normal_char and normal_backslash need `c'.  */\n               PATFETCH (c);\t\n\n               if (!(syntax & RE_NO_BK_BRACES))\n                 {\n                   if (p > pattern  &&  p[-1] == '\\\\')\n                     goto normal_backslash;\n                 }\n               goto normal_char;\n\n#ifdef emacs\n            /* There is no way to specify the before_dot and after_dot\n               operators.  rms says this is ok.  --karl  */\n            case '=':\n              BUF_PUSH (at_dot);\n              break;\n\n            case 's':\t\n              laststart = b;\n              PATFETCH (c);\n              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);\n              break;\n\n            case 'S':\n              laststart = b;\n              PATFETCH (c);\n              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);\n              break;\n#endif /* emacs */\n\n\n            case 'w':\n              laststart = b;\n              BUF_PUSH (wordchar);\n              break;\n\n\n            case 'W':\n              laststart = b;\n              BUF_PUSH (notwordchar);\n              break;\n\n\n            case '<':\n              BUF_PUSH (wordbeg);\n              break;\n\n            case '>':\n              BUF_PUSH (wordend);\n              break;\n\n            case 'b':\n              BUF_PUSH (wordbound);\n              break;\n\n            case 'B':\n              BUF_PUSH (notwordbound);\n              break;\n\n            case '`':\n              BUF_PUSH (begbuf);\n              break;\n\n            case '\\'':\n              BUF_PUSH (endbuf);\n              break;\n\n            case '1': case '2': case '3': case '4': case '5':\n            case '6': case '7': case '8': case '9':\n              if (syntax & RE_NO_BK_REFS)\n                goto normal_char;\n\n              c1 = c - '0';\n\n              if (c1 > regnum)\n                return REG_ESUBREG;\n\n              /* Can't back reference to a subexpression if inside of it.  */\n              if (group_in_compile_stack (compile_stack, c1))\n                goto normal_char;\n\n              laststart = b;\n              BUF_PUSH_2 (duplicate, c1);\n              break;\n\n\n            case '+':\n            case '?':\n              if (syntax & RE_BK_PLUS_QM)\n                goto handle_plus;\n              else\n                goto normal_backslash;\n\n            default:\n            normal_backslash:\n              /* You might think it would be useful for \\ to mean\n                 not to translate; but if we don't translate it\n                 it will never match anything.  */\n              c = TRANSLATE (c);\n              goto normal_char;\n            }\n          break;\n\n\n\tdefault:\n        /* Expects the character in `c'.  */\n\tnormal_char:\n\t      /* If no exactn currently being built.  */\n          if (!pending_exact \n\n              /* If last exactn not at current position.  */\n              || pending_exact + *pending_exact + 1 != b\n              \n              /* We have only one byte following the exactn for the count.  */\n\t      || *pending_exact == (1 << BYTEWIDTH) - 1\n\n              /* If followed by a repetition operator.  */\n              || *p == '*' || *p == '^'\n\t      || ((syntax & RE_BK_PLUS_QM)\n\t\t  ? *p == '\\\\' && (p[1] == '+' || p[1] == '?')\n\t\t  : (*p == '+' || *p == '?'))\n\t      || ((syntax & RE_INTERVALS)\n                  && ((syntax & RE_NO_BK_BRACES)\n\t\t      ? *p == '{'\n                      : (p[0] == '\\\\' && p[1] == '{'))))\n\t    {\n\t      /* Start building a new exactn.  */\n              \n              laststart = b;\n\n\t      BUF_PUSH_2 (exactn, 0);\n\t      pending_exact = b - 1;\n            }\n            \n\t  BUF_PUSH (c);\n          (*pending_exact)++;\n\t  break;\n        } /* switch (c) */\n    } /* while p != pend */\n\n  \n  /* Through the pattern now.  */\n  \n  if (fixup_alt_jump)\n    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);\n\n  if (!COMPILE_STACK_EMPTY) \n    return REG_EPAREN;\n\n  free (compile_stack.stack);\n\n  /* We have succeeded; set the length of the buffer.  */\n  bufp->used = b - bufp->buffer;\n\n#ifdef DEBUG\n  if (debug)\n    {\n      DEBUG_PRINT1 (\"\\nCompiled pattern: \\n\");\n      print_compiled_pattern (bufp);\n    }\n#endif /* DEBUG */\n\n  return REG_NOERROR;\n} /* regex_compile */\n\f\n/* Subroutines for `regex_compile'.  */\n\n/* Store OP at LOC followed by two-byte integer parameter ARG.  */\n\nstatic void\nstore_op1 (op, loc, arg)\n    re_opcode_t op;\n    unsigned char *loc;\n    int arg;\n{\n  *loc = (unsigned char) op;\n  STORE_NUMBER (loc + 1, arg);\n}\n\n\n/* Like `store_op1', but\" for 'two two-byte parameters ARG1 and ARG2.  */\n\nstatic void\nstore_op2 (op, loc, arg1, arg2)\n    re_opcode_t op;\n    unsigned char *loc;\n    int arg1, arg2;\n{\n  *loc = (unsigned char) op;\n  STORE_NUMBER (loc + 1, arg1);\n  STORE_NUMBER (loc + 3, arg2);\n}\n\n\n/* Copy the bytes from LOC to END to open up three bytes of space at LOC\n   for OP followed by two-byte integer parameter ARG.  */\n\nstatic void\ninsert_op1 (op, loc, arg, end)\n    re_opcode_t op;\n    unsigned char *loc;\n    int arg;\n    unsigned char *end;    \n{\n  register unsigned char *pfrom = end;\n  register unsigned char *pto = end + 3;\n\n  while (pfrom != loc)\n    *--pto = *--pfrom;\n    \n  store_op1 (op, loc, arg);\n}\n\n\n/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */\n\nstatic void\ninsert_op2 (op, loc, arg1, arg2, end)\n    re_opcode_t op;\n    unsigned char *loc;\n    int arg1, arg2;\n    unsigned char *end;    \n{\n  register unsigned char *pfrom = end;\n  register unsigned char *pto = end + 5;\n\n  while (pfrom != loc)\n    *--pto = *--pfrom;\n    \n  store_op2 (op, loc, arg1, arg2);\n}\n\n\n/* P points to just after a ^ in PATTERN.  Return true if that ^ comes\n   after an alternative or a begin-subexpression.  We assume there is at\n   least one character before the ^.  */\n\nstatic boolean\nat_begline_loc_p (pattern, p, syntax)\n    const char *pattern, *p;\n    reg_syntax_t syntax;\n{\n  const char *prev = p - 2;\n  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\\\';\n  \n  return\n       /* After a subexpression?  */\n       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))\n       /* After an alternative?  */\n    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));\n}\n\n\n/* The dual of at_begline_loc_p.  This one is for $.  We assume there is\n   at least one character after the $, i.e., `P < PEND'.  */\n\nstatic boolean\nat_endline_loc_p (p, pend, syntax)\n    const char *p, *pend;\n    int syntax;\n{\n  const char *next = p;\n  boolean next_backslash = *next == '\\\\';\n  const char *next_next = p + 1 < pend ? p + 1 : NULL;\n  \n  return\n       /* Before a subexpression?  */\n       (syntax & RE_NO_BK_PARENS ? *next == ')'\n        : next_backslash && next_next && *next_next == ')')\n       /* Before an alternative?  */\n    || (syntax & RE_NO_BK_VBAR ? *next == '|'\n        : next_backslash && next_next && *next_next == '|');\n}\n\n\n/* Returns true if REGNUM is in one of COMPILE_STACK's elements and \n   false if it's not.  */\n\nstatic boolean\ngroup_in_compile_stack (compile_stack, regnum)\n    compile_stack_type compile_stack;\n    regnum_t regnum;\n{\n  int this_element;\n\n  for (this_element = compile_stack.avail - 1;  \n       this_element >= 0; \n       this_element--)\n    if (compile_stack.stack[this_element].regnum == regnum)\n      return true;\n\n  return false;\n}\n\n\n/* Read the ending character of a range (in a bracket expression) from the\n   uncompiled pattern *P_PTR (which ends at PEND).  We assume the\n   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)\n   Then we set the translation of all bits between the starting and\n   ending characters (inclusive) in the compiled pattern B.\n   \n   Return an error code.\n   \n   We use these short variable names so we can use the same macros as\n   `regex_compile' itself.  */\n\nstatic reg_errcode_t\ncompile_range (p_ptr, pend, translate, syntax, b)\n    const char **p_ptr, *pend;\n    char *translate;\n    reg_syntax_t syntax;\n    unsigned char *b;\n{\n  unsigned this_char;\n\n  const char *p = *p_ptr;\n  int range_start, range_end;\n  \n  if (p == pend)\n    return REG_ERANGE;\n\n  /* Even though the pattern is a signed `char *', we need to fetch\n     with unsigned char *'s; if the high bit of the pattern character\n     is set, the range endpoints will be negative if we fetch using a\n     signed char *.\n\n     We also want to fetch the endpoints without translating them; the \n     appropriate translation is done in the bit-setting loop below.  */\n  range_start = ((unsigned char *) p)[-2];\n  range_end   = ((unsigned char *) p)[0];\n\n  /* Have to increment the pointer into the pattern string, so the\n     caller isn't still at the ending character.  */\n  (*p_ptr)++;\n\n  /* If the start is after the end, the range is empty.  */\n  if (range_start > range_end)\n    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;\n\n  /* Here we see why `this_char' has to be larger than an `unsigned\n     char' -- the range is inclusive, so if `range_end' == 0xff\n     (assuming 8-bit characters), we would otherwise go into an infinite\n     loop, since all characters <= 0xff.  */\n  for (this_char = range_start; this_char <= range_end; this_char++)\n    {\n      SET_LIST_BIT (TRANSLATE (this_char));\n    }\n  \n  return REG_NOERROR;\n}\n\f\n/* Failure stack declarations and macros; both re_compile_fastmap and\n   re_match_2 use a failure stack.  These have to be macros because of\n   REGEX_ALLOCATE.  */\n   \n\n/* Number of failure points for which to initially allocate space\n   when matching.  If this number is exceeded, we allocate more\n   space, so it is not a hard limit.  */\n#ifndef INIT_FAILURE_ALLOC\n#define INIT_FAILURE_ALLOC 5\n#endif\n\n/* Roughly the maximum number of failure points on the stack.  Would be\n   exactly that if always used MAX_FAILURE_SPACE each time we failed.\n   This is a variable only so users of regex can assign to it; we never\n   change it ourselves.  */\nint re_max_failures = 2000;\n\ntypedef const unsigned char *fail_stack_elt_t;\n\ntypedef struct\n{\n  fail_stack_elt_t *stack;\n  unsigned size;\n  unsigned avail;\t\t\t/* Offset of next open position.  */\n} fail_stack_type;\n\n#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)\n#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)\n#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)\n#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])\n\n\n/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */\n\n#define INIT_FAIL_STACK()\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    fail_stack.stack = (fail_stack_elt_t *)\t\t\t\t\\\n      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (fail_stack.stack == NULL)\t\t\t\t\t\\\n      return -2;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    fail_stack.size = INIT_FAILURE_ALLOC;\t\t\t\t\\\n    fail_stack.avail = 0;\t\t\t\t\t\t\\\n  } while (0)\n\n\n/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.\n\n   Return 1 if succeeds, and 0 if either ran out of memory\n   allocating space for it or it was already too large.  \n   \n   REGEX_REALLOCATE requires `destination' be declared.   */\n\n#define DOUBLE_FAIL_STACK(fail_stack)\t\t\t\t\t\\\n  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS\t\t\\\n   ? 0\t\t\t\t\t\t\t\t\t\\\n   : ((fail_stack).stack = (fail_stack_elt_t *)\t\t\t\t\\\n        REGEX_REALLOCATE ((fail_stack).stack, \t\t\t\t\\\n          (fail_stack).size * sizeof (fail_stack_elt_t),\t\t\\\n          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),\t\\\n\t\t\t\t\t\t\t\t\t\\\n      (fail_stack).stack == NULL\t\t\t\t\t\\\n      ? 0\t\t\t\t\t\t\t\t\\\n      : ((fail_stack).size <<= 1, \t\t\t\t\t\\\n         1)))\n\n\n/* Push PATTERN_OP on FAIL_STACK. \n\n   Return 1 if was able to do so and 0 if ran out of memory allocating\n   space to do so.  */\n#define PUSH_PATTERN_OP(pattern_op, fail_stack)\t\t\t\t\\\n  ((FAIL_STACK_FULL ()\t\t\t\t\t\t\t\\\n    && !DOUBLE_FAIL_STACK (fail_stack))\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,\t\t\\\n       1))\n\n/* This pushes an item onto the failure stack.  Must be a four-byte\n   value.  Assumes the variable `fail_stack'.  Probably should only\n   be called from within `PUSH_FAILURE_POINT'.  */\n#define PUSH_FAILURE_ITEM(item)\t\t\t\t\t\t\\\n  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item\n\n/* The complement operation.  Assumes `fail_stack' is nonempty.  */\n#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]\n\n/* Used to omit pushing failure point id's when we're not debugging.  */\n#ifdef DEBUG\n#define DEBUG_PUSH PUSH_FAILURE_ITEM\n#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()\n#else\n#define DEBUG_PUSH(item)\n#define DEBUG_POP(item_addr)\n#endif\n\n\n/* Push the information about the state we will need\n   if we ever fail back to it.  \n   \n   Requires variables fail_stack, regstart, regend, reg_info, and\n   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be\n   declared.\n   \n   Does `return FAILURE_CODE' if runs out of memory.  */\n\n#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    char *destination;\t\t\t\t\t\t\t\\\n    /* Must be int, so when we don't save any registers, the arithmetic\t\\\n       of 0 + -1 isn't done as unsigned.  */\t\t\t\t\\\n    int this_reg;\t\t\t\t\t\t\t\\\n    \t\t\t\t\t\t\t\t\t\\\n    DEBUG_STATEMENT (failure_id++);\t\t\t\t\t\\\n    DEBUG_STATEMENT (nfailure_points_pushed++);\t\t\t\t\\\n    DEBUG_PRINT2 (\"\\nPUSH_FAILURE_POINT #%u:\\n\", failure_id);\t\t\\\n    DEBUG_PRINT2 (\"  Before push, next avail: %d\\n\", (fail_stack).avail);\\\n    DEBUG_PRINT2 (\"                     size: %d\\n\", (fail_stack).size);\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  slots needed: %d\\n\", NUM_FAILURE_ITEMS);\t\t\\\n    DEBUG_PRINT2 (\"     available: %d\\n\", REMAINING_AVAIL_SLOTS);\t\\\n\t\t\t\t\t\t\t\t\t\\\n    /* Ensure we have enough space allocated for what we will push.  */\t\\\n    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n        if (!DOUBLE_FAIL_STACK (fail_stack))\t\t\t\\\n          return failure_code;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n        DEBUG_PRINT2 (\"\\n  Doubled stack; size now: %d\\n\",\t\t\\\n\t\t       (fail_stack).size);\t\t\t\t\\\n        DEBUG_PRINT2 (\"  slots available: %d\\n\", REMAINING_AVAIL_SLOTS);\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    /* Push the info, starting with the registers.  */\t\t\t\\\n    DEBUG_PRINT1 (\"\\n\");\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;\t\\\n         this_reg++)\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tDEBUG_PRINT2 (\"  Pushing reg: %d\\n\", this_reg);\t\t\t\\\n        DEBUG_STATEMENT (num_regs_pushed++);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tDEBUG_PRINT2 (\"    start: 0x%x\\n\", regstart[this_reg]);\t\t\\\n        PUSH_FAILURE_ITEM (regstart[this_reg]);\t\t\t\t\\\n                                                                        \\\n\tDEBUG_PRINT2 (\"    end: 0x%x\\n\", regend[this_reg]);\t\t\\\n        PUSH_FAILURE_ITEM (regend[this_reg]);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tDEBUG_PRINT2 (\"    info: 0x%x\\n      \", reg_info[this_reg]);\t\\\n        DEBUG_PRINT2 (\" match_null=%d\",\t\t\t\t\t\\\n                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));\t\\\n        DEBUG_PRINT2 (\" active=%d\", IS_ACTIVE (reg_info[this_reg]));\t\\\n        DEBUG_PRINT2 (\" matched_something=%d\",\t\t\t\t\\\n                      MATCHED_SOMETHING (reg_info[this_reg]));\t\t\\\n        DEBUG_PRINT2 (\" ever_matched=%d\",\t\t\t\t\\\n                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));\t\\\n\tDEBUG_PRINT1 (\"\\n\");\t\t\t\t\t\t\\\n        PUSH_FAILURE_ITEM (reg_info[this_reg].word);\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  Pushing  low active reg: %d\\n\", lowest_active_reg);\\\n    PUSH_FAILURE_ITEM (lowest_active_reg);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  Pushing high active reg: %d\\n\", highest_active_reg);\\\n    PUSH_FAILURE_ITEM (highest_active_reg);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  Pushing pattern 0x%x: \", pattern_place);\t\t\\\n    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);\t\t\\\n    PUSH_FAILURE_ITEM (pattern_place);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  Pushing string 0x%x: `\", string_place);\t\t\\\n    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \\\n\t\t\t\t size2);\t\t\t\t\\\n    DEBUG_PRINT1 (\"'\\n\");\t\t\t\t\t\t\\\n    PUSH_FAILURE_ITEM (string_place);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    DEBUG_PRINT2 (\"  Pushing failure id: %u\\n\", failure_id);\t\t\\\n    DEBUG_PUSH (failure_id);\t\t\t\t\t\t\\\n  } while (0)\n\n/* This is the number of items that are pushed and popped on the stack\n   for each register.  */\n#define NUM_REG_ITEMS  3\n\n/* Individual items aside from the registers.  */\n#ifdef DEBUG\n#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */\n#else\n#define NUM_NONREG_ITEMS 4\n#endif\n\n/* We push at most this many items on the stack.  */\n#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)\n\n/* We actually push this many items.  */\n#define NUM_FAILURE_ITEMS\t\t\t\t\t\t\\\n  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS \t\\\n    + NUM_NONREG_ITEMS)\n\n/* How many items can still be added to the stack without overflowing it.  */\n#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)\n\n\n/* Pops what PUSH_FAIL_STACK pushes.\n\n   We restore into the parameters, all of which should be lvalues:\n     STR -- the saved data position.\n     PAT -- the saved pattern position.\n     LOW_REG, HIGH_REG -- the highest and lowest active registers.\n     REGSTART, REGEND -- arrays of string positions.\n     REG_INFO -- array of information about each subexpression.\n   \n   Also assumes the variables `fail_stack' and (if debugging), `bufp',\n   `pend', `string1', `size1', `string2', and `size2'.  */\n\n#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\\\n{\t\t\t\t\t\t\t\t\t\\\n  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)\t\t\t\\\n  int this_reg;\t\t\t\t\t\t\t\t\\\n  const unsigned char *string_temp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  assert (!FAIL_STACK_EMPTY ());\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Remove failure points and point to how many regs pushed.  */\t\\\n  DEBUG_PRINT1 (\"POP_FAILURE_POINT:\\n\");\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Before pop, next avail: %d\\n\", fail_stack.avail);\t\\\n  DEBUG_PRINT2 (\"                    size: %d\\n\", fail_stack.size);\t\\\n\t\t\t\t\t\t\t\t\t\\\n  assert (fail_stack.avail >= NUM_NONREG_ITEMS);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  DEBUG_POP (&failure_id);\t\t\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Popping failure id: %u\\n\", failure_id);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* If the saved string location is NULL, it came from an\t\t\\\n     on_failure_keep_string_jump opcode, and we want to throw away the\t\\\n     saved NULL, thus retaining our current position in the string.  */\t\\\n  string_temp = POP_FAILURE_ITEM ();\t\t\t\t\t\\\n  if (string_temp != NULL)\t\t\t\t\t\t\\\n    str = (const char *) string_temp;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Popping string 0x%x: `\", str);\t\t\t\\\n  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);\t\\\n  DEBUG_PRINT1 (\"'\\n\");\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  pat = (unsigned char *) POP_FAILURE_ITEM ();\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Popping pattern 0x%x: \", pat);\t\t\t\\\n  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Restore register info.  */\t\t\t\t\t\t\\\n  high_reg = (unsigned) POP_FAILURE_ITEM ();\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Popping high active reg: %d\\n\", high_reg);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  low_reg = (unsigned) POP_FAILURE_ITEM ();\t\t\t\t\\\n  DEBUG_PRINT2 (\"  Popping  low active reg: %d\\n\", low_reg);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      DEBUG_PRINT2 (\"    Popping reg: %d\\n\", this_reg);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      reg_info[this_reg].word = POP_FAILURE_ITEM ();\t\t\t\\\n      DEBUG_PRINT2 (\"      info: 0x%x\\n\", reg_info[this_reg]);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();\t\t\\\n      DEBUG_PRINT2 (\"      end: 0x%x\\n\", regend[this_reg]);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();\t\t\\\n      DEBUG_PRINT2 (\"      start: 0x%x\\n\", regstart[this_reg]);\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  DEBUG_STATEMENT (nfailure_points_popped++);\t\t\t\t\\\n} /* POP_FAILURE_POINT */\n\f\n/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in\n   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible\n   characters can start a string that matches the pattern.  This fastmap\n   is used by re_search to skip quickly over impossible starting points.\n\n   The caller must supply the address of a (1 << BYTEWIDTH)-byte data\n   area as BUFP->fastmap.\n   \n   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in\n   the pattern buffer.\n\n   Returns 0 if we succeed, -2 if an internal error.   */\n\nint\nre_compile_fastmap (bufp)\n     struct re_pattern_buffer *bufp;\n{\n  int j, k;\n  fail_stack_type fail_stack;\n#ifndef REGEX_MALLOC\n  char *destination;\n#endif\n  /* We don't push any register information onto the failure stack.  */\n  unsigned num_regs = 0;\n  \n  register char *fastmap = bufp->fastmap;\n  unsigned char *pattern = bufp->buffer;\n  unsigned long size = bufp->used;\n  const unsigned char *p = pattern;\n  register unsigned char *pend = pattern + size;\n\n  /* Assume that each path through the pattern can be null until\n     proven otherwise.  We set this false at the bottom of switch\n     statement, to which we get only if a particular path doesn't\n     match the empty string.  */\n  boolean path_can_be_null = true;\n\n  /* We aren't doing a `succeed_n' to begin with.  */\n  boolean succeed_n_p = false;\n\n  assert (fastmap != NULL && p != NULL);\n  \n  INIT_FAIL_STACK ();\n  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */\n  bufp->fastmap_accurate = 1;\t    /* It will be when we're done.  */\n  bufp->can_be_null = 0;\n      \n  while (p != pend || !FAIL_STACK_EMPTY ())\n    {\n      if (p == pend)\n        {\n          bufp->can_be_null |= path_can_be_null;\n          \n          /* Reset for next path.  */\n          path_can_be_null = true;\n          \n          p = fail_stack.stack[--fail_stack.avail];\n\t}\n\n      /* We should never be about to go beyond the end of the pattern.  */\n      assert (p < pend);\n      \n#ifdef SWITCH_ENUM_BUG\n      switch ((int) ((re_opcode_t) *p++))\n#else\n      switch ((re_opcode_t) *p++)\n#endif\n\t{\n\n        /* I guess the idea here is to simply not bother with a fastmap\n           if a backreference is used, since it's too hard to figure out\n           the fastmap for the corresponding group.  Setting\n           `can_be_null' stops `re_search_2' from using the fastmap, so\n           that is all we do.  */\n\tcase duplicate:\n\t  bufp->can_be_null = 1;\n          return 0;\n\n\n      /* Following are the cases which match a character.  These end\n         with `break'.  */\n\n\tcase exactn:\n          fastmap[p[1]] = 1;\n\t  break;\n\n\n        case charset:\n          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)\n\t    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))\n              fastmap[j] = 1;\n\t  break;\n\n\n\tcase charset_not:\n\t  /* Chars beyond end of map must be allowed.  */\n\t  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)\n            fastmap[j] = 1;\n\n\t  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)\n\t    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))\n              fastmap[j] = 1;\n          break;\n\n\n\tcase wordchar:\n\t  for (j = 0; j < (1 << BYTEWIDTH); j++)\n\t    if (SYNTAX (j) == Sword)\n\t      fastmap[j] = 1;\n\t  break;\n\n\n\tcase notwordchar:\n\t  for (j = 0; j < (1 << BYTEWIDTH); j++)\n\t    if (SYNTAX (j) != Sword)\n\t      fastmap[j] = 1;\n\t  break;\n\n\n        case anychar:\n          /* `.' matches anything ...  */\n\t  for (j = 0; j < (1 << BYTEWIDTH); j++)\n            fastmap[j] = 1;\n\n          /* ... except perhaps newline.  */\n          if (!(bufp->syntax & RE_DOT_NEWLINE))\n            fastmap['\\n'] = 0;\n\n          /* Return if we have already set `can_be_null'; if we have,\n             then the fastmap is irrelevant.  Something's wrong here.  */\n\t  else if (bufp->can_be_null)\n\t    return 0;\n\n          /* Otherwise, have to check alternative paths.  */\n\t  break;\n\n\n#ifdef emacs\n        case syntaxspec:\n\t  k = *p++;\n\t  for (j = 0; j < (1 << BYTEWIDTH); j++)\n\t    if (SYNTAX (j) == (enum syntaxcode) k)\n\t      fastmap[j] = 1;\n\t  break;\n\n\n\tcase notsyntaxspec:\n\t  k = *p++;\n\t  for (j = 0; j < (1 << BYTEWIDTH); j++)\n\t    if (SYNTAX (j) != (enum syntaxcode) k)\n\t      fastmap[j] = 1;\n\t  break;\n\n\n      /* All cases after this match the empty string.  These end with\n         `continue'.  */\n\n\n\tcase before_dot:\n\tcase at_dot:\n\tcase after_dot:\n          continue;\n#endif /* not emacs */\n\n\n        case no_op:\n        case begline:\n        case endline:\n\tcase begbuf:\n\tcase endbuf:\n\tcase wordbound:\n\tcase notwordbound:\n\tcase wordbeg:\n\tcase wordend:\n        case push_dummy_failure:\n          continue;\n\n\n\tcase jump_n:\n        case pop_failure_jump:\n\tcase maybe_pop_jump:\n\tcase jump:\n        case jump_past_alt:\n\tcase dummy_failure_jump:\n          EXTRACT_NUMBER_AND_INCR (j, p);\n\t  p += j;\t\n\t  if (j > 0)\n\t    continue;\n            \n          /* Jump backward implies we just went through the body of a\n             loop and matched nothing.  Opcode jumped to should be\n             `on_failure_jump' or `succeed_n'.  Just treat it like an\n             ordinary jump.  For a * loop, it has pushed its failure\n             point already; if so, discard that as redundant.  */\n          if ((re_opcode_t) *p != on_failure_jump\n\t      && (re_opcode_t) *p != succeed_n)\n\t    continue;\n\n          p++;\n          EXTRACT_NUMBER_AND_INCR (j, p);\n          p += j;\t\t\n\t  \n          /* If what's on the stack is where we are now, pop it.  */\n          if (!FAIL_STACK_EMPTY () \n\t      && fail_stack.stack[fail_stack.avail - 1] == p)\n            fail_stack.avail--;\n\n          continue;\n\n\n        case on_failure_jump:\n        case on_failure_keep_string_jump:\n\thandle_on_failure_jump:\n          EXTRACT_NUMBER_AND_INCR (j, p);\n\n          /* For some patterns, e.g., `(a?)?', `p+j' here points to the\n             end of the pattern.  We don't want to push such a point,\n             since when we restore it above, entering the switch will\n             increment `p' past the end of the pattern.  We don't need\n             to push such a point since we obviously won't find any more\n             fastmap entries beyond `pend'.  Such a pattern can match\n             the null string, though.  */\n          if (p + j < pend)\n            {\n              if (!PUSH_PATTERN_OP (p + j, fail_stack))\n                return -2;\n            }\n          else\n            bufp->can_be_null = 1;\n\n          if (succeed_n_p)\n            {\n              EXTRACT_NUMBER_AND_INCR (k, p);\t/* Skip the n.  */\n              succeed_n_p = false;\n\t    }\n\n          continue;\n\n\n\tcase succeed_n:\n          /* Get to the number of times to succeed.  */\n          p += 2;\t\t\n\n          /* Increment p past the n for when k != 0.  */\n          EXTRACT_NUMBER_AND_INCR (k, p);\n          if (k == 0)\n\t    {\n              p -= 4;\n  \t      succeed_n_p = true;  /* Spaghetti code alert.  */\n              goto handle_on_failure_jump;\n            }\n          continue;\n\n\n\tcase set_number_at:\n          p += 4;\n          continue;\n\n\n\tcase start_memory:\n        case stop_memory:\n\t  p += 2;\n\t  continue;\n\n\n\tdefault:\n          abort (); /* We have listed all the cases.  */\n        } /* switch *p++ */\n\n      /* Getting here means we have found the possible starting\n         characters for one path of the pattern -- and that the empty\n         string does not match.  We need not follow this path further.\n         Instead, look at the next alternative (remembered on the\n         stack), or quit if no more.  The test at the top of the loop\n         does these things.  */\n      path_can_be_null = false;\n      p = pend;\n    } /* while p */\n\n  /* Set `can_be_null' for the last path (also the first path, if the\n     pattern is empty).  */\n  bufp->can_be_null |= path_can_be_null;\n  return 0;\n} /* re_compile_fastmap */\n\f\n/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use\n   this memory for recording register information.  STARTS and ENDS\n   must be allocated using the malloc library routine, and must each\n   be at least NUM_REGS * sizeof (regoff_t) bytes long.\n\n   If NUM_REGS == 0, then subsequent matches should allocate their own\n   register data.\n\n   Unless this function is called, the first search or match using\n   PATTERN_BUFFER will allocate its own register data, without\n   freeing the old data.  */\n\nvoid\nre_set_registers (bufp, regs, num_regs, starts, ends)\n    struct re_pattern_buffer *bufp;\n    struct re_registers *regs;\n    unsigned num_regs;\n    regoff_t *starts, *ends;\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = (regoff_t) 0;\n    }\n}\n\f\n/* Searching routines.  */\n\n/* Like re_search_2, below, but only one string is specified, and\n   doesn't let you say where to stop matching. */\n\nint\nre_search (bufp, string, size, startpos, range, regs)\n     struct re_pattern_buffer *bufp;\n     const char *string;\n     int size, startpos, range;\n     struct re_registers *regs;\n{\n  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, \n\t\t      regs, size);\n}\n\n\n/* Using the compiled pattern in BUFP->buffer, first tries to match the\n   virtual concatenation of STRING1 and STRING2, starting first at index\n   STARTPOS, then at STARTPOS + 1, and so on.\n   \n   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.\n   \n   RANGE is how far to scan while trying to match.  RANGE = 0 means try\n   only at STARTPOS; in general, the last start tried is STARTPOS +\n   RANGE.\n   \n   In REGS, return the indices of the virtual concatenation of STRING1\n   and STRING2 that matched the entire BUFP->buffer and its contained\n   subexpressions.\n   \n   Do not consider matching one past the index STOP in the virtual\n   concatenation of STRING1 and STRING2.\n\n   We return either the position in the strings at which the match was\n   found, -1 if no match, or -2 if error (such as failure\n   stack overflow).  */\n\nint\nre_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)\n     struct re_pattern_buffer *bufp;\n     const char *string1, *string2;\n     int size1, size2;\n     int startpos;\n     int range;\n     struct re_registers *regs;\n     int stop;\n{\n  int val;\n  register char *fastmap = bufp->fastmap;\n  register char *translate = bufp->translate;\n  int total_size = size1 + size2;\n  int endpos = startpos + range;\n\n  /* Check for out-of-range STARTPOS.  */\n  if (startpos < 0 || startpos > total_size)\n    return -1;\n    \n  /* Fix up RANGE if it might eventually take us outside\n     the virtual concatenation of STRING1 and STRING2.  */\n  if (endpos < -1)\n    range = -1 - startpos;\n  else if (endpos > total_size)\n    range = total_size - startpos;\n\n  /* If the search isn't to be a backwards one, don't waste time in a\n     search for a pattern that must be anchored.  */\n  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)\n    {\n      if (startpos > 0)\n\treturn -1;\n      else\n\trange = 1;\n    }\n\n  /* Update the fastmap now if not correct already.  */\n  if (fastmap && !bufp->fastmap_accurate)\n    if (re_compile_fastmap (bufp) == -2)\n      return -2;\n  \n  /* Loop through the string, looking for a place to start matching.  */\n  for (;;)\n    { \n      /* If a fastmap is supplied, skip quickly over characters that\n         cannot be the start of a match.  If the pattern can match the\n         null string, however, we don't need to skip characters; we want\n         the first null string.  */\n      if (fastmap && startpos < total_size && !bufp->can_be_null)\n\t{\n\t  if (range > 0)\t/* Searching forwards.  */\n\t    {\n\t      register const char *d;\n\t      register int lim = 0;\n\t      int irange = range;\n\n              if (startpos < size1 && startpos + range >= size1)\n                lim = range - (size1 - startpos);\n\n\t      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;\n   \n              /* Written out as an if-else to avoid testing `translate'\n                 inside the loop.  */\n\t      if (translate)\n                while (range > lim\n                       && !fastmap[(unsigned char)\n\t\t\t\t   translate[(unsigned char) *d++]])\n                  range--;\n\t      else\n                while (range > lim && !fastmap[(unsigned char) *d++])\n                  range--;\n\n\t      startpos += irange - range;\n\t    }\n\t  else\t\t\t\t/* Searching backwards.  */\n\t    {\n\t      register char c = (size1 == 0 || startpos >= size1\n                                 ? string2[startpos - size1] \n                                 : string1[startpos]);\n\n\t      if (!fastmap[(unsigned char) TRANSLATE (c)])\n\t\tgoto advance;\n\t    }\n\t}\n\n      /* If can't match the null string, and that's all we have left, fail.  */\n      if (range >= 0 && startpos == total_size && fastmap\n          && !bufp->can_be_null)\n\treturn -1;\n\n      val = re_match_2 (bufp, string1, size1, string2, size2,\n\t                startpos, regs, stop);\n      if (val >= 0)\n\treturn startpos;\n        \n      if (val == -2)\n\treturn -2;\n\n    advance:\n      if (!range) \n        break;\n      else if (range > 0) \n        {\n          range--; \n          startpos++;\n        }\n      else\n        {\n          range++; \n          startpos--;\n        }\n    }\n  return -1;\n} /* re_search_2 */\n\f\n/* Declarations and macros for re_match_2.  */\n\nstatic int bcmp_translate ();\nstatic boolean alt_match_null_string_p (),\n               common_op_match_null_string_p (),\n               group_match_null_string_p ();\n\n/* Structure for per-register (a.k.a. per-group) information.\n   This must not be longer than one word, because we push this value\n   onto the failure stack.  Other register information, such as the\n   starting and ending positions (which are addresses), and the list of\n   inner groups (which is a bits list) are maintained in separate\n   variables.  \n   \n   We are making a (strictly speaking) nonportable assumption here: that\n   the compiler will pack our bit fields into something that fits into\n   the type of `word', i.e., is something that fits into one item on the\n   failure stack.  */\ntypedef union\n{\n  fail_stack_elt_t word;\n  struct\n  {\n      /* This field is one if this group can match the empty string,\n         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */\n#define MATCH_NULL_UNSET_VALUE 3\n    unsigned match_null_string_p : 2;\n    unsigned is_active : 1;\n    unsigned matched_something : 1;\n    unsigned ever_matched_something : 1;\n  } bits;\n} register_info_type;\n\n#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)\n#define IS_ACTIVE(R)  ((R).bits.is_active)\n#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)\n#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)\n\n\n/* Call this when have matched a real character; it sets `matched' flags\n   for the subexpressions which we are currently inside.  Also records\n   that those subexprs have matched.  */\n#define SET_REGS_MATCHED()\t\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      unsigned r;\t\t\t\t\t\t\t\\\n      for (r = lowest_active_reg; r <= highest_active_reg; r++)\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          MATCHED_SOMETHING (reg_info[r])\t\t\t\t\\\n            = EVER_MATCHED_SOMETHING (reg_info[r])\t\t\t\\\n            = 1;\t\t\t\t\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n\n/* This converts PTR, a pointer into one of the search strings `string1'\n   and `string2' into an offset from the beginning of that string.  */\n#define POINTER_TO_OFFSET(ptr)\t\t\t\t\t\t\\\n  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)\n\n/* Registers are set to a sentinel when they haven't yet matched.  */\n#define REG_UNSET_VALUE ((char *) -1)\n#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)\n\n\n/* Macros for dealing with the split strings in re_match_2.  */\n\n#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)\n\n/* Call before fetching a character with *d.  This switches over to\n   string2 if necessary.  */\n#define PREFETCH()\t\t\t\t\t\t\t\\\n  while (d == dend)\t\t\t\t\t\t    \t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* End of string2 => fail.  */\t\t\t\t\t\\\n      if (dend == end_match_2) \t\t\t\t\t\t\\\n        goto fail;\t\t\t\t\t\t\t\\\n      /* End of string1 => advance to string2.  */ \t\t\t\\\n      d = string2;\t\t\t\t\t\t        \\\n      dend = end_match_2;\t\t\t\t\t\t\\\n    }\n\n\n/* Test if at very beginning or at very end of the virtual concatenation\n   of `string1' and `string2'.  If only one string, it's `string2'.  */\n#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)\n#define AT_STRINGS_END(d) ((d) == end2)\t\n\n\n/* Test if D points to a character which is word-constituent.  We have\n   two special cases to check for: if past the end of string1, look at\n   the first character in string2; and if before the beginning of\n   string2, look at the last character in string1.  */\n#define WORDCHAR_P(d)\t\t\t\t\t\t\t\\\n  (SYNTAX ((d) == end1 ? *string2\t\t\t\t\t\\\n           : (d) == string2 - 1 ? *(end1 - 1) : *(d))\t\t\t\\\n   == Sword)\n\n/* Test if the character before D and the one at D differ with respect\n   to being word-constituent.  */\n#define AT_WORD_BOUNDARY(d)\t\t\t\t\t\t\\\n  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)\t\t\t\t\\\n   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))\n\n\n/* Free everything we malloc.  */\n#ifdef REGEX_MALLOC\n#define FREE_VAR(var) if (var) free (var); var = NULL\n#define FREE_VARIABLES()\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    FREE_VAR (fail_stack.stack);\t\t\t\t\t\\\n    FREE_VAR (regstart);\t\t\t\t\t\t\\\n    FREE_VAR (regend);\t\t\t\t\t\t\t\\\n    FREE_VAR (old_regstart);\t\t\t\t\t\t\\\n    FREE_VAR (old_regend);\t\t\t\t\t\t\\\n    FREE_VAR (best_regstart);\t\t\t\t\t\t\\\n    FREE_VAR (best_regend);\t\t\t\t\t\t\\\n    FREE_VAR (reg_info);\t\t\t\t\t\t\\\n    FREE_VAR (reg_dummy);\t\t\t\t\t\t\\\n    FREE_VAR (reg_info_dummy);\t\t\t\t\t\t\\\n  } while (0)\n#else /* not REGEX_MALLOC */\n/* Some MIPS systems (at least) want this to free alloca'd storage.  */\n#define FREE_VARIABLES() alloca (0)\n#endif /* not REGEX_MALLOC */\n\n\n/* These values must meet several constraints.  They must not be valid\n   register values; since we have a limit of 255 registers (because\n   we use only one byte in the pattern for the register number), we can\n   use numbers larger than 255.  They must differ by 1, because of\n   NUM_FAILURE_ITEMS above.  And the value for the lowest register must\n   be larger than the value for the highest register, so we do not try\n   to actually save any registers when none are active.  */\n#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)\n#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)\n\f\n/* Matching routines.  */\n\n#ifndef emacs   /* Emacs never uses this.  */\n/* re_match is like re_match_2 except it takes only a single string.  */\n\nint\nre_match (bufp, string, size, pos, regs)\n     struct re_pattern_buffer *bufp;\n     const char *string;\n     int size, pos;\n     struct re_registers *regs;\n {\n  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); \n}\n#endif /* not emacs */\n\n\n/* re_match_2 matches the compiled pattern in BUFP against the\n   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1\n   and SIZE2, respectively).  We start matching at POS, and stop\n   matching at STOP.\n   \n   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we\n   store offsets for the substring each group matched in REGS.  See the\n   documentation for exactly how many groups we fill.\n\n   We return -1 if no match, -2 if an internal error (such as the\n   failure stack overflowing).  Otherwise, we return the length of the\n   matched substring.  */\n\nint\nre_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)\n     struct re_pattern_buffer *bufp;\n     const char *string1, *string2;\n     int size1, size2;\n     int pos;\n     struct re_registers *regs;\n     int stop;\n{\n  /* General temporaries.  */\n  int mcnt;\n  unsigned char *p1;\n\n  /* Just past the end of the corresponding string.  */\n  const char *end1, *end2;\n\n  /* Pointers into string1 and string2, just past the last characters in\n     each to consider matching.  */\n  const char *end_match_1, *end_match_2;\n\n  /* Where we are in the data, and the end of the current string.  */\n  const char *d, *dend;\n  \n  /* Where we are in the pattern, and the end of the pattern.  */\n  unsigned char *p = bufp->buffer;\n  register unsigned char *pend = p + bufp->used;\n\n  /* We use this to map every character in the string.  */\n  char *translate = bufp->translate;\n\n  /* Failure point stack.  Each place that can handle a failure further\n     down the line pushes a failure point on this stack.  It consists of\n     restart, regend, and reg_info for all registers corresponding to\n     the subexpressions we're currently inside, plus the number of such\n     registers, and, finally, two char *'s.  The first char * is where\n     to resume scanning the pattern; the second one is where to resume\n     scanning the strings.  If the latter is zero, the failure point is\n     a ``dummy''; if a failure happens and the failure point is a dummy,\n     it gets discarded and the next next one is tried.  */\n  fail_stack_type fail_stack;\n#ifdef DEBUG\n  static unsigned failure_id = 0;\n  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;\n#endif\n\n  /* We fill all the registers internally, independent of what we\n     return, for use in backreferences.  The number here includes\n     an element for register zero.  */\n  unsigned num_regs = bufp->re_nsub + 1;\n  \n  /* The currently active registers.  */\n  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;\n  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;\n\n  /* Information on the contents of registers. These are pointers into\n     the input strings; they record just what was matched (on this\n     attempt) by a subexpression part of the pattern, that is, the\n     regnum-th regstart pointer points to where in the pattern we began\n     matching and the regnum-th regend points to right after where we\n     stopped matching the regnum-th subexpression.  (The zeroth register\n     keeps track of what the whole pattern matches.)  */\n  const char **regstart, **regend;\n\n  /* If a group that's operated upon by a repetition operator fails to\n     match anything, then the register for its start will need to be\n     restored because it will have been set to wherever in the string we\n     are when we last see its open-group operator.  Similarly for a\n     register's end.  */\n  const char **old_regstart, **old_regend;\n\n  /* The is_active field of reg_info helps us keep track of which (possibly\n     nested) subexpressions we are currently in. The matched_something\n     field of reg_info[reg_num] helps us tell whether or not we have\n     matched any of the pattern so far this time through the reg_num-th\n     subexpression.  These two fields get reset each time through any\n     loop their register is in.  */\n  register_info_type *reg_info; \n\n  /* The following record the register info as found in the above\n     variables when we find a match better than any we've seen before. \n     This happens as we backtrack through the failure points, which in\n     turn happens only if we have not yet matched the entire string. */\n  unsigned best_regs_set = false;\n  const char **best_regstart, **best_regend;\n  \n  /* Logically, this is `best_regend[0]'.  But we don't want to have to\n     allocate space for that if we're not allocating space for anything\n     else (see below).  Also, we never need info about register 0 for\n     any of the other register vectors, and it seems rather a kludge to\n     treat `best_regend' differently than the rest.  So we keep track of\n     the end of the best match so far in a separate variable.  We\n     initialize this to NULL so that when we backtrack the first time\n     and need to test it, it's not garbage.  */\n  const char *match_end = NULL;\n\n  /* Used when we pop values we don't care about.  */\n  const char **reg_dummy;\n  register_info_type *reg_info_dummy;\n\n#ifdef DEBUG\n  /* Counts the total number of registers pushed.  */\n  unsigned num_regs_pushed = 0; \t\n#endif\n\n  DEBUG_PRINT1 (\"\\n\\nEntering re_match_2.\\n\");\n  \n  INIT_FAIL_STACK ();\n  \n  /* Do not bother to initialize all the register variables if there are\n     no groups in the pattern, as it takes a fair amount of time.  If\n     there are groups, we include space for register 0 (the whole\n     pattern), even though we never use it, since it simplifies the\n     array indexing.  We should fix this.  */\n  if (bufp->re_nsub)\n    {\n      regstart = REGEX_TALLOC (num_regs, const char *);\n      regend = REGEX_TALLOC (num_regs, const char *);\n      old_regstart = REGEX_TALLOC (num_regs, const char *);\n      old_regend = REGEX_TALLOC (num_regs, const char *);\n      best_regstart = REGEX_TALLOC (num_regs, const char *);\n      best_regend = REGEX_TALLOC (num_regs, const char *);\n      reg_info = REGEX_TALLOC (num_regs, register_info_type);\n      reg_dummy = REGEX_TALLOC (num_regs, const char *);\n      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);\n\n      if (!(regstart && regend && old_regstart && old_regend && reg_info \n            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) \n        {\n          FREE_VARIABLES ();\n          return -2;\n        }\n    }\n#ifdef REGEX_MALLOC\n  else\n    {\n      /* We must initialize all our variables to NULL, so that\n         `FREE_VARIABLES' doesn't try to free them.  */\n      regstart = regend = old_regstart = old_regend = best_regstart\n        = best_regend = reg_dummy = NULL;\n      reg_info = reg_info_dummy = (register_info_type *) NULL;\n    }\n#endif /* REGEX_MALLOC */\n\n  /* The starting position is bogus.  */\n  if (pos < 0 || pos > size1 + size2)\n    {\n      FREE_VARIABLES ();\n      return -1;\n    }\n    \n  /* Initialize subexpression text positions to -1 to mark ones that no\n     start_memory/stop_memory has been seen for. Also initialize the\n     register information struct.  */\n  for (mcnt = 1; mcnt < num_regs; mcnt++)\n    {\n      regstart[mcnt] = regend[mcnt] \n        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;\n        \n      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;\n      IS_ACTIVE (reg_info[mcnt]) = 0;\n      MATCHED_SOMETHING (reg_info[mcnt]) = 0;\n      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;\n    }\n  \n  /* We move `string1' into `string2' if the latter's empty -- but not if\n     `string1' is null.  */\n  if (size2 == 0 && string1 != NULL)\n    {\n      string2 = string1;\n      size2 = size1;\n      string1 = 0;\n      size1 = 0;\n    }\n  end1 = string1 + size1;\n  end2 = string2 + size2;\n\n  /* Compute where to stop matching, within the two strings.  */\n  if (stop <= size1)\n    {\n      end_match_1 = string1 + stop;\n      end_match_2 = string2;\n    }\n  else\n    {\n      end_match_1 = end1;\n      end_match_2 = string2 + stop - size1;\n    }\n\n  /* `p' scans through the pattern as `d' scans through the data. \n     `dend' is the end of the input string that `d' points within.  `d'\n     is advanced into the following input string whenever necessary, but\n     this happens before fetching; therefore, at the beginning of the\n     loop, `d' can be pointing at the end of a string, but it cannot\n     equal `string2'.  */\n  if (size1 > 0 && pos <= size1)\n    {\n      d = string1 + pos;\n      dend = end_match_1;\n    }\n  else\n    {\n      d = string2 + pos - size1;\n      dend = end_match_2;\n    }\n\n  DEBUG_PRINT1 (\"The compiled pattern is: \");\n  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);\n  DEBUG_PRINT1 (\"The string to match is: `\");\n  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);\n  DEBUG_PRINT1 (\"'\\n\");\n  \n  /* This loops over pattern commands.  It exits by returning from the\n     function if the match is complete, or it drops through if the match\n     fails at this starting point in the input data.  */\n  for (;;)\n    {\n      DEBUG_PRINT2 (\"\\n0x%x: \", p);\n\n      if (p == pend)\n\t{ /* End of pattern means we might have succeeded.  */\n          DEBUG_PRINT1 (\"end of pattern ... \");\n          \n\t  /* If we haven't matched the entire string, and we want the\n             longest match, try backtracking.  */\n          if (d != end_match_2)\n\t    {\n              DEBUG_PRINT1 (\"backtracking.\\n\");\n              \n              if (!FAIL_STACK_EMPTY ())\n                { /* More failure points to try.  */\n                  boolean same_str_p = (FIRST_STRING_P (match_end) \n\t        \t                == MATCHING_IN_FIRST_STRING);\n\n                  /* If exceeds best match so far, save it.  */\n                  if (!best_regs_set\n                      || (same_str_p && d > match_end)\n                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))\n                    {\n                      best_regs_set = true;\n                      match_end = d;\n                      \n                      DEBUG_PRINT1 (\"\\nSAVING match as best so far.\\n\");\n                      \n                      for (mcnt = 1; mcnt < num_regs; mcnt++)\n                        {\n                          best_regstart[mcnt] = regstart[mcnt];\n                          best_regend[mcnt] = regend[mcnt];\n                        }\n                    }\n                  goto fail;\t       \n                }\n\n              /* If no failure points, don't restore garbage.  */\n              else if (best_regs_set)   \n                {\n  \t        restore_best_regs:\n                  /* Restore best match.  It may happen that `dend ==\n                     end_match_1' while the restored d is in string2.\n                     For example, the pattern `x.*y.*z' against the\n                     strings `x-' and `y-z-', if the two strings are\n                     not consecutive in memory.  */\n                  DEBUG_PRINT1 (\"Restoring best registers.\\n\");\n                  \n                  d = match_end;\n                  dend = ((d >= string1 && d <= end1)\n\t\t           ? end_match_1 : end_match_2);\n\n\t\t  for (mcnt = 1; mcnt < num_regs; mcnt++)\n\t\t    {\n\t\t      regstart[mcnt] = best_regstart[mcnt];\n\t\t      regend[mcnt] = best_regend[mcnt];\n\t\t    }\n                }\n            } /* d != end_match_2 */\n\n          DEBUG_PRINT1 (\"Accepting match.\\n\");\n\n          /* If caller wants register contents data back, do it.  */\n          if (regs && !bufp->no_sub)\n\t    {\n              /* Have the register data arrays been allocated?  */\n              if (bufp->regs_allocated == REGS_UNALLOCATED)\n                { /* No.  So allocate them with malloc.  We need one\n                     extra element beyond `num_regs' for the `-1' marker\n                     GNU code uses.  */\n                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);\n                  regs->start = TALLOC (regs->num_regs, regoff_t);\n                  regs->end = TALLOC (regs->num_regs, regoff_t);\n                  if (regs->start == NULL || regs->end == NULL)\n                    return -2;\n                  bufp->regs_allocated = REGS_REALLOCATE;\n                }\n              else if (bufp->regs_allocated == REGS_REALLOCATE)\n                { /* Yes.  If we need more elements than were already\n                     allocated, reallocate them.  If we need fewer, just\n                     leave it alone.  */\n                  if (regs->num_regs < num_regs + 1)\n                    {\n                      regs->num_regs = num_regs + 1;\n                      RETALLOC (regs->start, regs->num_regs, regoff_t);\n                      RETALLOC (regs->end, regs->num_regs, regoff_t);\n                      if (regs->start == NULL || regs->end == NULL)\n                        return -2;\n                    }\n                }\n              else\n\t\t{\n\t\t  /* These braces fend off a \"empty body in an else-statement\"\n\t\t     warning under GCC when assert expands to nothing.  */\n\t\t  assert (bufp->regs_allocated == REGS_FIXED);\n\t\t}\n\n              /* Convert the pointer data in `regstart' and `regend' to\n                 indices.  Register zero has to be set differently,\n                 since we haven't kept track of any info for it.  */\n              if (regs->num_regs > 0)\n                {\n                  regs->start[0] = pos;\n                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1\n\t\t\t          : d - string2 + size1);\n                }\n              \n              /* Go through the first `min (num_regs, regs->num_regs)'\n                 registers, since that is all we initialized.  */\n\t      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)\n\t\t{\n                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))\n                    regs->start[mcnt] = regs->end[mcnt] = -1;\n                  else\n                    {\n\t\t      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);\n                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);\n                    }\n\t\t}\n              \n              /* If the regs structure we return has more elements than\n                 were in the pattern, set the extra elements to -1.  If\n                 we (re)allocated the registers, this is the case,\n                 because we always allocate enough to have at least one\n                 -1 at the end.  */\n              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)\n                regs->start[mcnt] = regs->end[mcnt] = -1;\n\t    } /* regs && !bufp->no_sub */\n\n          FREE_VARIABLES ();\n          DEBUG_PRINT4 (\"%u failure points pushed, %u popped (%u remain).\\n\",\n                        nfailure_points_pushed, nfailure_points_popped,\n                        nfailure_points_pushed - nfailure_points_popped);\n          DEBUG_PRINT2 (\"%u registers pushed.\\n\", num_regs_pushed);\n\n          mcnt = d - pos - (MATCHING_IN_FIRST_STRING \n\t\t\t    ? string1 \n\t\t\t    : string2 - size1);\n\n          DEBUG_PRINT2 (\"Returning %d from re_match_2.\\n\", mcnt);\n\n          return mcnt;\n        }\n\n      /* Otherwise match next pattern command.  */\n#ifdef SWITCH_ENUM_BUG\n      switch ((int) ((re_opcode_t) *p++))\n#else\n      switch ((re_opcode_t) *p++)\n#endif\n\t{\n        /* Ignore these.  Used to ignore the n of succeed_n's which\n           currently have n == 0.  */\n        case no_op:\n          DEBUG_PRINT1 (\"EXECUTING no_op.\\n\");\n          break;\n\n\n        /* Match the next n pattern characters exactly.  The following\n           byte in the pattern defines n, and the n bytes after that\n           are the characters to match.  */\n\tcase exactn:\n\t  mcnt = *p++;\n          DEBUG_PRINT2 (\"EXECUTING exactn %d.\\n\", mcnt);\n\n          /* This is written out as an if-else so we don't waste time\n             testing `translate' inside the loop.  */\n          if (translate)\n\t    {\n\t      do\n\t\t{\n\t\t  PREFETCH ();\n\t\t  if (translate[(unsigned char) *d++] != (char) *p++)\n                    goto fail;\n\t\t}\n\t      while (--mcnt);\n\t    }\n\t  else\n\t    {\n\t      do\n\t\t{\n\t\t  PREFETCH ();\n\t\t  if (*d++ != (char) *p++) goto fail;\n\t\t}\n\t      while (--mcnt);\n\t    }\n\t  SET_REGS_MATCHED ();\n          break;\n\n\n        /* Match any character except possibly a newline or a null.  */\n\tcase anychar:\n          DEBUG_PRINT1 (\"EXECUTING anychar.\\n\");\n\n          PREFETCH ();\n\n          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\\n')\n              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\\000'))\n\t    goto fail;\n\n          SET_REGS_MATCHED ();\n          DEBUG_PRINT2 (\"  Matched `%d'.\\n\", *d);\n          d++;\n\t  break;\n\n\n\tcase charset:\n\tcase charset_not:\n\t  {\n\t    register unsigned char c;\n\t    boolean not = (re_opcode_t) *(p - 1) == charset_not;\n\n            DEBUG_PRINT2 (\"EXECUTING charset%s.\\n\", not ? \"_not\" : \"\");\n\n\t    PREFETCH ();\n\t    c = TRANSLATE (*d); /* The character to match.  */\n\n            /* Cast to `unsigned' instead of `unsigned char' in case the\n               bit list is a full 32 bytes long.  */\n\t    if (c < (unsigned) (*p * BYTEWIDTH)\n\t\t&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))\n\t      not = !not;\n\n\t    p += 1 + *p;\n\n\t    if (!not) goto fail;\n            \n\t    SET_REGS_MATCHED ();\n            d++;\n\t    break;\n\t  }\n\n\n        /* The beginning of a group is represented by start_memory.\n           The arguments are the register number in the next byte, and the\n           number of groups inner to this one in the next.  The text\n           matched within the group is recorded (in the internal\n           registers data structure) under the register number.  */\n        case start_memory:\n\t  DEBUG_PRINT3 (\"EXECUTING start_memory %d (%d):\\n\", *p, p[1]);\n\n          /* Find out if this group can match the empty string.  */\n\t  p1 = p;\t\t/* To send to group_match_null_string_p.  */\n          \n          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)\n            REG_MATCH_NULL_STRING_P (reg_info[*p]) \n              = group_match_null_string_p (&p1, pend, reg_info);\n\n          /* Save the position in the string where we were the last time\n             we were at this open-group operator in case the group is\n             operated upon by a repetition operator, e.g., with `(a*)*b'\n             against `ab'; then we want to ignore where we are now in\n             the string in case this attempt to match fails.  */\n          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])\n                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]\n                             : regstart[*p];\n\t  DEBUG_PRINT2 (\"  old_regstart: %d\\n\", \n\t\t\t POINTER_TO_OFFSET (old_regstart[*p]));\n\n          regstart[*p] = d;\n\t  DEBUG_PRINT2 (\"  regstart: %d\\n\", POINTER_TO_OFFSET (regstart[*p]));\n\n          IS_ACTIVE (reg_info[*p]) = 1;\n          MATCHED_SOMETHING (reg_info[*p]) = 0;\n          \n          /* This is the new highest active register.  */\n          highest_active_reg = *p;\n          \n          /* If nothing was active before, this is the new lowest active\n             register.  */\n          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)\n            lowest_active_reg = *p;\n\n          /* Move past the register number and inner group count.  */\n          p += 2;\n          break;\n\n\n        /* The stop_memory opcode represents the end of a group.  Its\n           arguments are the same as start_memory's: the register\n           number, and the number of inner groups.  */\n\tcase stop_memory:\n\t  DEBUG_PRINT3 (\"EXECUTING stop_memory %d (%d):\\n\", *p, p[1]);\n             \n          /* We need to save the string position the last time we were at\n             this close-group operator in case the group is operated\n             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'\n             against `aba'; then we want to ignore where we are now in\n             the string in case this attempt to match fails.  */\n          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])\n                           ? REG_UNSET (regend[*p]) ? d : regend[*p]\n\t\t\t   : regend[*p];\n\t  DEBUG_PRINT2 (\"      old_regend: %d\\n\", \n\t\t\t POINTER_TO_OFFSET (old_regend[*p]));\n\n          regend[*p] = d;\n\t  DEBUG_PRINT2 (\"      regend: %d\\n\", POINTER_TO_OFFSET (regend[*p]));\n\n          /* This register isn't active anymore.  */\n          IS_ACTIVE (reg_info[*p]) = 0;\n          \n          /* If this was the only register active, nothing is active\n             anymore.  */\n          if (lowest_active_reg == highest_active_reg)\n            {\n              lowest_active_reg = NO_LOWEST_ACTIVE_REG;\n              highest_active_reg = NO_HIGHEST_ACTIVE_REG;\n            }\n          else\n            { /* We must scan for the new highest active register, since\n                 it isn't necessarily one less than now: consider\n                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the\n                 new highest active register is 1.  */\n              unsigned char r = *p - 1;\n              while (r > 0 && !IS_ACTIVE (reg_info[r]))\n                r--;\n              \n              /* If we end up at register zero, that means that we saved\n                 the registers as the result of an `on_failure_jump', not\n                 a `start_memory', and we jumped to past the innermost\n                 `stop_memory'.  For example, in ((.)*) we save\n                 registers 1 and 2 as a result of the *, but when we pop\n                 back to the second ), we are at the stop_memory 1.\n                 Thus, nothing is active.  */\n\t      if (r == 0)\n                {\n                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;\n                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;\n                }\n              else\n                highest_active_reg = r;\n            }\n          \n          /* If just failed to match something this time around with a\n             group that's operated on by a repetition operator, try to\n             force exit from the ``loop'', and restore the register\n             information for this group that we had before trying this\n             last match.  */\n          if ((!MATCHED_SOMETHING (reg_info[*p])\n               || (re_opcode_t) p[-3] == start_memory)\n\t      && (p + 2) < pend)              \n            {\n              boolean is_a_jump_n = false;\n              \n              p1 = p + 2;\n              mcnt = 0;\n              switch ((re_opcode_t) *p1++)\n                {\n                  case jump_n:\n\t\t    is_a_jump_n = true;\n                  case pop_failure_jump:\n\t\t  case maybe_pop_jump:\n\t\t  case jump:\n\t\t  case dummy_failure_jump:\n                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n\t\t    if (is_a_jump_n)\n\t\t      p1 += 2;\n                    break;\n                  \n                  default:\n                    /* do nothing */ ;\n                }\n\t      p1 += mcnt;\n        \n              /* If the next operation is a jump backwards in the pattern\n\t         to an on_failure_jump right before the start_memory\n                 corresponding to this stop_memory, exit from the loop\n                 by forcing a failure after pushing on the stack the\n                 on_failure_jump's jump in the pattern, and d.  */\n              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump\n                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)\n\t\t{\n                  /* If this group ever matched anything, then restore\n                     what its registers were before trying this last\n                     failed match, e.g., with `(a*)*b' against `ab' for\n                     regstart[1], and, e.g., with `((a*)*(b*)*)*'\n                     against `aba' for regend[3].\n                     \n                     Also restore the registers for inner groups for,\n                     e.g., `((a*)(b*))*' against `aba' (register 3 would\n                     otherwise get trashed).  */\n                     \n                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))\n\t\t    {\n\t\t      unsigned r; \n        \n                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;\n                      \n\t\t      /* Restore this and inner groups' (if any) registers.  */\n                      for (r = *p; r < *p + *(p + 1); r++)\n                        {\n                          regstart[r] = old_regstart[r];\n\n                          /* xx why this test?  */\n                          if ((int) old_regend[r] >= (int) regstart[r])\n                            regend[r] = old_regend[r];\n                        }     \n                    }\n\t\t  p1++;\n                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);\n\n                  goto fail;\n                }\n            }\n          \n          /* Move past the register number and the inner group count.  */\n          p += 2;\n          break;\n\n\n\t/* \\<digit> has been turned into a `duplicate' command which is\n           followed by the numeric value of <digit> as the register number.  */\n        case duplicate:\n\t  {\n\t    register const char *d2, *dend2;\n\t    int regno = *p++;   /* Get which register to match against.  */\n\t    DEBUG_PRINT2 (\"EXECUTING duplicate %d.\\n\", regno);\n\n\t    /* Can't back reference a group which we've never matched.  */\n            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))\n              goto fail;\n              \n            /* Where in input to try to start matching.  */\n            d2 = regstart[regno];\n            \n            /* Where to stop matching; if both the place to start and\n               the place to stop matching are in the same string, then\n               set to the place to stop, otherwise, for now have to use\n               the end of the first string.  */\n\n            dend2 = ((FIRST_STRING_P (regstart[regno]) \n\t\t      == FIRST_STRING_P (regend[regno]))\n\t\t     ? regend[regno] : end_match_1);\n\t    for (;;)\n\t      {\n\t\t/* If necessary, advance to next segment in register\n                   contents.  */\n\t\twhile (d2 == dend2)\n\t\t  {\n\t\t    if (dend2 == end_match_2) break;\n\t\t    if (dend2 == regend[regno]) break;\n\n                    /* End of string1 => advance to string2. */\n                    d2 = string2;\n                    dend2 = regend[regno];\n\t\t  }\n\t\t/* At end of register contents => success */\n\t\tif (d2 == dend2) break;\n\n\t\t/* If necessary, advance to next segment in data.  */\n\t\tPREFETCH ();\n\n\t\t/* How many characters left in this segment to match.  */\n\t\tmcnt = dend - d;\n                \n\t\t/* Want how many consecutive characters we can match in\n                   one shot, so, if necessary, adjust the count.  */\n                if (mcnt > dend2 - d2)\n\t\t  mcnt = dend2 - d2;\n                  \n\t\t/* Compare that many; failure if mismatch, else move\n                   past them.  */\n\t\tif (translate \n                    ? bcmp_translate (d, d2, mcnt, translate) \n                    : bcmp (d, d2, mcnt))\n\t\t  goto fail;\n\t\td += mcnt, d2 += mcnt;\n\t      }\n\t  }\n\t  break;\n\n\n        /* begline matches the empty string at the beginning of the string\n           (unless `not_bol' is set in `bufp'), and, if\n           `newline_anchor' is set, after newlines.  */\n\tcase begline:\n          DEBUG_PRINT1 (\"EXECUTING begline.\\n\");\n          \n          if (AT_STRINGS_BEG (d))\n            {\n              if (!bufp->not_bol) break;\n            }\n          else if (d[-1] == '\\n' && bufp->newline_anchor)\n            {\n              break;\n            }\n          /* In all other cases, we fail.  */\n          goto fail;\n\n\n        /* endline is the dual of begline.  */\n\tcase endline:\n          DEBUG_PRINT1 (\"EXECUTING endline.\\n\");\n\n          if (AT_STRINGS_END (d))\n            {\n              if (!bufp->not_eol) break;\n            }\n          \n          /* We have to ``prefetch'' the next character.  */\n          else if ((d == end1 ? *string2 : *d) == '\\n'\n                   && bufp->newline_anchor)\n            {\n              break;\n            }\n          goto fail;\n\n\n\t/* Match at the very beginning of the data.  */\n        case begbuf:\n          DEBUG_PRINT1 (\"EXECUTING begbuf.\\n\");\n          if (AT_STRINGS_BEG (d))\n            break;\n          goto fail;\n\n\n\t/* Match at the very end of the data.  */\n        case endbuf:\n          DEBUG_PRINT1 (\"EXECUTING endbuf.\\n\");\n\t  if (AT_STRINGS_END (d))\n\t    break;\n          goto fail;\n\n\n        /* on_failure_keep_string_jump is used to optimize `.*\\n'.  It\n           pushes NULL as the value for the string on the stack.  Then\n           `pop_failure_point' will keep the current value for the\n           string, instead of restoring it.  To see why, consider\n           matching `foo\\nbar' against `.*\\n'.  The .* matches the foo;\n           then the . fails against the \\n.  But the next thing we want\n           to do is match the \\n against the \\n; if we restored the\n           string value, we would be back at the foo.\n           \n           Because this is used only in specific cases, we don't need to\n           check all the things that `on_failure_jump' does, to make\n           sure the right things get saved on the stack.  Hence we don't\n           share its code.  The only reason to push anything on the\n           stack at all is that otherwise we would have to change\n           `anychar's code to do something besides goto fail in this\n           case; that seems worse than this.  */\n        case on_failure_keep_string_jump:\n          DEBUG_PRINT1 (\"EXECUTING on_failure_keep_string_jump\");\n          \n          EXTRACT_NUMBER_AND_INCR (mcnt, p);\n          DEBUG_PRINT3 (\" %d (to 0x%x):\\n\", mcnt, p + mcnt);\n\n          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);\n          break;\n\n\n\t/* Uses of on_failure_jump:\n        \n           Each alternative starts with an on_failure_jump that points\n           to the beginning of the next alternative.  Each alternative\n           except the last ends with a jump that in effect jumps past\n           the rest of the alternatives.  (They really jump to the\n           ending jump of the following alternative, because tensioning\n           these jumps is a hassle.)\n\n           Repeats start with an on_failure_jump that points past both\n           the repetition text and either the following jump or\n           pop_failure_jump back to this on_failure_jump.  */\n\tcase on_failure_jump:\n        on_failure:\n          DEBUG_PRINT1 (\"EXECUTING on_failure_jump\");\n\n          EXTRACT_NUMBER_AND_INCR (mcnt, p);\n          DEBUG_PRINT3 (\" %d (to 0x%x)\", mcnt, p + mcnt);\n\n          /* If this on_failure_jump comes right before a group (i.e.,\n             the original * applied to a group), save the information\n             for that group and all inner ones, so that if we fail back\n             to this point, the group's information will be correct.\n             For example, in \\(a*\\)*\\1, we need the preceding group,\n             and in \\(\\(a*\\)b*\\)\\2, we need the inner group.  */\n\n          /* We can't use `p' to check ahead because we push\n             a failure point to `p + mcnt' after we do this.  */\n          p1 = p;\n\n          /* We need to skip no_op's before we look for the\n             start_memory in case this on_failure_jump is happening as\n             the result of a completed succeed_n, as in \\(a\\)\\{1,3\\}b\\1\n             against aba.  */\n          while (p1 < pend && (re_opcode_t) *p1 == no_op)\n            p1++;\n\n          if (p1 < pend && (re_opcode_t) *p1 == start_memory)\n            {\n              /* We have a new highest active register now.  This will\n                 get reset at the start_memory we are about to get to,\n                 but we will have saved all the registers relevant to\n                 this repetition op, as described above.  */\n              highest_active_reg = *(p1 + 1) + *(p1 + 2);\n              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)\n                lowest_active_reg = *(p1 + 1);\n            }\n\n          DEBUG_PRINT1 (\":\\n\");\n          PUSH_FAILURE_POINT (p + mcnt, d, -2);\n          break;\n\n\n        /* A smart repeat ends with `maybe_pop_jump'.\n\t   We change it to either `pop_failure_jump' or `jump'.  */\n        case maybe_pop_jump:\n          EXTRACT_NUMBER_AND_INCR (mcnt, p);\n          DEBUG_PRINT2 (\"EXECUTING maybe_pop_jump %d.\\n\", mcnt);\n          {\n\t    register unsigned char *p2 = p;\n\n            /* Compare the beginning of the repeat with what in the\n               pattern follows its end. If we can establish that there\n               is nothing that they would both match, i.e., that we\n               would have to backtrack because of (as in, e.g., `a*a')\n               then we can change to pop_failure_jump, because we'll\n               never have to backtrack.\n               \n               This is not true in the case of alternatives: in\n               `(a|ab)*' we do need to backtrack to the `ab' alternative\n               (e.g., if the string was `ab').  But instead of trying to\n               detect that here, the alternative has put on a dummy\n               failure point which is what we will end up popping.  */\n\n\t    /* Skip over open/close-group commands.  */\n\t    while (p2 + 2 < pend\n\t\t   && ((re_opcode_t) *p2 == stop_memory\n\t\t       || (re_opcode_t) *p2 == start_memory))\n\t      p2 += 3;\t\t\t/* Skip over args, too.  */\n\n            /* If we're at the end of the pattern, we can change.  */\n            if (p2 == pend)\n\t      {\n\t\t/* Consider what happens when matching \":\\(.*\\)\"\n\t\t   against \":/\".  I don't really understand this code\n\t\t   yet.  */\n  \t        p[-3] = (unsigned char) pop_failure_jump;\n                DEBUG_PRINT1\n                  (\"  End of pattern: change to `pop_failure_jump'.\\n\");\n              }\n\n            else if ((re_opcode_t) *p2 == exactn\n\t\t     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))\n\t      {\n\t\tregister unsigned char c\n                  = *p2 == (unsigned char) endline ? '\\n' : p2[2];\n\t\tp1 = p + mcnt;\n\n                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding\n                   to the `maybe_finalize_jump' of this case.  Examine what \n                   follows.  */\n                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)\n                  {\n  \t\t    p[-3] = (unsigned char) pop_failure_jump;\n                    DEBUG_PRINT3 (\"  %c != %c => pop_failure_jump.\\n\",\n                                  c, p1[5]);\n                  }\n                  \n\t\telse if ((re_opcode_t) p1[3] == charset\n\t\t\t || (re_opcode_t) p1[3] == charset_not)\n\t\t  {\n\t\t    int not = (re_opcode_t) p1[3] == charset_not;\n                    \n\t\t    if (c < (unsigned char) (p1[4] * BYTEWIDTH)\n\t\t\t&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))\n\t\t      not = !not;\n\n                    /* `not' is equal to 1 if c would match, which means\n                        that we can't change to pop_failure_jump.  */\n\t\t    if (!not)\n                      {\n  \t\t        p[-3] = (unsigned char) pop_failure_jump;\n                        DEBUG_PRINT1 (\"  No match => pop_failure_jump.\\n\");\n                      }\n\t\t  }\n\t      }\n\t  }\n\t  p -= 2;\t\t/* Point at relative address again.  */\n\t  if ((re_opcode_t) p[-1] != pop_failure_jump)\n\t    {\n\t      p[-1] = (unsigned char) jump;\n              DEBUG_PRINT1 (\"  Match => jump.\\n\");\n\t      goto unconditional_jump;\n\t    }\n        /* Note fall through.  */\n\n\n\t/* The end of a simple repeat has a pop_failure_jump back to\n           its matching on_failure_jump, where the latter will push a\n           failure point.  The pop_failure_jump takes off failure\n           points put on by this pop_failure_jump's matching\n           on_failure_jump; we got through the pattern to here from the\n           matching on_failure_jump, so didn't fail.  */\n        case pop_failure_jump:\n          {\n            /* We need to pass separate storage for the lowest and\n               highest registers, even though we don't care about the\n               actual values.  Otherwise, we will restore only one\n               register from the stack, since lowest will == highest in\n               `pop_failure_point'.  */\n            unsigned dummy_low_reg, dummy_high_reg;\n            unsigned char *pdummy;\n            const char *sdummy;\n\n            DEBUG_PRINT1 (\"EXECUTING pop_failure_jump.\\n\");\n            POP_FAILURE_POINT (sdummy, pdummy,\n                               dummy_low_reg, dummy_high_reg,\n                               reg_dummy, reg_dummy, reg_info_dummy);\n          }\n          /* Note fall through.  */\n\n          \n        /* Unconditionally jump (without popping any failure points).  */\n        case jump:\n\tunconditional_jump:\n\t  EXTRACT_NUMBER_AND_INCR (mcnt, p);\t/* Get the amount to jump.  */\n          DEBUG_PRINT2 (\"EXECUTING jump %d \", mcnt);\n\t  p += mcnt;\t\t\t\t/* Do the jump.  */\n          DEBUG_PRINT2 (\"(to 0x%x).\\n\", p);\n\t  break;\n\n\t\n        /* We need this opcode so we can detect where alternatives end\n           in `group_match_null_string_p' et al.  */\n        case jump_past_alt:\n          DEBUG_PRINT1 (\"EXECUTING jump_past_alt.\\n\");\n          goto unconditional_jump;\n\n\n        /* Normally, the on_failure_jump pushes a failure point, which\n           then gets popped at pop_failure_jump.  We will end up at\n           pop_failure_jump, also, and with a pattern of, say, `a+', we\n           are skipping over the on_failure_jump, so we have to push\n           something meaningless for pop_failure_jump to pop.  */\n        case dummy_failure_jump:\n          DEBUG_PRINT1 (\"EXECUTING dummy_failure_jump.\\n\");\n          /* It doesn't matter what we push for the string here.  What\n             the code at `fail' tests is the value for the pattern.  */\n          PUSH_FAILURE_POINT (0, 0, -2);\n          goto unconditional_jump;\n\n\n        /* At the end of an alternative, we need to push a dummy failure\n           point in case we are followed by a `pop_failure_jump', because\n           we don't want the failure point for the alternative to be\n           popped.  For example, matching `(a|ab)*' against `aab'\n           requires that we match the `ab' alternative.  */\n        case push_dummy_failure:\n          DEBUG_PRINT1 (\"EXECUTING push_dummy_failure.\\n\");\n          /* See comments just above at `dummy_failure_jump' about the\n             two zeroes.  */\n          PUSH_FAILURE_POINT (0, 0, -2);\n          break;\n\n        /* Have to succeed matching what follows at least n times.\n           After that, handle like `on_failure_jump'.  */\n        case succeed_n: \n          EXTRACT_NUMBER (mcnt, p + 2);\n          DEBUG_PRINT2 (\"EXECUTING succeed_n %d.\\n\", mcnt);\n\n          assert (mcnt >= 0);\n          /* Originally, this is how many times we HAVE to succeed.  */\n          if (mcnt > 0)\n            {\n               mcnt--;\n\t       p += 2;\n               STORE_NUMBER_AND_INCR (p, mcnt);\n               DEBUG_PRINT3 (\"  Setting 0x%x to %d.\\n\", p, mcnt);\n            }\n\t  else if (mcnt == 0)\n            {\n              DEBUG_PRINT2 (\"  Setting two bytes from 0x%x to no_op.\\n\", p+2);\n\t      p[2] = (unsigned char) no_op;\n              p[3] = (unsigned char) no_op;\n              goto on_failure;\n            }\n          break;\n        \n        case jump_n: \n          EXTRACT_NUMBER (mcnt, p + 2);\n          DEBUG_PRINT2 (\"EXECUTING jump_n %d.\\n\", mcnt);\n\n          /* Originally, this is how many times we CAN jump.  */\n          if (mcnt)\n            {\n               mcnt--;\n               STORE_NUMBER (p + 2, mcnt);\n\t       goto unconditional_jump;\t     \n            }\n          /* If don't have to jump any more, skip over the rest of command.  */\n\t  else      \n\t    p += 4;\t\t     \n          break;\n        \n\tcase set_number_at:\n\t  {\n            DEBUG_PRINT1 (\"EXECUTING set_number_at.\\n\");\n\n            EXTRACT_NUMBER_AND_INCR (mcnt, p);\n            p1 = p + mcnt;\n            EXTRACT_NUMBER_AND_INCR (mcnt, p);\n            DEBUG_PRINT3 (\"  Setting 0x%x to %d.\\n\", p1, mcnt);\n\t    STORE_NUMBER (p1, mcnt);\n            break;\n          }\n\n        case wordbound:\n          DEBUG_PRINT1 (\"EXECUTING wordbound.\\n\");\n          if (AT_WORD_BOUNDARY (d))\n\t    break;\n          goto fail;\n\n\tcase notwordbound:\n          DEBUG_PRINT1 (\"EXECUTING notwordbound.\\n\");\n\t  if (AT_WORD_BOUNDARY (d))\n\t    goto fail;\n          break;\n\n\tcase wordbeg:\n          DEBUG_PRINT1 (\"EXECUTING wordbeg.\\n\");\n\t  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))\n\t    break;\n          goto fail;\n\n\tcase wordend:\n          DEBUG_PRINT1 (\"EXECUTING wordend.\\n\");\n\t  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)\n              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))\n\t    break;\n          goto fail;\n\n#ifdef emacs\n#ifdef emacs19\n  \tcase before_dot:\n          DEBUG_PRINT1 (\"EXECUTING before_dot.\\n\");\n \t  if (PTR_CHAR_POS ((unsigned char *) d) >= point)\n  \t    goto fail;\n  \t  break;\n  \n  \tcase at_dot:\n          DEBUG_PRINT1 (\"EXECUTING at_dot.\\n\");\n \t  if (PTR_CHAR_POS ((unsigned char *) d) != point)\n  \t    goto fail;\n  \t  break;\n  \n  \tcase after_dot:\n          DEBUG_PRINT1 (\"EXECUTING after_dot.\\n\");\n          if (PTR_CHAR_POS ((unsigned char *) d) <= point)\n  \t    goto fail;\n  \t  break;\n#else /* not emacs19 */\n\tcase at_dot:\n          DEBUG_PRINT1 (\"EXECUTING at_dot.\\n\");\n\t  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)\n\t    goto fail;\n\t  break;\n#endif /* not emacs19 */\n\n\tcase syntaxspec:\n          DEBUG_PRINT2 (\"EXECUTING syntaxspec %d.\\n\", mcnt);\n\t  mcnt = *p++;\n\t  goto matchsyntax;\n\n        case wordchar:\n          DEBUG_PRINT1 (\"EXECUTING Emacs wordchar.\\n\");\n\t  mcnt = (int) Sword;\n        matchsyntax:\n\t  PREFETCH ();\n\t  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)\n            goto fail;\n          SET_REGS_MATCHED ();\n\t  break;\n\n\tcase notsyntaxspec:\n          DEBUG_PRINT2 (\"EXECUTING notsyntaxspec %d.\\n\", mcnt);\n\t  mcnt = *p++;\n\t  goto matchnotsyntax;\n\n        case notwordchar:\n          DEBUG_PRINT1 (\"EXECUTING Emacs notwordchar.\\n\");\n\t  mcnt = (int) Sword;\n        matchnotsyntax:\n\t  PREFETCH ();\n\t  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)\n            goto fail;\n\t  SET_REGS_MATCHED ();\n          break;\n\n#else /* not emacs */\n\tcase wordchar:\n          DEBUG_PRINT1 (\"EXECUTING non-Emacs wordchar.\\n\");\n\t  PREFETCH ();\n          if (!WORDCHAR_P (d))\n            goto fail;\n\t  SET_REGS_MATCHED ();\n          d++;\n\t  break;\n\t  \n\tcase notwordchar:\n          DEBUG_PRINT1 (\"EXECUTING non-Emacs notwordchar.\\n\");\n\t  PREFETCH ();\n\t  if (WORDCHAR_P (d))\n            goto fail;\n          SET_REGS_MATCHED ();\n          d++;\n\t  break;\n#endif /* not emacs */\n          \n        default:\n          abort ();\n\t}\n      continue;  /* Successfully executed one pattern command; keep going.  */\n\n\n    /* We goto here if a matching operation fails. */\n    fail:\n      if (!FAIL_STACK_EMPTY ())\n\t{ /* A restart point is known.  Restore to that state.  */\n          DEBUG_PRINT1 (\"\\nFAIL:\\n\");\n          POP_FAILURE_POINT (d, p,\n                             lowest_active_reg, highest_active_reg,\n                             regstart, regend, reg_info);\n\n          /* If this failure point is a dummy, try the next one.  */\n          if (!p)\n\t    goto fail;\n\n          /* If we failed to the end of the pattern, don't examine *p.  */\n\t  assert (p <= pend);\n          if (p < pend)\n            {\n              boolean is_a_jump_n = false;\n              \n              /* If failed to a backwards jump that's part of a repetition\n                 loop, need to pop this failure point and use the next one.  */\n              switch ((re_opcode_t) *p)\n                {\n                case jump_n:\n                  is_a_jump_n = true;\n                case maybe_pop_jump:\n                case pop_failure_jump:\n                case jump:\n                  p1 = p + 1;\n                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n                  p1 += mcnt;\t\n\n                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)\n                      || (!is_a_jump_n\n                          && (re_opcode_t) *p1 == on_failure_jump))\n                    goto fail;\n                  break;\n                default:\n                  /* do nothing */ ;\n                }\n            }\n\n          if (d >= string1 && d <= end1)\n\t    dend = end_match_1;\n        }\n      else\n        break;   /* Matching at this starting point really fails.  */\n    } /* for (;;) */\n\n  if (best_regs_set)\n    goto restore_best_regs;\n\n  FREE_VARIABLES ();\n\n  return -1;         \t\t\t/* Failure to match.  */\n} /* re_match_2 */\n\f\n/* Subroutine definitions for re_match_2.  */\n\n\n/* We are passed P pointing to a register number after a start_memory.\n   \n   Return true if the pattern up to the corresponding stop_memory can\n   match the empty string, and false otherwise.\n   \n   If we find the matching stop_memory, sets P to point to one past its number.\n   Otherwise, sets P to an undefined byte less than or equal to END.\n\n   We don't handle duplicates properly (yet).  */\n\nstatic boolean\ngroup_match_null_string_p (p, end, reg_info)\n    unsigned char **p, *end;\n    register_info_type *reg_info;\n{\n  int mcnt;\n  /* Point to after the args to the start_memory.  */\n  unsigned char *p1 = *p + 2;\n  \n  while (p1 < end)\n    {\n      /* Skip over opcodes that can match nothing, and return true or\n\t false, as appropriate, when we get to one that can't, or to the\n         matching stop_memory.  */\n      \n      switch ((re_opcode_t) *p1)\n        {\n        /* Could be either a loop or a series of alternatives.  */\n        case on_failure_jump:\n          p1++;\n          EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n          \n          /* If the next operation is not a jump backwards in the\n\t     pattern.  */\n\n\t  if (mcnt >= 0)\n\t    {\n              /* Go through the on_failure_jumps of the alternatives,\n                 seeing if any of the alternatives cannot match nothing.\n                 The last alternative starts with only a jump,\n                 whereas the rest start with on_failure_jump and end\n                 with a jump, e.g., here is the pattern for `a|b|c':\n\n                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6\n                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3\n                 /exactn/1/c\t\t\t\t\t\t\n\n                 So, we have to first go through the first (n-1)\n                 alternatives and then deal with the last one separately.  */\n\n\n              /* Deal with the first (n-1) alternatives, which start\n                 with an on_failure_jump (see above) that jumps to right\n                 past a jump_past_alt.  */\n\n              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)\n                {\n                  /* `mcnt' holds how many bytes long the alternative\n                     is, including the ending `jump_past_alt' and\n                     its number.  */\n\n                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, \n\t\t\t\t                      reg_info))\n                    return false;\n\n                  /* Move to right after this alternative, including the\n\t\t     jump_past_alt.  */\n                  p1 += mcnt;\t\n\n                  /* Break if it's the beginning of an n-th alternative\n                     that doesn't begin with an on_failure_jump.  */\n                  if ((re_opcode_t) *p1 != on_failure_jump)\n                    break;\n\t\t\n\t\t  /* Still have to check that it's not an n-th\n\t\t     alternative that starts with an on_failure_jump.  */\n\t\t  p1++;\n                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)\n                    {\n\t\t      /* Get to the beginning of the n-th alternative.  */\n                      p1 -= 3;\n                      break;\n                    }\n                }\n\n              /* Deal with the last alternative: go back and get number\n                 of the `jump_past_alt' just before it.  `mcnt' contains\n                 the length of the alternative.  */\n              EXTRACT_NUMBER (mcnt, p1 - 2);\n\n              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))\n                return false;\n\n              p1 += mcnt;\t/* Get past the n-th alternative.  */\n            } /* if mcnt > 0 */\n          break;\n\n          \n        case stop_memory:\n\t  assert (p1[1] == **p);\n          *p = p1 + 2;\n          return true;\n\n        \n        default: \n          if (!common_op_match_null_string_p (&p1, end, reg_info))\n            return false;\n        }\n    } /* while p1 < end */\n\n  return false;\n} /* group_match_null_string_p */\n\n\n/* Similar to group_match_null_string_p, but doesn't deal with alternatives:\n   It expects P to be the first byte of a single alternative and END one\n   byte past the last. The alternative can contain groups.  */\n   \nstatic boolean\nalt_match_null_string_p (p, end, reg_info)\n    unsigned char *p, *end;\n    register_info_type *reg_info;\n{\n  int mcnt;\n  unsigned char *p1 = p;\n  \n  while (p1 < end)\n    {\n      /* Skip over opcodes that can match nothing, and break when we get \n         to one that can't.  */\n      \n      switch ((re_opcode_t) *p1)\n        {\n\t/* It's a loop.  */\n        case on_failure_jump:\n          p1++;\n          EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n          p1 += mcnt;\n          break;\n          \n\tdefault: \n          if (!common_op_match_null_string_p (&p1, end, reg_info))\n            return false;\n        }\n    }  /* while p1 < end */\n\n  return true;\n} /* alt_match_null_string_p */\n\n\n/* Deals with the ops common to group_match_null_string_p and\n   alt_match_null_string_p.  \n   \n   Sets P to one after the op and its arguments, if any.  */\n\nstatic boolean\ncommon_op_match_null_string_p (p, end, reg_info)\n    unsigned char **p, *end;\n    register_info_type *reg_info;\n{\n  int mcnt;\n  boolean ret;\n  int reg_no;\n  unsigned char *p1 = *p;\n\n  switch ((re_opcode_t) *p1++)\n    {\n    case no_op:\n    case begline:\n    case endline:\n    case begbuf:\n    case endbuf:\n    case wordbeg:\n    case wordend:\n    case wordbound:\n    case notwordbound:\n#ifdef emacs\n    case before_dot:\n    case at_dot:\n    case after_dot:\n#endif\n      break;\n\n    case start_memory:\n      reg_no = *p1;\n      assert (reg_no > 0 && reg_no <= MAX_REGNUM);\n      ret = group_match_null_string_p (&p1, end, reg_info);\n      \n      /* Have to set this here in case we're checking a group which\n         contains a group and a back reference to it.  */\n\n      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)\n        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;\n\n      if (!ret)\n        return false;\n      break;\n          \n    /* If this is an optimized succeed_n for zero times, make the jump.  */\n    case jump:\n      EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n      if (mcnt >= 0)\n        p1 += mcnt;\n      else\n        return false;\n      break;\n\n    case succeed_n:\n      /* Get to the number of times to succeed.  */\n      p1 += 2;\t\t\n      EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n\n      if (mcnt == 0)\n        {\n          p1 -= 4;\n          EXTRACT_NUMBER_AND_INCR (mcnt, p1);\n          p1 += mcnt;\n        }\n      else\n        return false;\n      break;\n\n    case duplicate: \n      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))\n        return false;\n      break;\n\n    case set_number_at:\n      p1 += 4;\n\n    default:\n      /* All other opcodes mean we cannot match the empty string.  */\n      return false;\n  }\n\n  *p = p1;\n  return true;\n} /* common_op_match_null_string_p */\n\n\n/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN\n   bytes; nonzero otherwise.  */\n   \nstatic int\nbcmp_translate (s1, s2, len, translate)\n     unsigned char *s1, *s2;\n     register int len;\n     char *translate;\n{\n  register unsigned char *p1 = s1, *p2 = s2;\n  while (len)\n    {\n      if (translate[*p1++] != translate[*p2++]) return 1;\n      len--;\n    }\n  return 0;\n}\n\f\n/* Entry points for GNU code.  */\n\n/* re_compile_pattern is the GNU regular expression compiler: it\n   compiles PATTERN (of length SIZE) and puts the result in BUFP.\n   Returns 0 if the pattern was valid, otherwise an error string.\n   \n   Assumes the `allocated' (and perhaps `buffer') and `translate' fields\n   are set in BUFP on entry.\n   \n   We call regex_compile to do the actual compilation.  */\n\nconst char *\nre_compile_pattern (pattern, length, bufp)\n     const char *pattern;\n     int length;\n     struct re_pattern_buffer *bufp;\n{\n  reg_errcode_t ret;\n  \n  /* GNU code is written to assume at least RE_NREGS registers will be set\n     (and at least one extra will be -1).  */\n  bufp->regs_allocated = REGS_UNALLOCATED;\n  \n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub.  */\n  bufp->no_sub = 0;\n  \n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n  \n  ret = regex_compile (pattern, length, re_syntax_options, bufp);\n\n  return re_error_msg[(int) ret];\n}     \n\f\n/* Entry points compatible with 4.2 BSD regex library.  We don't define\n   them if this is an Emacs or POSIX compilation.  */\n\n#if !defined (emacs) && !defined (_POSIX_SOURCE)\n\n/* BSD has one and only one pattern buffer.  */\nstatic struct re_pattern_buffer re_comp_buf;\n\nchar *\nre_comp (s)\n    const char *s;\n{\n  reg_errcode_t ret;\n  \n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn \"No previous regular expression\";\n      return 0;\n    }\n\n  if (!re_comp_buf.buffer)\n    {\n      re_comp_buf.buffer = (unsigned char *) malloc (200);\n      if (re_comp_buf.buffer == NULL)\n        return \"Memory exhausted\";\n      re_comp_buf.allocated = 200;\n\n      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);\n      if (re_comp_buf.fastmap == NULL)\n\treturn \"Memory exhausted\";\n    }\n\n  /* Since `re_exec' always passes NULL for the `regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);\n  \n  /* Yes, we're discarding `const' here.  */\n  return (char *) re_error_msg[(int) ret];\n}\n\n\nint\nre_exec (s)\n    const char *s;\n{\n  const int len = strlen (s);\n  return\n    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);\n}\n#endif /* not emacs and not _POSIX_SOURCE */\n\f\n/* POSIX.2 functions.  Don't define these for Emacs.  */\n\n#ifndef emacs\n\n/* regcomp takes a regular expression as a string and compiles it.\n\n   PREG is a regex_t *.  We do not expect any fields to be initialized,\n   since POSIX says we shouldn't.  Thus, we set\n\n     `buffer' to the compiled pattern;\n     `used' to the length of the compiled pattern;\n     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the\n       REG_EXTENDED bit in CFLAGS is set; otherwise, to\n       RE_SYNTAX_POSIX_BASIC;\n     `newline_anchor' to REG_NEWLINE being set in CFLAGS;\n     `fastmap' and `fastmap_accurate' to zero;\n     `re_nsub' to the number of subexpressions in PATTERN.\n\n   PATTERN is the address of the pattern string.\n\n   CFLAGS is a series of bits which affect compilation.\n\n     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we\n     use POSIX basic syntax.\n\n     If REG_NEWLINE is set, then . and [^...] don't match newline.\n     Also, regexec will try a match beginning after every newline.\n\n     If REG_ICASE is set, then we considers upper- and lowercase\n     versions of letters to be equivalent when matching.\n\n     If REG_NOSUB is set, then when PREG is passed to regexec, that\n     routine will report only success or failure, and nothing about the\n     registers.\n\n   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for\n   the return codes and their meanings.)  */\n\nint\nregcomp (preg, pattern, cflags)\n    regex_t *preg;\n    const char *pattern; \n    int cflags;\n{\n  reg_errcode_t ret;\n  unsigned syntax\n    = (cflags & REG_EXTENDED) ?\n      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;\n\n  /* regex_compile will allocate the space for the compiled pattern.  */\n  preg->buffer = 0;\n  preg->allocated = 0;\n  preg->used = 0;\n  \n  /* Don't bother to use a fastmap when searching.  This simplifies the\n     REG_NEWLINE case: if we used a fastmap, we'd have to put all the\n     characters after newlines into the fastmap.  This way, we just try\n     every character.  */\n  preg->fastmap = 0;\n  \n  if (cflags & REG_ICASE)\n    {\n      unsigned i;\n      \n      preg->translate = (char *) malloc (CHAR_SET_SIZE);\n      if (preg->translate == NULL)\n        return (int) REG_ESPACE;\n\n      /* Map uppercase characters to corresponding lowercase ones.  */\n      for (i = 0; i < CHAR_SET_SIZE; i++)\n        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;\n    }\n  else\n    preg->translate = NULL;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n\n  preg->no_sub = !!(cflags & REG_NOSUB);\n\n  /* POSIX says a null character in the pattern terminates it, so we \n     can use strlen here in compiling the pattern.  */\n  ret = regex_compile (pattern, strlen (pattern), syntax, preg);\n  \n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN) ret = REG_EPAREN;\n  \n  return (int) ret;\n}\n\n\n/* regexec searches for a given pattern, specified by PREG, in the\n   string STRING.\n   \n   If NMATCH is zero or REG_NOSUB was set in the cflags argument to\n   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at\n   least NMATCH elements, and we set them to the offsets of the\n   corresponding matched substrings.\n   \n   EFLAGS specifies `execution flags' which affect matching: if\n   REG_NOTBOL is set, then ^ does not match at the beginning of the\n   string; if REG_NOTEOL is set, then $ does not match at the end.\n   \n   We return 0 if we find a match and REG_NOMATCH if not.  */\n\nint\nregexec (preg, string, nmatch, pmatch, eflags)\n    const regex_t *preg;\n    const char *string; \n    size_t nmatch; \n    regmatch_t pmatch[]; \n    int eflags;\n{\n  int ret;\n  struct re_registers regs;\n  regex_t private_preg;\n  int len = strlen (string);\n  boolean want_reg_info = !preg->no_sub && nmatch > 0;\n\n  private_preg = *preg;\n  \n  private_preg.not_bol = !!(eflags & REG_NOTBOL);\n  private_preg.not_eol = !!(eflags & REG_NOTEOL);\n  \n  /* The user has told us exactly how many registers to return\n     information about, via `nmatch'.  We have to pass that on to the\n     matching routines.  */\n  private_preg.regs_allocated = REGS_FIXED;\n  \n  if (want_reg_info)\n    {\n      regs.num_regs = nmatch;\n      regs.start = TALLOC (nmatch, regoff_t);\n      regs.end = TALLOC (nmatch, regoff_t);\n      if (regs.start == NULL || regs.end == NULL)\n        return (int) REG_NOMATCH;\n    }\n\n  /* Perform the searching operation.  */\n  ret = re_search (&private_preg, string, len,\n                   /* start: */ 0, /* range: */ len,\n                   want_reg_info ? &regs : (struct re_registers *) 0);\n  \n  /* Copy the register information to the POSIX structure.  */\n  if (want_reg_info)\n    {\n      if (ret >= 0)\n        {\n          unsigned r;\n\n          for (r = 0; r < nmatch; r++)\n            {\n              pmatch[r].rm_so = regs.start[r];\n              pmatch[r].rm_eo = regs.end[r];\n            }\n        }\n\n      /* If we needed the temporary register info, free the space now.  */\n      free (regs.start);\n      free (regs.end);\n    }\n\n  /* We want zero return to mean success, unlike `re_search'.  */\n  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;\n}\n\n\n/* Returns a message corresponding to an error code, ERRCODE, returned\n   from either regcomp or regexec.   We don't use PREG here.  */\n\nsize_t\nregerror (errcode, preg, errbuf, errbuf_size)\n    int errcode;\n    const regex_t *preg;\n    char *errbuf;\n    size_t errbuf_size;\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (errcode < 0\n      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))\n    /* Only error codes returned by the rest of the code should be passed \n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = re_error_msg[errcode];\n\n  /* POSIX doesn't require that we do anything in this case, but why\n     not be nice.  */\n  if (! msg)\n    msg = \"Success\";\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n  \n  if (errbuf_size != 0)\n    {\n      if (msg_size > errbuf_size)\n        {\n          strncpy (errbuf, msg, errbuf_size - 1);\n          errbuf[errbuf_size - 1] = 0;\n        }\n      else\n        strcpy (errbuf, msg);\n    }\n\n  return msg_size;\n}\n\n\n/* Free dynamically allocated space used by PREG.  */\n\nvoid\nregfree (preg)\n    regex_t *preg;\n{\n  if (preg->buffer != NULL)\n    free (preg->buffer);\n  preg->buffer = NULL;\n  \n  preg->allocated = 0;\n  preg->used = 0;\n\n  if (preg->fastmap != NULL)\n    free (preg->fastmap);\n  preg->fastmap = NULL;\n  preg->fastmap_accurate = 0;\n\n  if (preg->translate != NULL)\n    free (preg->translate);\n  preg->translate = NULL;\n}\n\n#endif /* not emacs  */\n\f\n/*\nLocal variables:\nmake-backup-files: t\nversion-control: t\ntrim-versions-without-asking: nil\nEnd:\n*/\n/* dfa.c - deterministic extended regexp routines for GNU\n   Copyright (C) 1988 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n/* Written June, 1988 by Mike Haertel\n   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */\n\n/*#include <assert.h> */\n/*#include <ctype.h> */\n/*#include <stdio.h> */\n\n#ifdef STDC_HEADERS\n#if flag_stdlib==0\n#include <stdlib.h>\n#define flag_stdlib 1\n#endif\n#else\n#if flag_systypes==0 \n#include <sys/types.h>\n#define flag_systypes 1\n#endif\nextern char *calloc(), *malloc(), *realloc();\nextern void free();\n#endif\n\n#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)\n#if flag_string==0\n#include <string.h>\n#define flag_string 1\n#endif\n#undef index\n#define index strchr\n#else\n#if flag_strings==0\n#include <strings.h>\n#define flag_strings 1\n#endif\n#endif\n\n#ifndef isgraph\n#define isgraph(C) (isprint(C) && !isspace(C))\n#endif\n\n#undef ISALPHA\n#undef ISUPPER\n#undef ISLOWER\n#undef ISDIGIT\n#undef ISXDIGIT\n#undef ISSPACE\n#undef ISPUNCT\n#undef ISALNUM\n#undef ISPRINT\n#undef ISGRAPH\n#undef ISCNTRL\n\n\n#ifdef isascii\n#define ISALPHA(C) (isascii(C) && isalpha(C))\n#define ISUPPER(C) (isascii(C) && isupper(C))\n#define ISLOWER(C) (isascii(C) && islower(C))\n#define ISDIGIT(C) (isascii(C) && isdigit(C))\n#define ISXDIGIT(C) (isascii(C) && isxdigit(C))\n#define ISSPACE(C) (isascii(C) && isspace(C))\n#define ISPUNCT(C) (isascii(C) && ispunct(C))\n#define ISALNUM(C) (isascii(C) && isalnum(C))\n#define ISPRINT(C) (isascii(C) && isprint(C))\n#define ISGRAPH(C) (isascii(C) && isgraph(C))\n#define ISCNTRL(C) (isascii(C) && iscntrl(C))\n#else\n#define ISALPHA(C) isalpha(C)\n#define ISUPPER(C) isupper(C)\n#define ISLOWER(C) islower(C)\n#define ISDIGIT(C) isdigit(C)\n#define ISXDIGIT(C) isxdigit(C)\n#define ISSPACE(C) isspace(C)\n#define ISPUNCT(C) ispunct(C)\n#define ISALNUM(C) isalnum(C)\n#define ISPRINT(C) isprint(C)\n#define ISGRAPH(C) isgraph(C)\n#define ISCNTRL(C) iscntrl(C)\n#endif\n\n#include \"dfa.h\"\n/*#include \"regex.h\"*/\n\n#if __STDC__\ntypedef void *ptr_t;\n#else\ntypedef char *ptr_t;\n#endif\n\nstatic void\tdfamust();\n\nstatic ptr_t\nxcalloc(n, s)\n     int n;\n     size_t s;\n{\n  ptr_t r = calloc(n, s);\n\n  if (!r)\n    dfaerror(\"Memory exhausted\");\n  return r;\n}\n\nstatic ptr_t\nxmalloc_1(n)\n     size_t n;\n{\n  ptr_t r = malloc(n);\n\n  assert(n != 0);\n  if (!r)\n    dfaerror(\"Memory exhausted\");\n  return r;\n}\n\nstatic ptr_t\nxrealloc_1(p, n)\n     ptr_t p;\n     size_t n;\n{\n  ptr_t r = realloc(p, n);\n\n  assert(n != 0);\n  if (!r)\n    dfaerror(\"Memory exhausted\");\n  return r;\n}\n\n#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))\n#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))\n#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))\n\n/* Reallocate an array of type t if nalloc is too small for index. */\n#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \\\n  if ((index) >= (nalloc))\t\t\t  \\\n    {\t\t\t\t\t\t  \\\n      while ((index) >= (nalloc))\t\t  \\\n\t(nalloc) *= 2;\t\t\t\t  \\\n      REALLOC(p, t, nalloc);\t\t\t  \\\n    }\n\n#ifdef DEBUG\n\nstatic void\nprtok(t)\n     token t;\n{\n  char *s;\n\n  if (t < 0)\n    fprintf(stderr, \"END\");\n  else if (t < NOTCHAR)\n    fprintf(stderr, \"%c\", t);\n  else\n    {\n      switch (t)\n\t{\n\tcase EMPTY: s = \"EMPTY\"; break;\n\tcase BACKREF: s = \"BACKREF\"; break;\n\tcase BEGLINE: s = \"BEGLINE\"; break;\n\tcase ENDLINE: s = \"ENDLINE\"; break;\n\tcase BEGWORD: s = \"BEGWORD\"; break;\n\tcase ENDWORD: s = \"ENDWORD\"; break;\n\tcase LIMWORD: s = \"LIMWORD\"; break;\n\tcase NOTLIMWORD: s = \"NOTLIMWORD\"; break;\n\tcase QMARK: s = \"QMARK\"; break;\n\tcase STAR: s = \"STAR\"; break;\n\tcase PLUS: s = \"PLUS\"; break;\n\tcase CAT: s = \"CAT\"; break;\n\tcase OR: s = \"OR\"; break;\n\tcase ORTOP: s = \"ORTOP\"; break;\n\tcase LPAREN: s = \"LPAREN\"; break;\n\tcase RPAREN: s = \"RPAREN\"; break;\n\tdefault: s = \"CSET\"; break;\n\t}\n      fprintf(stderr, \"%s\", s);\n    }\n}\n#endif /* DEBUG */\n\n/* Stuff pertaining to charclasses. */\n\nstatic int\ntstbit(b, c)\n     int b;\n     charclass c;\n{\n  return c[b / INTBITS] & 1 << b % INTBITS;\n}\n\nstatic void\nsetbit(b, c)\n     int b;\n     charclass c;\n{\n  c[b / INTBITS] |= 1 << b % INTBITS;\n}\n\nstatic void\nclrbit(b, c)\n     int b;\n     charclass c;\n{\n  c[b / INTBITS] &= ~(1 << b % INTBITS);\n}\n\nstatic void\ncopyset(src, dst)\n     charclass src;\n     charclass dst;\n{\n  int i;\n\n  for (i = 0; i < CHARCLASS_INTS; ++i)\n    dst[i] = src[i];\n}\n\nstatic void\nzeroset(s)\n     charclass s;\n{\n  int i;\n\n  for (i = 0; i < CHARCLASS_INTS; ++i)\n    s[i] = 0;\n}\n\nstatic void\nnotset(s)\n     charclass s;\n{\n  int i;\n\n  for (i = 0; i < CHARCLASS_INTS; ++i)\n    s[i] = ~s[i];\n}\n\nstatic int\nequal(s1, s2)\n     charclass s1;\n     charclass s2;\n{\n  int i;\n\n  for (i = 0; i < CHARCLASS_INTS; ++i)\n    if (s1[i] != s2[i])\n      return 0;\n  return 1;\n}\n\n/* A pointer to the current dfa is kept here during parsing. */\nstatic struct dfa *dfa;\n\n/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */\nstatic int\ncharclass_index(s)\n     charclass s;\n{\n  int i;\n\n  for (i = 0; i < dfa->cindex; ++i)\n    if (equal(s, dfa->charclasses[i]))\n      return i;\n  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);\n  ++dfa->cindex;\n  copyset(s, dfa->charclasses[i]);\n  return i;\n}\n\n/* Syntax bits controlling the behavior of the lexical analyzer. */\nstatic int syntax_bits, syntax_bits_set;\n\n/* Flag for case-folding letters into sets. */\nstatic int case_fold;\n\n/* Entry point to set syntax options. */\nvoid\ndfasyntax(bits, fold)\n     int bits;\n     int fold;\n{\n  syntax_bits_set = 1;\n  syntax_bits = bits;\n  case_fold = fold;\n}\n\n/* Lexical analyzer.  All the dross that deals with the obnoxious\n   GNU Regex syntax bits is located here.  The poor, suffering\n   reader is referred to the GNU Regex documentation for the\n   meaning of the @#%!@#%^!@ syntax bits. */\n\nstatic char *lexstart;\t\t/* Pointer to beginning of input string. */\nstatic char *lexptr;\t\t/* Pointer to next input character. */\nstatic lexleft;\t\t\t/* Number of characters remaining. */\nstatic token lasttok;\t\t/* Previous token returned; initially END. */\nstatic int laststart;\t\t/* True if we're separated from beginning or (, |\n\t\t\t\t   only by zero-width characters. */\nstatic int parens;\t\t/* Count of outstanding left parens. */\nstatic int minrep, maxrep;\t/* Repeat counts for {m,n}. */\n\n/* Note that characters become unsigned here. */\n#define FETCH(c, eoferr)   \t      \\\n  {\t\t\t   \t      \\\n    if (! lexleft)\t   \t      \\\n      if (eoferr != 0)\t   \t      \\\n\tdfaerror(eoferr);  \t      \\\n      else\t\t   \t      \\\n\treturn END;\t   \t      \\\n    (c) = (unsigned char) *lexptr++;  \\\n    --lexleft;\t\t   \t      \\\n  }\n\n#define FUNC(F, P) static int F(c) int c; { return P(c); }\n\nFUNC(is_alpha, ISALPHA)\nFUNC(is_upper, ISUPPER)\nFUNC(is_lower, ISLOWER)\nFUNC(is_digit, ISDIGIT)\nFUNC(is_xdigit, ISXDIGIT)\nFUNC(is_space, ISSPACE)\nFUNC(is_punct, ISPUNCT)\nFUNC(is_alnum, ISALNUM)\nFUNC(is_print, ISPRINT)\nFUNC(is_graph, ISGRAPH)\nFUNC(is_cntrl, ISCNTRL)\n\n/* The following list maps the names of the Posix named character classes\n   to predicate functions that determine whether a given character is in\n   the class.  The leading [ has already been eaten by the lexical analyzer. */\nstatic struct {\n  char *name;\n  int (*pred)();\n} prednames[] = {\n  \":alpha:]\", is_alpha,\n  \":upper:]\", is_upper,\n  \":lower:]\", is_lower,\n  \":digit:]\", is_digit,\n  \":xdigit:]\", is_xdigit,\n  \":space:]\", is_space,\n  \":punct:]\", is_punct,\n  \":alnum:]\", is_alnum,\n  \":print:]\", is_print,\n  \":graph:]\", is_graph,\n  \":cntrl:]\", is_cntrl,\n  0\n};\n\nstatic int\nlooking_at(s)\n     char *s;\n{\n  int len;\n\n  len = strlen(s);\n  if (lexleft < len)\n    return 0;\n  return strncmp(s, lexptr, len) == 0;\n}\n\nstatic token\nlex()\n{\n  token c, c1, c2;\n  int backslash = 0, invert;\n  charclass ccl;\n  int i;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (i = 0; i < 2; ++i)\n    {\n      FETCH(c, 0);\n      switch (c)\n\t{\n\tcase '\\\\':\n\t  if (backslash)\n\t    goto normal_char;\n\t  if (lexleft == 0)\n\t    dfaerror(\"Unfinished \\\\ escape\");\n\t  backslash = 1;\n\t  break;\n\n\tcase '^':\n\t  if (backslash)\n\t    goto normal_char;\n\t  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n\t      || lasttok == END\n\t      || lasttok == LPAREN\n\t      || lasttok == OR)\n\t    return lasttok = BEGLINE;\n\t  goto normal_char;\n\n\tcase '$':\n\t  if (backslash)\n\t    goto normal_char;\n\t  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n\t      || lexleft == 0\n\t      || (syntax_bits & RE_NO_BK_PARENS\n\t\t  ? lexleft > 0 && *lexptr == ')'\n\t\t  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == ')')\n\t      || (syntax_bits & RE_NO_BK_VBAR\n\t\t  ? lexleft > 0 && *lexptr == '|'\n\t\t  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == '|')\n\t      || ((syntax_bits & RE_NEWLINE_ALT)\n\t          && lexleft > 0 && *lexptr == '\\n'))\n\t    return lasttok = ENDLINE;\n\t  goto normal_char;\n\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (backslash && !(syntax_bits & RE_NO_BK_REFS))\n\t    {\n\t      laststart = 0;\n\t      return lasttok = BACKREF;\n\t    }\n\t  goto normal_char;\n\n\tcase '<':\n\t  if (backslash)\n\t    return lasttok = BEGWORD;\n\t  goto normal_char;\n\n\tcase '>':\n\t  if (backslash)\n\t    return lasttok = ENDWORD;\n\t  goto normal_char;\n\n\tcase 'b':\n\t  if (backslash)\n\t    return lasttok = LIMWORD;\n\t  goto normal_char;\n\n\tcase 'B':\n\t  if (backslash)\n\t    return lasttok = NOTLIMWORD;\n\t  goto normal_char;\n\n\tcase '?':\n\t  if (syntax_bits & RE_LIMITED_OPS)\n\t    goto normal_char;\n\t  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n\t    goto normal_char;\n\t  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n\t    goto normal_char;\n\t  return lasttok = QMARK;\n\n\tcase '*':\n\t  if (backslash)\n\t    goto normal_char;\n\t  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n\t    goto normal_char;\n\t  return lasttok = STAR;\n\n\tcase '+':\n\t  if (syntax_bits & RE_LIMITED_OPS)\n\t    goto normal_char;\n\t  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n\t    goto normal_char;\n\t  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n\t    goto normal_char;\n\t  return lasttok = PLUS;\n\n\tcase '{':\n\t  if (!(syntax_bits & RE_INTERVALS))\n\t    goto normal_char;\n\t  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))\n\t    goto normal_char;\n\t  minrep = maxrep = 0;\n\t  /* Cases:\n\t     {M} - exact count\n\t     {M,} - minimum count, maximum is infinity\n\t     {,M} - 0 through M\n\t     {M,N} - M through N */\n\t  FETCH(c, \"unfinished repeat count\");\n\t  if (ISDIGIT(c))\n\t    {\n\t      minrep = c - '0';\n\t      for (;;)\n\t\t{\n\t\t  FETCH(c, \"unfinished repeat count\");\n\t\t  if (!ISDIGIT(c))\n\t\t    break;\n\t\t  minrep = 10 * minrep + c - '0';\n\t\t}\n\t    }\n\t  else if (c != ',')\n\t    dfaerror(\"malformed repeat count\");\n\t  if (c == ',')\n\t    for (;;)\n\t      {\n\t\tFETCH(c, \"unfinished repeat count\");\n\t\tif (!ISDIGIT(c))\n\t\t  break;\n\t\tmaxrep = 10 * maxrep + c - '0';\n\t      }\n\t  else\n\t    maxrep = minrep;\n\t  if (!(syntax_bits & RE_NO_BK_BRACES))\n\t    {\n\t      if (c != '\\\\')\n\t\tdfaerror(\"malformed repeat count\");\n\t      FETCH(c, \"unfinished repeat count\");\n\t    }\n\t  if (c != '}')\n\t    dfaerror(\"malformed repeat count\");\n\t  laststart = 0;\n\t  return lasttok = REPMN;\n\n\tcase '|':\n\t  if (syntax_bits & RE_LIMITED_OPS)\n\t    goto normal_char;\n\t  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))\n\t    goto normal_char;\n\t  laststart = 1;\n\t  return lasttok = OR;\n\n\tcase '\\n':\n\t  if (syntax_bits & RE_LIMITED_OPS\n\t      || backslash\n\t      || !(syntax_bits & RE_NEWLINE_ALT))\n\t    goto normal_char;\n\t  laststart = 1;\n\t  return lasttok = OR;\n\n\tcase '(':\n\t  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n\t    goto normal_char;\n\t  ++parens;\n\t  laststart = 1;\n\t  return lasttok = LPAREN;\n\n\tcase ')':\n\t  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n\t    goto normal_char;\n\t  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n\t    goto normal_char;\n\t  --parens;\n\t  laststart = 0;\n\t  return lasttok = RPAREN;\n\n\tcase '.':\n\t  if (backslash)\n\t    goto normal_char;\n\t  zeroset(ccl);\n\t  notset(ccl);\n\t  if (!(syntax_bits & RE_DOT_NEWLINE))\n\t    clrbit('\\n', ccl);\n\t  if (syntax_bits & RE_DOT_NOT_NULL)\n\t    clrbit('\\0', ccl);\n\t  laststart = 0;\n\t  return lasttok = CSET + charclass_index(ccl);\n\n\tcase 'w':\n\tcase 'W':\n\t  if (!backslash)\n\t    goto normal_char;\n\t  zeroset(ccl);\n\t  for (c2 = 0; c2 < NOTCHAR; ++c2)\n\t    if (ISALNUM(c2))\n\t      setbit(c2, ccl);\n\t  if (c == 'W')\n\t    notset(ccl);\n\t  laststart = 0;\n\t  return lasttok = CSET + charclass_index(ccl);\n\t\n\tcase '[':\n\t  if (backslash)\n\t    goto normal_char;\n\t  zeroset(ccl);\n\t  FETCH(c, \"Unbalanced [\");\n\t  if (c == '^')\n\t    {\n\t      FETCH(c, \"Unbalanced [\");\n\t      invert = 1;\n\t    }\n\t  else\n\t    invert = 0;\n\t  do\n\t    {\n\t      /* Nobody ever said this had to be fast. :-)\n\t\t Note that if we're looking at some other [:...:]\n\t\t construct, we just treat it as a bunch of ordinary\n\t\t characters.  We can do this because we assume\n\t\t regex has checked for syntax errors before\n\t\t dfa is ever called. */\n\t      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))\n\t\tfor (c1 = 0; prednames[c1].name; ++c1)\n\t\t  if (looking_at(prednames[c1].name))\n\t\t    {\n\t\t      for (c2 = 0; c2 < NOTCHAR; ++c2)\n\t\t\tif ((*prednames[c1].pred)(c2))\n\t\t\t  setbit(c2, ccl);\n\t\t      lexptr += strlen(prednames[c1].name);\n\t\t      lexleft -= strlen(prednames[c1].name);\n\t\t      FETCH(c1, \"Unbalanced [\");\n\t\t      goto skip;\n\t\t    }\n\t      if (c == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n\t\tFETCH(c, \"Unbalanced [\");\n\t      FETCH(c1, \"Unbalanced [\");\n\t      if (c1 == '-')\n\t\t{\n\t\t  FETCH(c2, \"Unbalanced [\");\n\t\t  if (c2 == ']')\n\t\t    {\n\t\t      /* In the case [x-], the - is an ordinary hyphen,\n\t\t\t which is left in c1, the lookahead character. */\n\t\t      --lexptr;\n\t\t      ++lexleft;\n\t\t      c2 = c;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (c2 == '\\\\'\n\t\t\t  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n\t\t\tFETCH(c2, \"Unbalanced [\");\n\t\t      FETCH(c1, \"Unbalanced [\");\n\t\t    }\n\t\t}\n\t      else\n\t\tc2 = c;\n\t      while (c <= c2)\n\t\t{\n\t\t  setbit(c, ccl);\n\t\t  if (case_fold)\n\t\t    if (ISUPPER(c))\n\t\t      setbit(tolower(c), ccl);\n\t\t    else if (ISLOWER(c))\n\t\t      setbit(toupper(c), ccl);\n\t\t  ++c;\n\t\t}\n\t    skip:\n\t      ;\n\t    }\n\t  while ((c = c1) != ']');\n\t  if (invert)\n\t    {\n\t      notset(ccl);\n\t      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n\t\tclrbit('\\n', ccl);\n\t    }\n\t  laststart = 0;\n\t  return lasttok = CSET + charclass_index(ccl);\n\n\tdefault:\n\tnormal_char:\n\t  laststart = 0;\n\t  if (case_fold && ISALPHA(c))\n\t    {\n\t      zeroset(ccl);\n\t      setbit(c, ccl);\n\t      if (isupper(c))\n\t\tsetbit(tolower(c), ccl);\n\t      else\n\t\tsetbit(toupper(c), ccl);\n\t      return lasttok = CSET + charclass_index(ccl);\n\t    }\n\t  return c;\n\t}\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character. */\n  abort();\n}\n\n/* Recursive descent parser for regular expressions. */\n\nstatic token tok;\t\t/* Lookahead token. */\nstatic depth;\t\t\t/* Current depth of a hypothetical stack\n\t\t\t\t   holding deferred productions.  This is\n\t\t\t\t   used to determine the depth that will be\n\t\t\t\t   required of the real stack later on in\n\t\t\t\t   dfaanalyze(). */\n\n/* Add the given token to the parse tree, maintaining the depth count and\n   updating the maximum depth if necessary. */\nstatic void\naddtok(t)\n     token t;\n{\n  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);\n  dfa->tokens[dfa->tindex++] = t;\n\n  switch (t)\n    {\n    case QMARK:\n    case STAR:\n    case PLUS:\n      break;\n\n    case CAT:\n    case OR:\n    case ORTOP:\n      --depth;\n      break;\n\n    default:\n      ++dfa->nleaves;\n    case EMPTY:\n      ++depth;\n      break;\n    }\n  if (depth > dfa->depth)\n    dfa->depth = depth;\n}\n\n/* The grammar understood by the parser is as follows.\n\n   regexp:\n     regexp OR branch\n     branch\n\n   branch:\n     branch closure\n     closure\n\n   closure:\n     closure QMARK\n     closure STAR\n     closure PLUS\n     atom\n\n   atom:\n     <normal character>\n     CSET\n     BACKREF\n     BEGLINE\n     ENDLINE\n     BEGWORD\n     ENDWORD\n     LIMWORD\n     NOTLIMWORD\n     <empty>\n\n   The parser builds a parse tree in postfix form in an array of tokens. */\n\n#if __STDC__\nstatic void regexp(int);\n#else\nstatic void regexp();\n#endif\n\nstatic void\natom()\n{\n  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF\n      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD\n      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)\n    {\n      addtok(tok);\n      tok = lex();\n    }\n  else if (tok == LPAREN)\n    {\n      tok = lex();\n      regexp(0);\n      if (tok != RPAREN)\n\tdfaerror(\"Unbalanced (\");\n      tok = lex();\n    }\n  else\n    addtok(EMPTY);\n}\n\n/* Return the number of tokens in the given subexpression. */\nstatic int\nnsubtoks(tindex)\n{\n  int ntoks1;\n\n  switch (dfa->tokens[tindex - 1])\n    {\n    default:\n      return 1;\n    case QMARK:\n    case STAR:\n    case PLUS:\n      return 1 + nsubtoks(tindex - 1);\n    case CAT:\n    case OR:\n    case ORTOP:\n      ntoks1 = nsubtoks(tindex - 1);\n      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);\n    }\n}\n\n/* Copy the given subexpression to the top of the tree. */\nstatic void\ncopytoks(tindex, ntokens)\n     int tindex, ntokens;\n{\n  int i;\n\n  for (i = 0; i < ntokens; ++i)\n    addtok(dfa->tokens[tindex + i]);\n}\n\nstatic void\nclosure()\n{\n  int tindex, ntokens, i;\n\n  atom();\n  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)\n    if (tok == REPMN)\n      {\n\tntokens = nsubtoks(dfa->tindex);\n\ttindex = dfa->tindex - ntokens;\n\tif (maxrep == 0)\n\t  addtok(PLUS);\n\tif (minrep == 0)\n\t  addtok(QMARK);\n\tfor (i = 1; i < minrep; ++i)\n\t  {\n\t    copytoks(tindex, ntokens);\n\t    addtok(CAT);\n\t  }\n\tfor (; i < maxrep; ++i)\n\t  {\n\t    copytoks(tindex, ntokens);\n\t    addtok(QMARK);\n\t    addtok(CAT);\n\t  }\n\ttok = lex();\n      }\n    else\n      {\n\taddtok(tok);\n\ttok = lex();\n      }\n}\n\nstatic void\nbranch()\n{\n  closure();\n  while (tok != RPAREN && tok != OR && tok >= 0)\n    {\n      closure();\n      addtok(CAT);\n    }\n}\n\nstatic void\nregexp(toplevel)\n     int toplevel;\n{\n  branch();\n  while (tok == OR)\n    {\n      tok = lex();\n      branch();\n      if (toplevel)\n\taddtok(ORTOP);\n      else\n\taddtok(OR);\n    }\n}\n\n/* Main entry point for the parser.  S is a string to be parsed, len is the\n   length of the string, so s can include NUL characters.  D is a pointer to\n   the struct dfa to parse into. */\nvoid\ndfaparse(s, len, d)\n     char *s;\n     size_t len;\n     struct dfa *d;\n\n{\n  dfa = d;\n  lexstart = lexptr = s;\n  lexleft = len;\n  lasttok = END;\n  laststart = 1;\n  parens = 0;\n\n  if (! syntax_bits_set)\n    dfaerror(\"No syntax specified\");\n\n  tok = lex();\n  depth = d->depth;\n\n  regexp(1);\n\n  if (tok != END)\n    dfaerror(\"Unbalanced )\");\n\n  addtok(END - d->nregexps);\n  addtok(CAT);\n\n  if (d->nregexps)\n    addtok(ORTOP);\n\n  ++d->nregexps;\n}\n\n/* Some primitives for operating on sets of positions. */\n\n/* Copy one set to another; the destination must be large enough. */\nstatic void\ncopy(src, dst)\n     position_set *src;\n     position_set *dst;\n{\n  int i;\n\n  for (i = 0; i < src->nelem; ++i)\n    dst->elems[i] = src->elems[i];\n  dst->nelem = src->nelem;\n}\n\n/* Insert a position in a set.  Position sets are maintained in sorted\n   order according to index.  If position already exists in the set with\n   the same index then their constraints are logically or'd together.\n   S->elems must point to an array large enough to hold the resulting set. */\nstatic void\ninsert(p, s)\n     position p;\n     position_set *s;\n{\n  int i;\n  position t1, t2;\n\n  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)\n    ;\n  if (i < s->nelem && p.index == s->elems[i].index)\n    s->elems[i].constraint |= p.constraint;\n  else\n    {\n      t1 = p;\n      ++s->nelem;\n      while (i < s->nelem)\n\t{\n\t  t2 = s->elems[i];\n\t  s->elems[i++] = t1;\n\t  t1 = t2;\n\t}\n    }\n}\n\n/* Merge two sets of positions into a third.  The result is exactly as if\n   the positions of both sets were inserted into an initially empty set. */\nstatic void\nmerge(s1, s2, m)\n     position_set *s1;\n     position_set *s2;\n     position_set *m;\n{\n  int i = 0, j = 0;\n\n  m->nelem = 0;\n  while (i < s1->nelem && j < s2->nelem)\n    if (s1->elems[i].index > s2->elems[j].index)\n      m->elems[m->nelem++] = s1->elems[i++];\n    else if (s1->elems[i].index < s2->elems[j].index)\n      m->elems[m->nelem++] = s2->elems[j++];\n    else\n      {\n\tm->elems[m->nelem] = s1->elems[i++];\n\tm->elems[m->nelem++].constraint |= s2->elems[j++].constraint;\n      }\n  while (i < s1->nelem)\n    m->elems[m->nelem++] = s1->elems[i++];\n  while (j < s2->nelem)\n    m->elems[m->nelem++] = s2->elems[j++];\n}\n\n/* Delete a position from a set. */\nstatic void\ndelete(p, s)\n     position p;\n     position_set *s;\n{\n  int i;\n\n  for (i = 0; i < s->nelem; ++i)\n    if (p.index == s->elems[i].index)\n      break;\n  if (i < s->nelem)\n    for (--s->nelem; i < s->nelem; ++i)\n      s->elems[i] = s->elems[i + 1];\n}\n\n/* Find the index of the state corresponding to the given position set with\n   the given preceding context, or create a new state if there is no such\n   state.  Newline and letter tell whether we got here on a newline or\n   letter, respectively. */\nstatic int\nstate_index(d, s, newline, letter)\n     struct dfa *d;\n     position_set *s;\n     int newline;\n     int letter;\n{\n  int hash = 0;\n  int constraint;\n  int i, j;\n\n  newline = newline ? 1 : 0;\n  letter = letter ? 1 : 0;\n\n  for (i = 0; i < s->nelem; ++i)\n    hash ^= s->elems[i].index + s->elems[i].constraint;\n\n  /* Try to find a state that exactly matches the proposed one. */\n  for (i = 0; i < d->sindex; ++i)\n    {\n      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem\n\t  || newline != d->states[i].newline || letter != d->states[i].letter)\n\tcontinue;\n      for (j = 0; j < s->nelem; ++j)\n\tif (s->elems[j].constraint\n\t    != d->states[i].elems.elems[j].constraint\n\t    || s->elems[j].index != d->states[i].elems.elems[j].index)\n\t  break;\n      if (j == s->nelem)\n\treturn i;\n    }\n\n  /* We'll have to create a new state. */\n  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);\n  d->states[i].hash = hash;\n  MALLOC(d->states[i].elems.elems, position, s->nelem);\n  copy(s, &d->states[i].elems);\n  d->states[i].newline = newline;\n  d->states[i].letter = letter;\n  d->states[i].backref = 0;\n  d->states[i].constraint = 0;\n  d->states[i].first_end = 0;\n  for (j = 0; j < s->nelem; ++j)\n    if (d->tokens[s->elems[j].index] < 0)\n      {\n\tconstraint = s->elems[j].constraint;\n\tif (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)\n\t    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)\n\t    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)\n\t    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))\n\t  d->states[i].constraint |= constraint;\n\tif (! d->states[i].first_end)\n\t  d->states[i].first_end = d->tokens[s->elems[j].index];\n      }\n    else if (d->tokens[s->elems[j].index] == BACKREF)\n      {\n\td->states[i].constraint = NO_CONSTRAINT;\n\td->states[i].backref = 1;\n      }\n\n  ++d->sindex;\n\n  return i;\n}\n\n/* Find the epsilon closure of a set of positions.  If any position of the set\n   contains a symbol that matches the empty string in some context, replace\n   that position with the elements of its follow labeled with an appropriate\n   constraint.  Repeat exhaustively until no funny positions are left.\n   S->elems must be large enough to hold the result. */\nvoid\nepsclosure(s, d)\n     position_set *s;\n     struct dfa *d;\n{\n  int i, j;\n  int *visited;\n  position p, old;\n\n  MALLOC(visited, int, d->tindex);\n  for (i = 0; i < d->tindex; ++i)\n    visited[i] = 0;\n\n  for (i = 0; i < s->nelem; ++i)\n    if (d->tokens[s->elems[i].index] >= NOTCHAR\n\t&& d->tokens[s->elems[i].index] != BACKREF\n\t&& d->tokens[s->elems[i].index] < CSET)\n      {\n\told = s->elems[i];\n\tp.constraint = old.constraint;\n\tdelete(s->elems[i], s);\n\tif (visited[old.index])\n\t  {\n\t    --i;\n\t    continue;\n\t  }\n\tvisited[old.index] = 1;\n\tswitch (d->tokens[old.index])\n\t  {\n\t  case BEGLINE:\n\t    p.constraint &= BEGLINE_CONSTRAINT;\n\t    break;\n\t  case ENDLINE:\n\t    p.constraint &= ENDLINE_CONSTRAINT;\n\t    break;\n\t  case BEGWORD:\n\t    p.constraint &= BEGWORD_CONSTRAINT;\n\t    break;\n\t  case ENDWORD:\n\t    p.constraint &= ENDWORD_CONSTRAINT;\n\t    break;\n\t  case LIMWORD:\n\t    p.constraint &= LIMWORD_CONSTRAINT;\n\t    break;\n\t  case NOTLIMWORD:\n\t    p.constraint &= NOTLIMWORD_CONSTRAINT;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\tfor (j = 0; j < d->follows[old.index].nelem; ++j)\n\t  {\n\t    p.index = d->follows[old.index].elems[j].index;\n\t    insert(p, s);\n\t  }\n\t/* Force rescan to start at the beginning. */\n\ti = -1;\n      }\n\n  free(visited);\n}\n\n/* Perform bottom-up analysis on the parse tree, computing various functions.\n   Note that at this point, we're pretending constructs like \\< are real\n   characters rather than constraints on what can follow them.\n\n   Nullable:  A node is nullable if it is at the root of a regexp that can\n   match the empty string.\n   *  EMPTY leaves are nullable.\n   * No other leaf is nullable.\n   * A QMARK or STAR node is nullable.\n   * A PLUS node is nullable if its argument is nullable.\n   * A CAT node is nullable if both its arguments are nullable.\n   * An OR node is nullable if either argument is nullable.\n\n   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)\n   that could correspond to the first character of a string matching the\n   regexp rooted at the given node.\n   * EMPTY leaves have empty firstpos.\n   * The firstpos of a nonempty leaf is that leaf itself.\n   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its\n     argument.\n   * The firstpos of a CAT node is the firstpos of the left argument, union\n     the firstpos of the right if the left argument is nullable.\n   * The firstpos of an OR node is the union of firstpos of each argument.\n\n   Lastpos:  The lastpos of a node is the set of positions that could\n   correspond to the last character of a string matching the regexp at\n   the given node.\n   * EMPTY leaves have empty lastpos.\n   * The lastpos of a nonempty leaf is that leaf itself.\n   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its\n     argument.\n   * The lastpos of a CAT node is the lastpos of its right argument, union\n     the lastpos of the left if the right argument is nullable.\n   * The lastpos of an OR node is the union of the lastpos of each argument.\n\n   Follow:  The follow of a position is the set of positions that could\n   correspond to the character following a character matching the node in\n   a string matching the regexp.  At this point we consider special symbols\n   that match the empty string in some context to be just normal characters.\n   Later, if we find that a special symbol is in a follow set, we will\n   replace it with the elements of its follow, labeled with an appropriate\n   constraint.\n   * Every node in the firstpos of the argument of a STAR or PLUS node is in\n     the follow of every node in the lastpos.\n   * Every node in the firstpos of the second argument of a CAT node is in\n     the follow of every node in the lastpos of the first argument.\n\n   Because of the postfix representation of the parse tree, the depth-first\n   analysis is conveniently done by a linear scan with the aid of a stack.\n   Sets are stored as arrays of the elements, obeying a stack-like allocation\n   scheme; the number of elements in each set deeper in the stack can be\n   used to determine the address of a particular set's array. */\nvoid\ndfaanalyze(d, searchflag)\n     struct dfa *d;\n     int searchflag;\n{\n  int *nullable;\t\t/* Nullable stack. */\n  int *nfirstpos;\t\t/* Element count stack for firstpos sets. */\n  position *firstpos;\t\t/* Array where firstpos elements are stored. */\n  int *nlastpos;\t\t/* Element count stack for lastpos sets. */\n  position *lastpos;\t\t/* Array where lastpos elements are stored. */\n  int *nalloc;\t\t\t/* Sizes of arrays allocated to follow sets. */\n  position_set tmp;\t\t/* Temporary set for merging sets. */\n  position_set merged;\t\t/* Result of merging sets. */\n  int wants_newline;\t\t/* True if some position wants newline info. */\n  int *o_nullable;\n  int *o_nfirst, *o_nlast;\n  position *o_firstpos, *o_lastpos;\n  int i, j;\n  position *pos;\n\n#ifdef DEBUG\n  fprintf(stderr, \"dfaanalyze:\\n\");\n  for (i = 0; i < d->tindex; ++i)\n    {\n      fprintf(stderr, \" %d:\", i);\n      prtok(d->tokens[i]);\n    }\n  putc('\\n', stderr);\n#endif\n\n  d->searchflag = searchflag;\n\n  MALLOC(nullable, int, d->depth);\n  o_nullable = nullable;\n  MALLOC(nfirstpos, int, d->depth);\n  o_nfirst = nfirstpos;\n  MALLOC(firstpos, position, d->nleaves);\n  o_firstpos = firstpos, firstpos += d->nleaves;\n  MALLOC(nlastpos, int, d->depth);\n  o_nlast = nlastpos;\n  MALLOC(lastpos, position, d->nleaves);\n  o_lastpos = lastpos, lastpos += d->nleaves;\n  MALLOC(nalloc, int, d->tindex);\n  for (i = 0; i < d->tindex; ++i)\n    nalloc[i] = 0;\n  MALLOC(merged.elems, position, d->nleaves);\n\n  CALLOC(d->follows, position_set, d->tindex);\n\n  for (i = 0; i < d->tindex; ++i)\n#ifdef DEBUG\n    {\t\t\t\t/* Nonsyntactic #ifdef goo... */\n#endif\n    switch (d->tokens[i])\n      {\n      case EMPTY:\n\t/* The empty set is nullable. */\n\t*nullable++ = 1;\n\n\t/* The firstpos and lastpos of the empty leaf are both empty. */\n\t*nfirstpos++ = *nlastpos++ = 0;\n\tbreak;\n\n      case STAR:\n      case PLUS:\n\t/* Every element in the firstpos of the argument is in the follow\n\t   of every element in the lastpos. */\n\ttmp.nelem = nfirstpos[-1];\n\ttmp.elems = firstpos;\n\tpos = lastpos;\n\tfor (j = 0; j < nlastpos[-1]; ++j)\n\t  {\n\t    merge(&tmp, &d->follows[pos[j].index], &merged);\n\t    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,\n\t\t\t\t nalloc[pos[j].index], merged.nelem - 1);\n\t    copy(&merged, &d->follows[pos[j].index]);\n\t  }\n\n      case QMARK:\n\t/* A QMARK or STAR node is automatically nullable. */\n\tif (d->tokens[i] != PLUS)\n\t  nullable[-1] = 1;\n\tbreak;\n\n      case CAT:\n\t/* Every element in the firstpos of the second argument is in the\n\t   follow of every element in the lastpos of the first argument. */\n\ttmp.nelem = nfirstpos[-1];\n\ttmp.elems = firstpos;\n\tpos = lastpos + nlastpos[-1];\n\tfor (j = 0; j < nlastpos[-2]; ++j)\n\t  {\n\t    merge(&tmp, &d->follows[pos[j].index], &merged);\n\t    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,\n\t\t\t\t nalloc[pos[j].index], merged.nelem - 1);\n\t    copy(&merged, &d->follows[pos[j].index]);\n\t  }\n\n\t/* The firstpos of a CAT node is the firstpos of the first argument,\n\t   union that of the second argument if the first is nullable. */\n\tif (nullable[-2])\n\t  nfirstpos[-2] += nfirstpos[-1];\n\telse\n\t  firstpos += nfirstpos[-1];\n\t--nfirstpos;\n\n\t/* The lastpos of a CAT node is the lastpos of the second argument,\n\t   union that of the first argument if the second is nullable. */\n\tif (nullable[-1])\n\t  nlastpos[-2] += nlastpos[-1];\n\telse\n\t  {\n\t    pos = lastpos + nlastpos[-2];\n\t    for (j = nlastpos[-1] - 1; j >= 0; --j)\n\t      pos[j] = lastpos[j];\n\t    lastpos += nlastpos[-2];\n\t    nlastpos[-2] = nlastpos[-1];\n\t  }\n\t--nlastpos;\n\n\t/* A CAT node is nullable if both arguments are nullable. */\n\tnullable[-2] = nullable[-1] && nullable[-2];\n\t--nullable;\n\tbreak;\n\n      case OR:\n      case ORTOP:\n\t/* The firstpos is the union of the firstpos of each argument. */\n\tnfirstpos[-2] += nfirstpos[-1];\n\t--nfirstpos;\n\n\t/* The lastpos is the union of the lastpos of each argument. */\n\tnlastpos[-2] += nlastpos[-1];\n\t--nlastpos;\n\n\t/* An OR node is nullable if either argument is nullable. */\n\tnullable[-2] = nullable[-1] || nullable[-2];\n\t--nullable;\n\tbreak;\n\n      default:\n\t/* Anything else is a nonempty position.  (Note that special\n\t   constructs like \\< are treated as nonempty strings here;\n\t   an \"epsilon closure\" effectively makes them nullable later.\n\t   Backreferences have to get a real position so we can detect\n\t   transitions on them later.  But they are nullable. */\n\t*nullable++ = d->tokens[i] == BACKREF;\n\n\t/* This position is in its own firstpos and lastpos. */\n\t*nfirstpos++ = *nlastpos++ = 1;\n\t--firstpos, --lastpos;\n\tfirstpos->index = lastpos->index = i;\n\tfirstpos->constraint = lastpos->constraint = NO_CONSTRAINT;\n\n\t/* Allocate the follow set for this position. */\n\tnalloc[i] = 1;\n\tMALLOC(d->follows[i].elems, position, nalloc[i]);\n\tbreak;\n      }\n#ifdef DEBUG\n    /* ... balance the above nonsyntactic #ifdef goo... */\n      fprintf(stderr, \"node %d:\", i);\n      prtok(d->tokens[i]);\n      putc('\\n', stderr);\n      fprintf(stderr, nullable[-1] ? \" nullable: yes\\n\" : \" nullable: no\\n\");\n      fprintf(stderr, \" firstpos:\");\n      for (j = nfirstpos[-1] - 1; j >= 0; --j)\n\t{\n\t  fprintf(stderr, \" %d:\", firstpos[j].index);\n\t  prtok(d->tokens[firstpos[j].index]);\n\t}\n      fprintf(stderr, \"\\n lastpos:\");\n      for (j = nlastpos[-1] - 1; j >= 0; --j)\n\t{\n\t  fprintf(stderr, \" %d:\", lastpos[j].index);\n\t  prtok(d->tokens[lastpos[j].index]);\n\t}\n      putc('\\n', stderr);\n    }\n#endif\n\n  /* For each follow set that is the follow set of a real position, replace\n     it with its epsilon closure. */\n  for (i = 0; i < d->tindex; ++i)\n    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF\n\t|| d->tokens[i] >= CSET)\n      {\n#ifdef DEBUG\n\tfprintf(stderr, \"follows(%d:\", i);\n\tprtok(d->tokens[i]);\n\tfprintf(stderr, \"):\");\n\tfor (j = d->follows[i].nelem - 1; j >= 0; --j)\n\t  {\n\t    fprintf(stderr, \" %d:\", d->follows[i].elems[j].index);\n\t    prtok(d->tokens[d->follows[i].elems[j].index]);\n\t  }\n\tputc('\\n', stderr);\n#endif\n\tcopy(&d->follows[i], &merged);\n\tepsclosure(&merged, d);\n\tif (d->follows[i].nelem < merged.nelem)\n\t  REALLOC(d->follows[i].elems, position, merged.nelem);\n\tcopy(&merged, &d->follows[i]);\n      }\n\n  /* Get the epsilon closure of the firstpos of the regexp.  The result will\n     be the set of positions of state 0. */\n  merged.nelem = 0;\n  for (i = 0; i < nfirstpos[-1]; ++i)\n    insert(firstpos[i], &merged);\n  epsclosure(&merged, d);\n\n  /* Check if any of the positions of state 0 will want newline context. */\n  wants_newline = 0;\n  for (i = 0; i < merged.nelem; ++i)\n    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))\n      wants_newline = 1;\n\n  /* Build the initial state. */\n  d->salloc = 1;\n  d->sindex = 0;\n  MALLOC(d->states, dfa_state, d->salloc);\n  state_index(d, &merged, wants_newline, 0);\n\n  free(o_nullable);\n  free(o_nfirst);\n  free(o_firstpos);\n  free(o_nlast);\n  free(o_lastpos);\n  free(nalloc);\n  free(merged.elems);\n}\n\n/* Find, for each character, the transition out of state s of d, and store\n   it in the appropriate slot of trans.\n\n   We divide the positions of s into groups (positions can appear in more\n   than one group).  Each group is labeled with a set of characters that\n   every position in the group matches (taking into account, if necessary,\n   preceding context information of s).  For each group, find the union\n   of the its elements' follows.  This set is the set of positions of the\n   new state.  For each character in the group's label, set the transition\n   on this character to be to a state corresponding to the set's positions,\n   and its associated backward context information, if necessary.\n\n   If we are building a searching matcher, we include the positions of state\n   0 in every state.\n\n   The collection of groups is constructed by building an equivalence-class\n   partition of the positions of s.\n\n   For each position, find the set of characters C that it matches.  Eliminate\n   any characters from C that fail on grounds of backward context.\n\n   Search through the groups, looking for a group whose label L has nonempty\n   intersection with C.  If L - C is nonempty, create a new group labeled\n   L - C and having the same positions as the current group, and set L to\n   the intersection of L and C.  Insert the position in this group, set\n   C = C - L, and resume scanning.\n\n   If after comparing with every group there are characters remaining in C,\n   create a new group labeled with the characters of C and insert this\n   position in that group. */\nvoid\ndfastate(s, d, trans)\n     int s;\n     struct dfa *d;\n     int trans[];\n{\n  position_set grps[NOTCHAR];\t/* As many as will ever be needed. */\n  charclass labels[NOTCHAR];\t/* Labels corresponding to the groups. */\n  int ngrps = 0;\t\t/* Number of groups actually used. */\n  position pos;\t\t\t/* Current position being considered. */\n  charclass matches;\t\t/* Set of matching characters. */\n  int matchesf;\t\t\t/* True if matches is nonempty. */\n  charclass intersect;\t\t/* Intersection with some label set. */\n  int intersectf;\t\t/* True if intersect is nonempty. */\n  charclass leftovers;\t\t/* Stuff in the label that didn't match. */\n  int leftoversf;\t\t/* True if leftovers is nonempty. */\n  static charclass letters;\t/* Set of characters considered letters. */\n  static charclass newline;\t/* Set of characters that aren't newline. */\n  position_set follows;\t\t/* Union of the follows of some group. */\n  position_set tmp;\t\t/* Temporary space for merging sets. */\n  int state;\t\t\t/* New state. */\n  int wants_newline;\t\t/* New state wants to know newline context. */\n  int state_newline;\t\t/* New state on a newline transition. */\n  int wants_letter;\t\t/* New state wants to know letter context. */\n  int state_letter;\t\t/* New state on a letter transition. */\n  static initialized;\t\t/* Flag for static initialization. */\n  int i, j, k;\n\n  /* Initialize the set of letters, if necessary. */\n  if (! initialized)\n    {\n      initialized = 1;\n      for (i = 0; i < NOTCHAR; ++i)\n\tif (ISALNUM(i))\n\t  setbit(i, letters);\n      setbit('\\n', newline);\n    }\n\n  zeroset(matches);\n\n  for (i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      pos = d->states[s].elems.elems[i];\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n\tsetbit(d->tokens[pos.index], matches);\n      else if (d->tokens[pos.index] >= CSET)\n\tcopyset(d->charclasses[d->tokens[pos.index] - CSET], matches);\n      else\n\tcontinue;\n\n      /* Some characters may need to be eliminated from matches because\n\t they fail in the current context. */\n      if (pos.constraint != 0xFF)\n\t{\n\t  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,\n\t\t\t\t\t d->states[s].newline, 1))\n\t    clrbit('\\n', matches);\n\t  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,\n\t\t\t\t\t d->states[s].newline, 0))\n\t    for (j = 0; j < CHARCLASS_INTS; ++j)\n\t      matches[j] &= newline[j];\n\t  if (! MATCHES_LETTER_CONTEXT(pos.constraint,\n\t\t\t\t\td->states[s].letter, 1))\n\t    for (j = 0; j < CHARCLASS_INTS; ++j)\n\t      matches[j] &= ~letters[j];\n\t  if (! MATCHES_LETTER_CONTEXT(pos.constraint,\n\t\t\t\t\td->states[s].letter, 0))\n\t    for (j = 0; j < CHARCLASS_INTS; ++j)\n\t      matches[j] &= letters[j];\n\n\t  /* If there are no characters left, there's no point in going on. */\n\t  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)\n\t    ;\n\t  if (j == CHARCLASS_INTS)\n\t    continue;\n\t}\n\n      for (j = 0; j < ngrps; ++j)\n\t{\n\t  /* If matches contains a single character only, and the current\n\t     group's label doesn't contain that character, go on to the\n\t     next group. */\n\t  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR\n\t      && !tstbit(d->tokens[pos.index], labels[j]))\n\t    continue;\n\n\t  /* Check if this group's label has a nonempty intersection with\n\t     matches. */\n\t  intersectf = 0;\n\t  for (k = 0; k < CHARCLASS_INTS; ++k)\n\t    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;\n\t  if (! intersectf)\n\t    continue;\n\n\t  /* It does; now find the set differences both ways. */\n\t  leftoversf = matchesf = 0;\n\t  for (k = 0; k < CHARCLASS_INTS; ++k)\n\t    {\n\t      /* Even an optimizing compiler can't know this for sure. */\n\t      int match = matches[k], label = labels[j][k];\n\n\t      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;\n\t      (matches[k] = match & ~label) ? matchesf = 1 : 0;\n\t    }\n\n\t  /* If there were leftovers, create a new group labeled with them. */\n\t  if (leftoversf)\n\t    {\n\t      copyset(leftovers, labels[ngrps]);\n\t      copyset(intersect, labels[j]);\n\t      MALLOC(grps[ngrps].elems, position, d->nleaves);\n\t      copy(&grps[j], &grps[ngrps]);\n\t      ++ngrps;\n\t    }\n\n\t  /* Put the position in the current group.  Note that there is no\n\t     reason to call insert() here. */\n\t  grps[j].elems[grps[j].nelem++] = pos;\n\n\t  /* If every character matching the current position has been\n\t     accounted for, we're done. */\n\t  if (! matchesf)\n\t    break;\n\t}\n\n      /* If we've passed the last group, and there are still characters\n\t unaccounted for, then we'll have to create a new group. */\n      if (j == ngrps)\n\t{\n\t  copyset(matches, labels[ngrps]);\n\t  zeroset(matches);\n\t  MALLOC(grps[ngrps].elems, position, d->nleaves);\n\t  grps[ngrps].nelem = 1;\n\t  grps[ngrps].elems[0] = pos;\n\t  ++ngrps;\n\t}\n    }\n\n  MALLOC(follows.elems, position, d->nleaves);\n  MALLOC(tmp.elems, position, d->nleaves);\n\n  /* If we are a searching matcher, the default transition is to a state\n     containing the positions of state 0, otherwise the default transition\n     is to fail miserably. */\n  if (d->searchflag)\n    {\n      wants_newline = 0;\n      wants_letter = 0;\n      for (i = 0; i < d->states[0].elems.nelem; ++i)\n\t{\n\t  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))\n\t    wants_newline = 1;\n\t  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))\n\t    wants_letter = 1;\n\t}\n      copy(&d->states[0].elems, &follows);\n      state = state_index(d, &follows, 0, 0);\n      if (wants_newline)\n\tstate_newline = state_index(d, &follows, 1, 0);\n      else\n\tstate_newline = state;\n      if (wants_letter)\n\tstate_letter = state_index(d, &follows, 0, 1);\n      else\n\tstate_letter = state;\n      for (i = 0; i < NOTCHAR; ++i)\n\tif (i == '\\n')\n\t  trans[i] = state_newline;\n\telse if (ISALNUM(i))\n\t  trans[i] = state_letter;\n\telse\n\t  trans[i] = state;\n    }\n  else\n    for (i = 0; i < NOTCHAR; ++i)\n      trans[i] = -1;\n\n  for (i = 0; i < ngrps; ++i)\n    {\n      follows.nelem = 0;\n\n      /* Find the union of the follows of the positions of the group.\n\t This is a hideously inefficient loop.  Fix it someday. */\n      for (j = 0; j < grps[i].nelem; ++j)\n\tfor (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)\n\t  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);\n\n      /* If we are building a searching matcher, throw in the positions\n\t of state 0 as well. */\n      if (d->searchflag)\n\tfor (j = 0; j < d->states[0].elems.nelem; ++j)\n\t  insert(d->states[0].elems.elems[j], &follows);\n\n      /* Find out if the new state will want any context information. */\n      wants_newline = 0;\n      if (tstbit('\\n', labels[i]))\n\tfor (j = 0; j < follows.nelem; ++j)\n\t  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))\n\t    wants_newline = 1;\n\n      wants_letter = 0;\n      for (j = 0; j < CHARCLASS_INTS; ++j)\n\tif (labels[i][j] & letters[j])\n\t  break;\n      if (j < CHARCLASS_INTS)\n\tfor (j = 0; j < follows.nelem; ++j)\n\t  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))\n\t    wants_letter = 1;\n\n      /* Find the state(s) corresponding to the union of the follows. */\n      state = state_index(d, &follows, 0, 0);\n      if (wants_newline)\n\tstate_newline = state_index(d, &follows, 1, 0);\n      else\n\tstate_newline = state;\n      if (wants_letter)\n\tstate_letter = state_index(d, &follows, 0, 1);\n      else\n\tstate_letter = state;\n\n      /* Set the transitions for each character in the current label. */\n      for (j = 0; j < CHARCLASS_INTS; ++j)\n\tfor (k = 0; k < INTBITS; ++k)\n\t  if (labels[i][j] & 1 << k)\n\t    {\n\t      int c = j * INTBITS + k;\n\n\t      if (c == '\\n')\n\t\ttrans[c] = state_newline;\n\t      else if (ISALNUM(c))\n\t\ttrans[c] = state_letter;\n\t      else if (c < NOTCHAR)\n\t\ttrans[c] = state;\n\t    }\n    }\n\n  for (i = 0; i < ngrps; ++i)\n    free(grps[i].elems);\n  free(follows.elems);\n  free(tmp.elems);\n}\n\n/* Some routines for manipulating a compiled dfa's transition tables.\n   Each state may or may not have a transition table; if it does, and it\n   is a non-accepting state, then d->trans[state] points to its table.\n   If it is an accepting state then d->fails[state] points to its table.\n   If it has no table at all, then d->trans[state] is NULL.\n   TODO: Improve this comment, get rid of the unnecessary redundancy. */\n\nstatic void\nbuild_state(s, d)\n     int s;\n     struct dfa *d;\n{\n  int *trans;\t\t\t/* The new transition table. */\n  int i;\n\n  /* Set an upper limit on the number of transition tables that will ever\n     exist at once.  1024 is arbitrary.  The idea is that the frequently\n     used transition tables will be quickly rebuilt, whereas the ones that\n     were only needed once or twice will be cleared away. */\n  if (d->trcount >= 1024)\n    {\n      for (i = 0; i < d->tralloc; ++i)\n\tif (d->trans[i])\n\t  {\n\t    free((ptr_t) d->trans[i]);\n\t    d->trans[i] = NULL;\n\t  }\n\telse if (d->fails[i])\n\t  {\n\t    free((ptr_t) d->fails[i]);\n\t    d->fails[i] = NULL;\n\t  }\n      d->trcount = 0;\n    }\n\n  ++d->trcount;\n\n  /* Set up the success bits for this state. */\n  d->success[s] = 0;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,\n      s, *d))\n    d->success[s] |= 4;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,\n      s, *d))\n    d->success[s] |= 2;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,\n      s, *d))\n    d->success[s] |= 1;\n\n  MALLOC(trans, int, NOTCHAR);\n  dfastate(s, d, trans);\n\n  /* Now go through the new transition table, and make sure that the trans\n     and fail arrays are allocated large enough to hold a pointer for the\n     largest state mentioned in the table. */\n  for (i = 0; i < NOTCHAR; ++i)\n    if (trans[i] >= d->tralloc)\n      {\n\tint oldalloc = d->tralloc;\n\n\twhile (trans[i] >= d->tralloc)\n\t  d->tralloc *= 2;\n\tREALLOC(d->realtrans, int *, d->tralloc + 1);\n\td->trans = d->realtrans + 1;\n\tREALLOC(d->fails, int *, d->tralloc);\n\tREALLOC(d->success, int, d->tralloc);\n\tREALLOC(d->newlines, int, d->tralloc);\n\twhile (oldalloc < d->tralloc)\n\t  {\n\t    d->trans[oldalloc] = NULL;\n\t    d->fails[oldalloc++] = NULL;\n\t  }\n      }\n\n  /* Keep the newline transition in a special place so we can use it as\n     a sentinel. */\n  d->newlines[s] = trans['\\n'];\n  trans['\\n'] = -1;\n\n  if (ACCEPTING(s, *d))\n    d->fails[s] = trans;\n  else\n    d->trans[s] = trans;\n}\n\nstatic void\nbuild_state_zero(d)\n     struct dfa *d;\n{\n  d->tralloc = 1;\n  d->trcount = 0;\n  CALLOC(d->realtrans, int *, d->tralloc + 1);\n  d->trans = d->realtrans + 1;\n  CALLOC(d->fails, int *, d->tralloc);\n  MALLOC(d->success, int, d->tralloc);\n  MALLOC(d->newlines, int, d->tralloc);\n  build_state(0, d);\n}\n\n/* Search through a buffer looking for a match to the given struct dfa.\n   Find the first occurrence of a string matching the regexp in the buffer,\n   and the shortest possible version thereof.  Return a pointer to the first\n   character after the match, or NULL if none is found.  Begin points to\n   the beginning of the buffer, and end points to the first character after\n   its end.  We store a newline in *end to act as a sentinel, so end had\n   better point somewhere valid.  Newline is a flag indicating whether to\n   allow newlines to be in the matching string.  If count is non-\n   NULL it points to a place we're supposed to increment every time we\n   see a newline.  Finally, if backref is non-NULL it points to a place\n   where we're supposed to store a 1 if backreferencing happened and the\n   match needs to be verified by a backtracking matcher.  Otherwise\n   we store a 0 in *backref. */\nchar *\ndfaexec(d, begin, end, newline, count, backref)\n     struct dfa *d;\n     char *begin;\n     char *end;\n     int newline;\n     int *count;\n     int *backref;\n{\n  register s, s1, tmp;\t\t/* Current state. */\n  register unsigned char *p;\t/* Current input character. */\n  register **trans, *t;\t\t/* Copy of d->trans so it can be optimized\n\t\t\t\t   into a register. */\n  static sbit[NOTCHAR];\t/* Table for anding with d->success. */\n  static sbit_init;\n\n  if (! sbit_init)\n    {\n      int i;\n\n      sbit_init = 1;\n      for (i = 0; i < NOTCHAR; ++i)\n\tif (i == '\\n')\n\t  sbit[i] = 4;\n\telse if (ISALNUM(i))\n\t  sbit[i] = 2;\n\telse\n\t  sbit[i] = 1;\n    }\n\n  if (! d->tralloc)\n    build_state_zero(d);\n\n  s = s1 = 0;\n  p = (unsigned char *) begin;\n  trans = d->trans;\n  *end = '\\n';\n\n  for (;;)\n    {\n      /* The dreaded inner loop. */\n      if ((t = trans[s]) != 0)\n\tdo\n\t  {\n\t    s1 = t[*p++];\n\t    if (! (t = trans[s1]))\n\t      goto last_was_s;\n\t    s = t[*p++];\n\t  }\n        while ((t = trans[s]) != 0);\n      goto last_was_s1;\n    last_was_s:\n      tmp = s, s = s1, s1 = tmp;\n    last_was_s1:\n\n      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])\n\t{\n\t  if (d->success[s] & sbit[*p])\n\t    {\n\t      if (backref)\n\t\tif (d->states[s].backref)\n\t\t  *backref = 1;\n\t\telse\n\t\t  *backref = 0;\n\t      return (char *) p;\n\t    }\n\n\t  s1 = s;\n\t  s = d->fails[s][*p++];\n\t  continue;\n\t}\n\n      /* If the previous character was a newline, count it. */\n      if (count && (char *) p <= end && p[-1] == '\\n')\n\t++*count;\n\n      /* Check if we've run off the end of the buffer. */\n      if ((char *) p > end)\n\treturn NULL;\n\n      if (s >= 0)\n\t{\n\t  build_state(s, d);\n\t  trans = d->trans;\n\t  continue;\n\t}\n\n      if (p[-1] == '\\n' && newline)\n\t{\n\t  s = d->newlines[s1];\n\t  continue;\n\t}\n\n      s = 0;\n    }\n}\n\n/* Initialize the components of a dfa that the other routines don't\n   initialize for themselves. */\nvoid\ndfainit(d)\n     struct dfa *d;\n{\n  d->calloc = 1;\n  MALLOC(d->charclasses, charclass, d->calloc);\n  d->cindex = 0;\n\n  d->talloc = 1;\n  MALLOC(d->tokens, token, d->talloc);\n  d->tindex = d->depth = d->nleaves = d->nregexps = 0;\n\n  d->searchflag = 0;\n  d->tralloc = 0;\n\n  d->musts = 0;\n}\n\n/* Parse and analyze a single string of the given length. */\nvoid\ndfacomp(s, len, d, searchflag)\n     char *s;\n     size_t len;\n     struct dfa *d;\n     int searchflag;\n{\n  if (case_fold)\t/* dummy folding in service of dfamust() */\n    {\n      char *copy;\n      int i;\n\n      copy = malloc(len);\n      if (!copy)\n\tdfaerror(\"out of memory\");\n      \n      /* This is a kludge. */\n      case_fold = 0;\n      for (i = 0; i < len; ++i)\n\tif (ISUPPER(s[i]))\n\t  copy[i] = tolower(s[i]);\n\telse\n\t  copy[i] = s[i];\n\n      dfainit(d);\n      dfaparse(copy, len, d);\n      free(copy);\n      dfamust(d);\n      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;\n      case_fold = 1;\n      dfaparse(s, len, d);\n      dfaanalyze(d, searchflag);\n    }\n  else\n    {\n        dfainit(d);\n        dfaparse(s, len, d);\n\tdfamust(d);\n        dfaanalyze(d, searchflag);\n    }\n}\n\n/* Free the storage held by the components of a dfa. */\nvoid\ndfafree(d)\n     struct dfa *d;\n{\n  int i;\n  struct dfamust *dm, *ndm;\n\n  free((ptr_t) d->charclasses);\n  free((ptr_t) d->tokens);\n  for (i = 0; i < d->sindex; ++i)\n    free((ptr_t) d->states[i].elems.elems);\n  free((ptr_t) d->states);\n  for (i = 0; i < d->tindex; ++i)\n    if (d->follows[i].elems)\n      free((ptr_t) d->follows[i].elems);\n  free((ptr_t) d->follows);\n  for (i = 0; i < d->tralloc; ++i)\n    if (d->trans[i])\n      free((ptr_t) d->trans[i]);\n    else if (d->fails[i])\n      free((ptr_t) d->fails[i]);\n  free((ptr_t) d->realtrans);\n  free((ptr_t) d->fails);\n  free((ptr_t) d->newlines);\n  for (dm = d->musts; dm; dm = ndm)\n    {\n      ndm = dm->next;\n      free(dm->must);\n      free((ptr_t) dm);\n    }\n}\n\n/* Having found the postfix representation of the regular expression,\n   try to find a long sequence of characters that must appear in any line\n   containing the r.e.\n   Finding a \"longest\" sequence is beyond the scope here;\n   we take an easy way out and hope for the best.\n   (Take \"(ab|a)b\"--please.)\n\n   We do a bottom-up calculation of sequences of characters that must appear\n   in matches of r.e.'s represented by trees rooted at the nodes of the postfix\n   representation:\n\tsequences that must appear at the left of the match (\"left\")\n\tsequences that must appear at the right of the match (\"right\")\n\tlists of sequences that must appear somewhere in the match (\"in\")\n\tsequences that must constitute the match (\"is\")\n\n   When we get to the root of the tree, we use one of the longest of its\n   calculated \"in\" sequences as our answer.  The sequence we find is returned in\n   d->must (where \"d\" is the single argument passed to \"dfamust\");\n   the length of the sequence is returned in d->mustn.\n\n   The sequences calculated for the various types of node (in pseudo ANSI c)\n   are shown below.  \"p\" is the operand of unary operators (and the left-hand\n   operand of binary operators); \"q\" is the right-hand operand of binary\n   operators.\n\n   \"ZERO\" means \"a zero-length sequence\" below.\n\n\tType\tleft\t\tright\t\tis\t\tin\n\t----\t----\t\t-----\t\t--\t\t--\n\tchar c\t# c\t\t# c\t\t# c\t\t# c\n\t\n\tCSET\tZERO\t\tZERO\t\tZERO\t\tZERO\n\t\n\tSTAR\tZERO\t\tZERO\t\tZERO\t\tZERO\n\n\tQMARK\tZERO\t\tZERO\t\tZERO\t\tZERO\n\n\tPLUS\tp->left\t\tp->right\tZERO\t\tp->in\n\n\tCAT\t(p->is==ZERO)?\t(q->is==ZERO)?\t(p->is!=ZERO &&\tp->in plus\n\t\tp->left :\tq->right :\tq->is!=ZERO) ?\tq->in plus\n\t\tp->is##q->left\tp->right##q->is\tp->is##q->is :\tp->right##q->left\n\t\t\t\t\t\tZERO\n\t\t\t\t\t\n\tOR\tlongest common\tlongest common\t(do p->is and\tsubstrings common to\n\t\tleading\t\ttrailing\tq->is have same\tp->in and q->in\n\t\t(sub)sequence\t(sub)sequence\tlength and\t\n\t\tof p->left\tof p->right\tcontent) ?\t\n\t\tand q->left\tand q->right\tp->is : NULL\t\n\n   If there's anything else we recognize in the tree, all four sequences get set\n   to zero-length sequences.  If there's something we don't recognize in the tree,\n   we just return a zero-length sequence.\n\n   Break ties in favor of infrequent letters (choosing 'zzz' in preference to\n   'aaa')?\n\n   And. . .is it here or someplace that we might ponder \"optimizations\" such as\n\tegrep 'psi|epsilon'\t->\tegrep 'psi'\n\tegrep 'pepsi|epsilon'\t->\tegrep 'epsi'\n\t\t\t\t\t(Yes, we now find \"epsi\" as a \"string\n\t\t\t\t\tthat must occur\", but we might also\n\t\t\t\t\tsimplify the *entire* r.e. being sought)\n\tgrep '[c]'\t\t->\tgrep 'c'\n\tgrep '(ab|a)b'\t\t->\tgrep 'ab'\n\tgrep 'ab*'\t\t->\tgrep 'a'\n\tgrep 'a*b'\t\t->\tgrep 'b'\n\n   There are several issues:\n\n   Is optimization easy (enough)?\n\n   Does optimization actually accomplish anything,\n   or is the automaton you get from \"psi|epsilon\" (for example)\n   the same as the one you get from \"psi\" (for example)?\n  \n   Are optimizable r.e.'s likely to be used in real-life situations\n   (something like 'ab*' is probably unlikely; something like is\n   'psi|epsilon' is likelier)? */\n\nstatic char *\nicatalloc(old, new)\n     char *old;\n     char *new;\n{\n  char *result;\n  int oldsize, newsize;\n\n  newsize = (new == NULL) ? 0 : strlen(new);\n  if (old == NULL)\n    oldsize = 0;\n  else if (newsize == 0)\n    return old;\n  else\toldsize = strlen(old);\n  if (old == NULL)\n    result = (char *) malloc(newsize + 1);\n  else\n    result = (char *) realloc((void *) old, oldsize + newsize + 1);\n  if (result != NULL && new != NULL)\n    (void) strcpy(result + oldsize, new);\n  return result;\n}\n\nstatic char *\nicpyalloc(string)\n     char *string;\n{\n  return icatalloc((char *) NULL, string);\n}\n\nstatic char *\nistrstr(lookin, lookfor)\n     char *lookin;\n     char *lookfor;\n{\n  char *cp;\n  int len;\n\n  len = strlen(lookfor);\n  for (cp = lookin; *cp != '\\0'; ++cp)\n    if (strncmp(cp, lookfor, len) == 0)\n      return cp;\n  return NULL;\n}\n\nstatic void\nifree(cp)\n     char *cp;\n{\n  if (cp != NULL)\n    free(cp);\n}\n\nstatic void\nfreelist(cpp)\n     char **cpp;\n{\n  int i;\n\n  if (cpp == NULL)\n    return;\n  for (i = 0; cpp[i] != NULL; ++i)\n    {\n      free(cpp[i]);\n      cpp[i] = NULL;\n    }\n}\n\nstatic char **\nenlist(cpp, new, len)\n     char **cpp;\n     char *new;\n     int len;\n{\n  int i, j;\n\n  if (cpp == NULL)\n    return NULL;\n  if ((new = icpyalloc(new)) == NULL)\n    {\n      freelist(cpp);\n      return NULL;\n    }\n  new[len] = '\\0';\n  /* Is there already something in the list that's new (or longer)? */\n  for (i = 0; cpp[i] != NULL; ++i)\n    if (istrstr(cpp[i], new) != NULL)\n      {\n\tfree(new);\n\treturn cpp;\n      }\n  /* Eliminate any obsoleted strings. */\n  j = 0;\n  while (cpp[j] != NULL)\n    if (istrstr(new, cpp[j]) == NULL)\n      ++j;\n    else\n      {\n\tfree(cpp[j]);\n\tif (--i == j)\n\t  break;\n\tcpp[j] = cpp[i];\n\tcpp[i] = NULL;\n      }\n  /* Add the new string. */\n  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);\n  if (cpp == NULL)\n    return NULL;\n  cpp[i] = new;\n  cpp[i + 1] = NULL;\n  return cpp;\n}\n\n/* Given pointers to two strings, return a pointer to an allocated\n   list of their distinct common substrings. Return NULL if something\n   seems wild. */\nstatic char **\ncomsubs(left, right)\n     char *left;\n     char *right;\n{\n  char **cpp;\n  char *lcp;\n  char *rcp;\n  int i, len;\n\n  if (left == NULL || right == NULL)\n    return NULL;\n  cpp = (char **) malloc(sizeof *cpp);\n  if (cpp == NULL)\n    return NULL;\n  cpp[0] = NULL;\n  for (lcp = left; *lcp != '\\0'; ++lcp)\n    {\n      len = 0;\n      rcp = index(right, *lcp);\n      while (rcp != NULL)\n\t{\n\t  for (i = 1; lcp[i] != '\\0' && lcp[i] == rcp[i]; ++i)\n\t    ;\n\t  if (i > len)\n\t    len = i;\n\t  rcp = index(rcp + 1, *lcp);\n\t}\n      if (len == 0)\n\tcontinue;\n      if ((cpp = enlist(cpp, lcp, len)) == NULL)\n\tbreak;\n    }\n  return cpp;\n}\n\nstatic char **\naddlists(old, new)\nchar **old;\nchar **new;\n{\n  int i;\n\n  if (old == NULL || new == NULL)\n    return NULL;\n  for (i = 0; new[i] != NULL; ++i)\n    {\n      old = enlist(old, new[i], strlen(new[i]));\n      if (old == NULL)\n\tbreak;\n    }\n  return old;\n}\n\n/* Given two lists of substrings, return a new list giving substrings\n   common to both. */\nstatic char **\ninboth(left, right)\n     char **left;\n     char **right;\n{\n  char **both;\n  char **temp;\n  int lnum, rnum;\n\n  if (left == NULL || right == NULL)\n    return NULL;\n  both = (char **) malloc(sizeof *both);\n  if (both == NULL)\n    return NULL;\n  both[0] = NULL;\n  for (lnum = 0; left[lnum] != NULL; ++lnum)\n    {\n      for (rnum = 0; right[rnum] != NULL; ++rnum)\n\t{\n\t  temp = comsubs(left[lnum], right[rnum]);\n\t  if (temp == NULL)\n\t    {\n\t      freelist(both);\n\t      return NULL;\n\t    }\n\t  both = addlists(both, temp);\n\t  freelist(temp);\n\t  if (both == NULL)\n\t    return NULL;\n\t}\n    }\n  return both;\n}\n\ntypedef struct\n{\n  char **in;\n  char *left;\n  char *right;\n  char *is;\n} must;\n\nstatic void\nresetmust(mp)\nmust *mp;\n{\n  mp->left[0] = mp->right[0] = mp->is[0] = '\\0';\n  freelist(mp->in);\n}\n\nstatic void\ndfamust(dfa)\nstruct dfa *dfa;\n{\n  must *musts;\n  must *mp;\n  char *result;\n  int ri;\n  int i;\n  int exact;\n  token t;\n  static must must0;\n  struct dfamust *dm;\n\n  result = \"\";\n  exact = 0;\n  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);\n  if (musts == NULL)\n    return;\n  mp = musts;\n  for (i = 0; i <= dfa->tindex; ++i)\n    mp[i] = must0;\n  for (i = 0; i <= dfa->tindex; ++i)\n    {\n      mp[i].in = (char **) malloc(sizeof *mp[i].in);\n      mp[i].left = malloc(2);\n      mp[i].right = malloc(2);\n      mp[i].is = malloc(2);\n      if (mp[i].in == NULL || mp[i].left == NULL ||\n\t  mp[i].right == NULL || mp[i].is == NULL)\n\tgoto done;\n      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\\0';\n      mp[i].in[0] = NULL;\n    }\n#ifdef DEBUG\n  fprintf(stderr, \"dfamust:\\n\");\n  for (i = 0; i < dfa->tindex; ++i)\n    {\n      fprintf(stderr, \" %d:\", i);\n      prtok(dfa->tokens[i]);\n    }\n  putc('\\n', stderr);\n#endif\n  for (ri = 0; ri < dfa->tindex; ++ri)\n    {\n      switch (t = dfa->tokens[ri])\n\t{\n\tcase LPAREN:\n\tcase RPAREN:\n\t  goto done;\t\t/* \"cannot happen\" */\n\tcase EMPTY:\n\tcase BEGLINE:\n\tcase ENDLINE:\n\tcase BEGWORD:\n\tcase ENDWORD:\n\tcase LIMWORD:\n\tcase NOTLIMWORD:\n\tcase BACKREF:\n\t  resetmust(mp);\n\t  break;\n\tcase STAR:\n\tcase QMARK:\n\t  if (mp <= musts)\n\t    goto done;\t\t/* \"cannot happen\" */\n\t  --mp;\n\t  resetmust(mp);\n\t  break;\n\tcase OR:\n\tcase ORTOP:\n\t  if (mp < &musts[2])\n\t    goto done;\t\t/* \"cannot happen\" */\n\t  {\n\t    char **new;\n\t    must *lmp;\n\t    must *rmp;\n\t    int j, ln, rn, n;\n\n\t    rmp = --mp;\n\t    lmp = --mp;\n\t    /* Guaranteed to be.  Unlikely, but. . . */\n\t    if (strcmp(lmp->is, rmp->is) != 0)\n\t      lmp->is[0] = '\\0';\n\t    /* Left side--easy */\n\t    i = 0;\n\t    while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n\t      ++i;\n\t    lmp->left[i] = '\\0';\n\t    /* Right side */\n\t    ln = strlen(lmp->right);\n\t    rn = strlen(rmp->right);\n\t    n = ln;\n\t    if (n > rn)\n\t      n = rn;\n\t    for (i = 0; i < n; ++i)\n\t      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n\t\tbreak;\n\t    for (j = 0; j < i; ++j)\n\t      lmp->right[j] = lmp->right[(ln - i) + j];\n\t    lmp->right[j] = '\\0';\n\t    new = inboth(lmp->in, rmp->in);\n\t    if (new == NULL)\n\t      goto done;\n\t    freelist(lmp->in);\n\t    free((char *) lmp->in);\n\t    lmp->in = new;\n\t  }\n\t  break;\n\tcase PLUS:\n\t  if (mp <= musts)\n\t    goto done;\t\t/* \"cannot happen\" */\n\t  --mp;\n\t  mp->is[0] = '\\0';\n\t  break;\n\tcase END:\n\t  if (mp != &musts[1])\n\t    goto done;\t\t/* \"cannot happen\" */\n\t  for (i = 0; musts[0].in[i] != NULL; ++i)\n\t    if (strlen(musts[0].in[i]) > strlen(result))\n\t      result = musts[0].in[i];\n\t  if (strcmp(result, musts[0].is) == 0)\n\t    exact = 1;\n\t  goto done;\n\tcase CAT:\n\t  if (mp < &musts[2])\n\t    goto done;\t\t/* \"cannot happen\" */\n\t  {\n\t    must *lmp;\n\t    must *rmp;\n\n\t    rmp = --mp;\n\t    lmp = --mp;\n\t    /* In.  Everything in left, plus everything in\n\t       right, plus catenation of\n\t       left's right and right's left. */\n\t    lmp->in = addlists(lmp->in, rmp->in);\n\t    if (lmp->in == NULL)\n\t      goto done;\n\t    if (lmp->right[0] != '\\0' &&\n\t\trmp->left[0] != '\\0')\n\t      {\n\t\tchar *tp;\n\n\t\ttp = icpyalloc(lmp->right);\n\t\tif (tp == NULL)\n\t\t  goto done;\n\t\ttp = icatalloc(tp, rmp->left);\n\t\tif (tp == NULL)\n\t\t  goto done;\n\t\tlmp->in = enlist(lmp->in, tp,\n\t\t\t\t strlen(tp));\n\t\tfree(tp);\n\t\tif (lmp->in == NULL)\n\t\t  goto done;\n\t      }\n\t    /* Left-hand */\n\t    if (lmp->is[0] != '\\0')\n\t      {\n\t\tlmp->left = icatalloc(lmp->left,\n\t\t\t\t      rmp->left);\n\t\tif (lmp->left == NULL)\n\t\t  goto done;\n\t      }\n\t    /* Right-hand */\n\t    if (rmp->is[0] == '\\0')\n\t      lmp->right[0] = '\\0';\n\t    lmp->right = icatalloc(lmp->right, rmp->right);\n\t    if (lmp->right == NULL)\n\t      goto done;\n\t    /* Guaranteed to be */\n\t    if (lmp->is[0] != '\\0' && rmp->is[0] != '\\0')\n\t      {\n\t\tlmp->is = icatalloc(lmp->is, rmp->is);\n\t\tif (lmp->is == NULL)\n\t\t  goto done;\n\t      }\n\t    else\n\t      lmp->is[0] = '\\0';\n\t  }\n\t  break;\n\tdefault:\n\t  if (t < END)\n\t    {\n\t      /* \"cannot happen\" */\n\t      goto done;\n\t    }\n\t  else if (t == '\\0')\n\t    {\n\t      /* not on *my* shift */\n\t      goto done;\n\t    }\n\t  else if (t >= CSET)\n\t    {\n\t      /* easy enough */\n\t      resetmust(mp);\n\t    }\n\t  else\n\t    {\n\t      /* plain character */\n\t      resetmust(mp);\n\t      mp->is[0] = mp->left[0] = mp->right[0] = t;\n\t      mp->is[1] = mp->left[1] = mp->right[1] = '\\0';\n\t      mp->in = enlist(mp->in, mp->is, 1);\n\t      if (mp->in == NULL)\n\t\tgoto done;\n\t    }\n\t  break;\n\t}\n#ifdef DEBUG\n      fprintf(stderr, \" node: %d:\", ri);\n      prtok(dfa->tokens[ri]);\n      fprintf(stderr, \"\\n  in:\");\n      for (i = 0; mp->in[i]; ++i)\n\tfprintf(stderr, \" \\\"%s\\\"\", mp->in[i]);\n      fprintf(stderr, \"\\n  is: \\\"%s\\\"\\n\", mp->is);\n      fprintf(stderr, \"  left: \\\"%s\\\"\\n\", mp->left);\n      fprintf(stderr, \"  right: \\\"%s\\\"\\n\", mp->right);\n#endif\n      ++mp;\n    }\n done:\n  if (strlen(result))\n    {\n      dm = (struct dfamust *) malloc(sizeof (struct dfamust));\n      dm->exact = exact;\n      dm->must = malloc(strlen(result) + 1);\n      strcpy(dm->must, result);\n      dm->next = dfa->musts;\n      dfa->musts = dm;\n    }\n  mp = musts;\n  for (i = 0; i <= dfa->tindex; ++i)\n    {\n      freelist(mp[i].in);\n      ifree((char *) mp[i].in);\n      ifree(mp[i].left);\n      ifree(mp[i].right);\n      ifree(mp[i].is);\n    }\n  free((char *) mp);\n}\n/* kwset.c - search for any of a set of keywords.\n   Copyright 1989 Free Software Foundation\n\t\t  Written August 1989 by Mike Haertel.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 1, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n   The author may be reached (Email) at the address mike@ai.mit.edu,\n   or (US mail) as Mike Haertel c/o Free Software Foundation. */\n\n/* The algorithm implemented by these routines bears a startling resemblence\n   to one discovered by Beate Commentz-Walter, although it is not identical.\n   See \"A String Matching Algorithm Fast on the Average,\" Technical Report,\n   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900\n   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, \"Efficient\n   String Matching:  An Aid to Bibliographic Search,\" CACM June 1975,\n   Vol. 18, No. 6, which describes the failure function used below. */\n\n\n#ifdef STDC_HEADERS\n#undef RE_DUP_MAX\n#include <limits.h>\n#define flag_limits 1\n#if flag_stdlib==0 \n#include <stdlib.h>\n#define flag_stdlib 1\n#endif\n#else\n#define INT_MAX 2147483647\n#define UCHAR_MAX 255\n#ifdef __STDC__\n#include <stddef.h>\n#else\n#if flag_systypes==0\n#include <sys/types.h>\n#define flag_systypes 1\n#endif\n#endif\nextern char *malloc();\nextern void free();\n#endif\n\n#ifdef HAVE_MEMCHR\n#if flag_string==0\n#include <string.h>\n#define flag_string 1\n#endif\n#ifdef NEED_MEMORY_H\n#if flag_memory==0\n#include <memory.h>\n#define flag_memory 1\n#endif\n#endif\n#else\n#ifdef __STDC__\nextern void *memchr();\n#else\nextern char *memchr();\n#endif\n#endif\n\n#ifdef GREP\nextern char *xmalloc();\n#define malloc xmalloc\n#endif\n\n#include \"kwset.h\"\n#include \"obstack.h\"\n\n#define NCHAR (UCHAR_MAX + 1)\n#define obstack_chunk_alloc malloc\n#define obstack_chunk_free free\n\n/* Balanced tree of edges and labels leaving a given trie node. */\nstruct tree\n{\n  struct tree *llink;\t\t/* Left link; MUST be first field. */\n  struct tree *rlink;\t\t/* Right link (to larger labels). */\n  struct trie *trie;\t\t/* Trie node pointed to by this edge. */\n  unsigned char label;\t\t/* Label on this edge. */\n  char balance;\t\t\t/* Difference in depths of subtrees. */\n};\n\n/* Node of a trie representing a set of reversed keywords. */\nstruct trie\n{\n  unsigned int accepting;\t/* Word index of accepted word, or zero. */\n  struct tree *links;\t\t/* Tree of edges leaving this node. */\n  struct trie *parent;\t\t/* Parent of this node. */\n  struct trie *next;\t\t/* List of all trie nodes in level order. */\n  struct trie *fail;\t\t/* Aho-Corasick failure function. */\n  int depth;\t\t\t/* Depth of this node from the root. */\n  int shift;\t\t\t/* Shift function for search failures. */\n  int maxshift;\t\t\t/* Max shift of self and descendents. */\n};\n\n/* Structure returned opaquely to the caller, containing everything. */\nstruct kwset\n{\n  struct obstack obstack;\t/* Obstack for node allocation. */\n  int words;\t\t\t/* Number of words in the trie. */\n  struct trie *trie;\t\t/* The trie itself. */\n  int mind;\t\t\t/* Minimum depth of an accepting node. */\n  int maxd;\t\t\t/* Maximum depth of any node. */\n  unsigned char delta[NCHAR];\t/* Delta table for rapid search. */\n  struct trie *next[NCHAR];\t/* Table of children of the root. */\n  char *target;\t\t\t/* Target string if there's only one. */\n  int mind2;\t\t\t/* Used in Boyer-Moore search for one string. */\n  char *trans;\t\t\t/* Character translation table. */\n};\n\n/* Allocate and initialize a keyword set object, returning an opaque\n   pointer to it.  Return NULL if memory is not available. */\nkwset_t\nkwsalloc(trans)\n     char *trans;\n{\n  struct kwset *kwset;\n\n  kwset = (struct kwset *) malloc(sizeof (struct kwset));\n  if (!kwset)\n    return 0;\n\n  obstack_init(&kwset->obstack);\n  kwset->words = 0;\n  kwset->trie\n    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));\n  if (!kwset->trie)\n    {\n      kwsfree((kwset_t) kwset);\n      return 0;\n    }\n  kwset->trie->accepting = 0;\n  kwset->trie->links = 0;\n  kwset->trie->parent = 0;\n  kwset->trie->next = 0;\n  kwset->trie->fail = 0;\n  kwset->trie->depth = 0;\n  kwset->trie->shift = 0;\n  kwset->mind = INT_MAX;\n  kwset->maxd = -1;\n  kwset->target = 0;\n  kwset->trans = trans;\n\n  return (kwset_t) kwset;\n}\n\n/* Add the given string to the contents of the keyword set.  Return NULL\n   for success, an error message otherwise. */\nchar *\nkwsincr(kws, text, len)\n     kwset_t kws;\n     char *text;\n     size_t len;\n{\n  struct kwset *kwset;\n  register struct trie *trie;\n  register unsigned char label;\n  register struct tree *link;\n  register int depth;\n  struct tree *links[12];\n  enum { L, R } dirs[12];\n  struct tree *t, *r, *l, *rl, *lr;\n\n  kwset = (struct kwset *) kws;\n  trie = kwset->trie;\n  text += len;\n\n  /* Descend the trie (built of reversed keywords) character-by-character,\n     installing new nodes when necessary. */\n  while (len--)\n    {\n      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;\n\n      /* Descend the tree of outgoing links for this trie node,\n\t looking for the current character and keeping track\n\t of the path followed. */\n      link = trie->links;\n      links[0] = (struct tree *) &trie->links;\n      dirs[0] = L;\n      depth = 1;\n\n      while (link && label != link->label)\n\t{\n\t  links[depth] = link;\n\t  if (label < link->label)\n\t    dirs[depth++] = L, link = link->llink;\n\t  else\n\t    dirs[depth++] = R, link = link->rlink;\n\t}\n\n      /* The current character doesn't have an outgoing link at\n\t this trie node, so build a new trie node and install\n\t a link in the current trie node's tree. */\n      if (!link)\n\t{\n\t  link = (struct tree *) obstack_alloc(&kwset->obstack,\n\t\t\t\t\t       sizeof (struct tree));\n\t  if (!link)\n\t    return \"memory exhausted\";\n\t  link->llink = 0;\n\t  link->rlink = 0;\n\t  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,\n\t\t\t\t\t\t     sizeof (struct trie));\n\t  if (!link->trie)\n\t    return \"memory exhausted\";\n\t  link->trie->accepting = 0;\n\t  link->trie->links = 0;\n\t  link->trie->parent = trie;\n\t  link->trie->next = 0;\n\t  link->trie->fail = 0;\n\t  link->trie->depth = trie->depth + 1;\n\t  link->trie->shift = 0;\n\t  link->label = label;\n\t  link->balance = 0;\n\n\t  /* Install the new tree node in its parent. */\n\t  if (dirs[--depth] == L)\n\t    links[depth]->llink = link;\n\t  else\n\t    links[depth]->rlink = link;\n\n\t  /* Back up the tree fixing the balance flags. */\n\t  while (depth && !links[depth]->balance)\n\t    {\n\t      if (dirs[depth] == L)\n\t\t--links[depth]->balance;\n\t      else\n\t\t++links[depth]->balance;\n\t      --depth;\n\t    }\n\n\t  /* Rebalance the tree by pointer rotations if necessary. */\n\t  if (depth && ((dirs[depth] == L && --links[depth]->balance)\n\t\t\t|| (dirs[depth] == R && ++links[depth]->balance)))\n\t    {\n\t      switch (links[depth]->balance)\n\t\t{\n\t\tcase (char) -2:\n\t\t  switch (dirs[depth + 1])\n\t\t    {\n\t\t    case L:\n\t\t      r = links[depth], t = r->llink, rl = t->rlink;\n\t\t      t->rlink = r, r->llink = rl;\n\t\t      t->balance = r->balance = 0;\n\t\t      break;\n\t\t    case R:\n\t\t      r = links[depth], l = r->llink, t = l->rlink;\n\t\t      rl = t->rlink, lr = t->llink;\n\t\t      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;\n\t\t      l->balance = t->balance != 1 ? 0 : -1;\n\t\t      r->balance = t->balance != (char) -1 ? 0 : 1;\n\t\t      t->balance = 0;\n\t\t      break;\n\t\t    }\n\t\t  break;\n\t\tcase 2:\n\t\t  switch (dirs[depth + 1])\n\t\t    {\n\t\t    case R:\n\t\t      l = links[depth], t = l->rlink, lr = t->llink;\n\t\t      t->llink = l, l->rlink = lr;\n\t\t      t->balance = l->balance = 0;\n\t\t      break;\n\t\t    case L:\n\t\t      l = links[depth], r = l->rlink, t = r->llink;\n\t\t      lr = t->llink, rl = t->rlink;\n\t\t      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;\n\t\t      l->balance = t->balance != 1 ? 0 : -1;\n\t\t      r->balance = t->balance != (char) -1 ? 0 : 1;\n\t\t      t->balance = 0;\n\t\t      break;\n\t\t    }\n\t\t  break;\n\t\t}\n\n\t      if (dirs[depth - 1] == L)\n\t\tlinks[depth - 1]->llink = t;\n\t      else\n\t\tlinks[depth - 1]->rlink = t;\n\t    }\n\t}\n\n      trie = link->trie;\n    }\n\n  /* Mark the node we finally reached as accepting, encoding the\n     index number of this word in the keyword set so far. */\n  if (!trie->accepting)\n    trie->accepting = 1 + 2 * kwset->words;\n  ++kwset->words;\n\n  /* Keep track of the longest and shortest string of the keyword set. */\n  if (trie->depth < kwset->mind)\n    kwset->mind = trie->depth;\n  if (trie->depth > kwset->maxd)\n    kwset->maxd = trie->depth;\n\n  return 0;\n}\n\n/* Enqueue the trie nodes referenced from the given tree in the\n   given queue. */\nstatic void\nenqueue(tree, last)\n     struct tree *tree;\n     struct trie **last;\n{\n  if (!tree)\n    return;\n  enqueue(tree->llink, last);\n  enqueue(tree->rlink, last);\n  (*last) = (*last)->next = tree->trie;\n}\n\n/* Compute the Aho-Corasick failure function for the trie nodes referenced\n   from the given tree, given the failure function for their parent as\n   well as a last resort failure node. */\nstatic void\ntreefails(tree, fail, recourse)\n     register struct tree *tree;\n     struct trie *fail;\n     struct trie *recourse;\n{\n  register struct tree *link;\n\n  if (!tree)\n    return;\n\n  treefails(tree->llink, fail, recourse);\n  treefails(tree->rlink, fail, recourse);\n\n  /* Find, in the chain of fails going back to the root, the first\n     node that has a descendent on the current label. */\n  while (fail)\n    {\n      link = fail->links;\n      while (link && tree->label != link->label)\n\tif (tree->label < link->label)\n\t  link = link->llink;\n\telse\n\t  link = link->rlink;\n      if (link)\n\t{\n\t  tree->trie->fail = link->trie;\n\t  return;\n\t}\n      fail = fail->fail;\n    }\n\n  tree->trie->fail = recourse;\n}\n\n/* Set delta entries for the links of the given tree such that\n   the preexisting delta value is larger than the current depth. */\nstatic void\ntreedelta(tree, depth, delta)\n     register struct tree *tree;\n     register unsigned int depth;\n     unsigned char delta[];\n{\n  if (!tree)\n    return;\n  treedelta(tree->llink, depth, delta);\n  treedelta(tree->rlink, depth, delta);\n  if (depth < delta[tree->label])\n    delta[tree->label] = depth;\n}\n\n/* Return true if A has every label in B. */\nstatic int\nhasevery(a, b)\n     register struct tree *a;\n     register struct tree *b;\n{\n  if (!b)\n    return 1;\n  if (!hasevery(a, b->llink))\n    return 0;\n  if (!hasevery(a, b->rlink))\n    return 0;\n  while (a && b->label != a->label)\n    if (b->label < a->label)\n      a = a->llink;\n    else\n      a = a->rlink;\n  return !!a;\n}\n\n/* Compute a vector, indexed by character code, of the trie nodes\n   referenced from the given tree. */\nstatic void\ntreenext(tree, next)\n     struct tree *tree;\n     struct trie *next[];\n{\n  if (!tree)\n    return;\n  treenext(tree->llink, next);\n  treenext(tree->rlink, next);\n  next[tree->label] = tree->trie;\n}\n\n/* Compute the shift for each trie node, as well as the delta\n   table and next cache for the given keyword set. */\nchar *\nkwsprep(kws)\n     kwset_t kws;\n{\n  register struct kwset *kwset;\n  register int i;\n  register struct trie *curr, *fail;\n  register char *trans;\n  unsigned char delta[NCHAR];\n  struct trie *last, *next[NCHAR];\n\n  kwset = (struct kwset *) kws;\n\n  /* Initial values for the delta table; will be changed later.  The\n     delta entry for a given character is the smallest depth of any\n     node at which an outgoing edge is labeled by that character. */\n  if (kwset->mind < 256)\n    for (i = 0; i < NCHAR; ++i)\n      delta[i] = kwset->mind;\n  else\n    for (i = 0; i < NCHAR; ++i)\n      delta[i] = 255;\n\n  /* Check if we can use the simple boyer-moore algorithm, instead\n     of the hairy commentz-walter algorithm. */\n  if (kwset->words == 1 && kwset->trans == 0)\n    {\n      /* Looking for just one string.  Extract it from the trie. */\n      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);\n      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)\n\t{\n\t  kwset->target[i] = curr->links->label;\n\t  curr = curr->links->trie;\n\t}\n      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */\n      for (i = 0; i < kwset->mind; ++i)\n\tdelta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);\n      kwset->mind2 = kwset->mind;\n      /* Find the minimal delta2 shift that we might make after\n\t a backwards match has failed. */\n      for (i = 0; i < kwset->mind - 1; ++i)\n\tif (kwset->target[i] == kwset->target[kwset->mind - 1])\n\t  kwset->mind2 = kwset->mind - (i + 1);\n    }\n  else\n    {\n      /* Traverse the nodes of the trie in level order, simultaneously\n\t computing the delta table, failure function, and shift function. */\n      for (curr = last = kwset->trie; curr; curr = curr->next)\n\t{\n\t  /* Enqueue the immediate descendents in the level order queue. */\n\t  enqueue(curr->links, &last);\n\n\t  curr->shift = kwset->mind;\n\t  curr->maxshift = kwset->mind;\n\n\t  /* Update the delta table for the descendents of this node. */\n\t  treedelta(curr->links, curr->depth, delta);\n\n\t  /* Compute the failure function for the decendents of this node. */\n\t  treefails(curr->links, curr->fail, kwset->trie);\n\n\t  /* Update the shifts at each node in the current node's chain\n\t     of fails back to the root. */\n\t  for (fail = curr->fail; fail; fail = fail->fail)\n\t    {\n\t      /* If the current node has some outgoing edge that the fail\n\t\t doesn't, then the shift at the fail should be no larger\n\t\t than the difference of their depths. */\n\t      if (!hasevery(fail->links, curr->links))\n\t\tif (curr->depth - fail->depth < fail->shift)\n\t\t  fail->shift = curr->depth - fail->depth;\n\n\t      /* If the current node is accepting then the shift at the\n\t\t fail and its descendents should be no larger than the\n\t\t difference of their depths. */\n\t      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)\n\t\tfail->maxshift = curr->depth - fail->depth;\n\t    }\n\t}\n\n      /* Traverse the trie in level order again, fixing up all nodes whose\n\t shift exceeds their inherited maxshift. */\n      for (curr = kwset->trie->next; curr; curr = curr->next)\n\t{\n\t  if (curr->maxshift > curr->parent->maxshift)\n\t    curr->maxshift = curr->parent->maxshift;\n\t  if (curr->shift > curr->maxshift)\n\t    curr->shift = curr->maxshift;\n\t}\n\n      /* Create a vector, indexed by character code, of the outgoing links\n\t from the root node. */\n      for (i = 0; i < NCHAR; ++i)\n\tnext[i] = 0;\n      treenext(kwset->trie->links, next);\n\n      if ((trans = kwset->trans) != 0)\n\tfor (i = 0; i < NCHAR; ++i)\n\t  kwset->next[i] = next[(unsigned char) trans[i]];\n      else\n\tfor (i = 0; i < NCHAR; ++i)\n\t  kwset->next[i] = next[i];\n    }\n\n  /* Fix things up for any translation table. */\n  if ((trans = kwset->trans) != 0)\n    for (i = 0; i < NCHAR; ++i)\n      kwset->delta[i] = delta[(unsigned char) trans[i]];\n  else\n    for (i = 0; i < NCHAR; ++i)\n      kwset->delta[i] = delta[i];\n\n  return 0;\n}\n\n#define U(C) ((unsigned char) (C))\n\n/* Fast boyer-moore search. */\nstatic char *\nbmexec(kws, text, size)\n     kwset_t kws;\n     char *text;\n     size_t size;\n{\n  struct kwset *kwset;\n  register unsigned char *d1;\n  register char *ep, *sp, *tp;\n  register int d, gc, i, len, md2;\n\n  kwset = (struct kwset *) kws;\n  len = kwset->mind;\n\n  if (len == 0)\n    return text;\n  if (len > size)\n    return 0;\n  if (len == 1)\n    return memchr(text, kwset->target[0], size);\n\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  gc = U(sp[-2]);\n  md2 = kwset->mind2;\n  tp = text + len;\n\n  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */\n  if (size > 12 * len)\n    /* 11 is not a bug, the initial offset happens only once. */\n    for (ep = text + size - 11 * len;;)\n      {\n\twhile (tp <= ep)\n\t  {\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    if (d == 0)\n\t      goto found;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    if (d == 0)\n\t      goto found;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    if (d == 0)\n\t      goto found;\n\t    d = d1[U(tp[-1])], tp += d;\n\t    d = d1[U(tp[-1])], tp += d;\n\t  }\n\tbreak;\n      found:\n\tif (U(tp[-2]) == gc)\n\t  {\n\t    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)\n\t      ;\n\t    if (i > len)\n\t      return tp - len;\n\t  }\n\ttp += md2;\n      }\n\n  /* Now we have only a few characters left to search.  We\n     carefully avoid ever producing an out-of-bounds pointer. */\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n\tcontinue;\n      if (tp[-2] == gc)\n\t{\n\t  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)\n\t    ;\n\t  if (i > len)\n\t    return tp - len;\n\t}\n      d = md2;\n    }\n\n  return 0;\n}\n\n/* Hairy multiple string search. */\nstatic char *\ncwexec(kws, text, len, kwsmatch)\n     kwset_t kws;\n     char *text;\n     size_t len;\n     struct kwsmatch *kwsmatch;\n{\n  struct kwset *kwset;\n  struct trie **next, *trie, *accept;\n  char *beg, *lim, *mch, *lmch;\n  register unsigned char c, *delta;\n  register int d;\n  register char *end, *qlim;\n  register struct tree *tree;\n  register char *trans;\n\n  /* Initialize register copies and look for easy ways out. */\n  kwset = (struct kwset *) kws;\n  if (len < kwset->mind)\n    return 0;\n  next = kwset->next;\n  delta = kwset->delta;\n  trans = kwset->trans;\n  lim = text + len;\n  end = text;\n  if ((d = kwset->mind) != 0)\n    mch = 0;\n  else\n    {\n      mch = text, accept = kwset->trie;\n      goto match;\n    }\n\n  if (len >= 4 * kwset->mind)\n    qlim = lim - 4 * kwset->mind;\n  else\n    qlim = 0;\n\n  while (lim - end >= d)\n    {\n      if (qlim && end <= qlim)\n\t{\n\t  end += d - 1;\n\t  while ((d = delta[c = *end]) && end < qlim)\n\t    {\n\t      end += d;\n\t      end += delta[(unsigned char) *end];\n\t      end += delta[(unsigned char) *end];\n\t    }\n\t  ++end;\n\t}\n      else\n\td = delta[c = (end += d)[-1]];\n      if (d)\n\tcontinue;\n      beg = end - 1;\n      trie = next[c];\n      if (trie->accepting)\n\t{\n\t  mch = beg;\n\t  accept = trie;\n\t}\n      d = trie->shift;\n      while (beg > text)\n\t{\n\t  c = trans ? trans[(unsigned char) *--beg] : *--beg;\n\t  tree = trie->links;\n\t  while (tree && c != tree->label)\n\t    if (c < tree->label)\n\t      tree = tree->llink;\n\t    else\n\t      tree = tree->rlink;\n\t  if (tree)\n\t    {\n\t      trie = tree->trie;\n\t      if (trie->accepting)\n\t\t{\n\t\t  mch = beg;\n\t\t  accept = trie;\n\t\t}\n\t    }\n\t  else\n\t    break;\n\t  d = trie->shift;\n\t}\n      if (mch)\n\tgoto match;\n    }\n  return 0;\n\n match:\n  /* Given a known match, find the longest possible match anchored\n     at or before its starting point.  This is nearly a verbatim\n     copy of the preceding main search loops. */\n  if (lim - mch > kwset->maxd)\n    lim = mch + kwset->maxd;\n  lmch = 0;\n  d = 1;\n  while (lim - end >= d)\n    {\n      if ((d = delta[c = (end += d)[-1]]) != 0)\n\tcontinue;\n      beg = end - 1;\n      if (!(trie = next[c]))\n\t{\n\t  d = 1;\n\t  continue;\n\t}\n      if (trie->accepting && beg <= mch)\n\t{\n\t  lmch = beg;\n\t  accept = trie;\n\t}\n      d = trie->shift;\n      while (beg > text)\n\t{\n\t  c = trans ? trans[(unsigned char) *--beg] : *--beg;\n\t  tree = trie->links;\n\t  while (tree && c != tree->label)\n\t    if (c < tree->label)\n\t      tree = tree->llink;\n\t    else\n\t      tree = tree->rlink;\n\t  if (tree)\n\t    {\n\t      trie = tree->trie;\n\t      if (trie->accepting && beg <= mch)\n\t\t{\n\t\t  lmch = beg;\n\t\t  accept = trie;\n\t\t}\n\t    }\n\t  else\n\t    break;\n\t  d = trie->shift;\n\t}\n      if (lmch)\n\t{\n\t  mch = lmch;\n\t  goto match;\n\t}\n      if (!d)\n\td = 1;\n    }\n\n  if (kwsmatch)\n    {\n      kwsmatch->index = accept->accepting / 2;\n      kwsmatch->beg[0] = mch;\n      kwsmatch->size[0] = accept->depth;\n    }\n  return mch;\n}\n  \n/* Search through the given text for a match of any member of the\n   given keyword set.  Return a pointer to the first character of\n   the matching substring, or NULL if no match is found.  If FOUNDLEN\n   is non-NULL store in the referenced location the length of the\n   matching substring.  Similarly, if FOUNDIDX is non-NULL, store\n   in the referenced location the index number of the particular\n   keyword matched. */\nchar *\nkwsexec(kws, text, size, kwsmatch)\n     kwset_t kws;\n     char *text;\n     size_t size;\n     struct kwsmatch *kwsmatch;\n{\n  struct kwset *kwset;\n  char *ret;\n\n  kwset = (struct kwset *) kws;\n  if (kwset->words == 1 && kwset->trans == 0)\n    {\n      ret = bmexec(kws, text, size);\n      if (kwsmatch != 0 && ret != 0)\n\t{\n\t  kwsmatch->index = 0;\n\t  kwsmatch->beg[0] = ret;\n\t  kwsmatch->size[0] = kwset->mind;\n\t}\n      return ret;\n    }\n  else\n    return cwexec(kws, text, size, kwsmatch);\n}\n\n/* Free the components of the given keyword set. */\nvoid\nkwsfree(kws)\n     kwset_t kws;\n{\n  struct kwset *kwset;\n\n  kwset = (struct kwset *) kws;\n  obstack_free(&kwset->obstack, 0);\n  free(kws);\n}\n/* obstack.c - subroutines used implicitly by object stack macros\n   Copyright (C) 1988, 1993 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n/*#include \"obstack.h\"*/\n\n/* This is just to get __GNU_LIBRARY__ defined.  */\n/*#include <stdio.h>*/\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#if defined (_LIBC) || !defined (__GNU_LIBRARY__)\n\n\n#ifdef __STDC__\n#define POINTER void *\n#else\n#define POINTER char *\n#endif\n\n/* Determine default alignment.  */\nstruct fooalign {char x; double d;};\n#define DEFAULT_ALIGNMENT  \\\n  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))\n/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.\n   But in fact it might be less smart and round addresses to as much as\n   DEFAULT_ROUNDING.  So we prepare for it to do that.  */\nunion fooround {long x; double d;};\n#define DEFAULT_ROUNDING (sizeof (union fooround))\n\n/* When we copy a long block of data, this is the unit to do it with.\n   On some machines, copying successive ints does not work;\n   in such a case, redefine COPYING_UNIT to `long' (if that works)\n   or `char' as a last resort.  */\n#ifndef COPYING_UNIT\n#define COPYING_UNIT int\n#endif\n\n/* The non-GNU-C macros copy the obstack into this global variable\n   to avoid multiple evaluation.  */\n\nstruct obstack *_obstack;\n\n/* Define a macro that either calls functions with the traditional malloc/free\n   calling interface, or calls functions with the mmalloc/mfree interface\n   (that adds an extra first argument), based on the state of use_extra_arg.\n   For free, do not use ?:, since some compilers, like the MIPS compilers,\n   do not allow (expr) ? void : void.  */\n\n#define CALL_CHUNKFUN(h, size) \\\n  (((h) -> use_extra_arg) \\\n   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n   : (*(h)->chunkfun) ((size)))\n\n#define CALL_FREEFUN(h, old_chunk) \\\n  do { \\\n    if ((h) -> use_extra_arg) \\\n      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n    else \\\n      (*(h)->freefun) ((old_chunk)); \\\n  } while (0)\n\n#define CALL_FREEFUN(h, old_chunk) \\\n  do { \\\n      free ((old_chunk)); \\\n  } while (0)\n\n\f\n/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n   Objects start on multiples of ALIGNMENT (0 means use default).\n   CHUNKFUN is the function to use to allocate chunks,\n   and FREEFUN the function to free them.  */\n\nvoid\n_obstack_begin (h, size, alignment, chunkfun, freefun)\n     struct obstack *h;\n     int size;\n     int alignment;\n     POINTER (*chunkfun) ();\n     void (*freefun) ();\n{\n  register struct _obstack_chunk* chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n\t Use the values for range checking, because if range checking is off,\n\t the extra bytes won't be missed terribly, but if range checking is on\n\t and we used a larger request, a whole extra 4096 bytes would be\n\t allocated.\n\n\t These number are irrelevant to the new GNU malloc.  I suspect it is\n\t less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n\t\t    + 4 + DEFAULT_ROUNDING - 1)\n\t\t   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n  h->freefun = freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->use_extra_arg = 0;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  h->next_free = h->object_base = chunk->contents;\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n}\n\nvoid\n_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n     struct obstack *h;\n     int size;\n     int alignment;\n     POINTER (*chunkfun) ();\n     void (*freefun) ();\n     POINTER arg;\n{\n  register struct _obstack_chunk* chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n\t Use the values for range checking, because if range checking is off,\n\t the extra bytes won't be missed terribly, but if range checking is on\n\t and we used a larger request, a whole extra 4096 bytes would be\n\t allocated.\n\n\t These number are irrelevant to the new GNU malloc.  I suspect it is\n\t less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n\t\t    + 4 + DEFAULT_ROUNDING - 1)\n\t\t   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n  h->freefun = freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  h->next_free = h->object_base = chunk->contents;\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n}\n\n/* Allocate a new current chunk for the obstack *H\n   on the assumption that LENGTH bytes need to be added\n   to the current object, or a new object of length LENGTH allocated.\n   Copies any partial object from the end of the old chunk\n   to the beginning of the new one.  */\n\nvoid\n_obstack_newchunk (h, length)\n     struct obstack *h;\n     int length;\n{\n  register struct _obstack_chunk*\told_chunk = h->chunk;\n  register struct _obstack_chunk*\tnew_chunk;\n  register long\tnew_size;\n  register int obj_size = h->next_free - h->object_base;\n  register int i;\n  int already;\n\n  /* Compute size for new chunk.  */\n  new_size = (obj_size + length) + (obj_size >> 3) + 100;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Move the existing object to the new chunk.\n     Word at a time is fast and is safe if the object\n     is sufficiently aligned.  */\n  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n    {\n      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n\t   i >= 0; i--)\n\t((COPYING_UNIT *)new_chunk->contents)[i]\n\t  = ((COPYING_UNIT *)h->object_base)[i];\n      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n\t but that can cross a page boundary on a machine\n\t which does not do strict alignment for COPYING_UNITS.  */\n      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n    }\n  else\n    already = 0;\n  /* Copy remaining bytes one by one.  */\n  for (i = already; i < obj_size; i++)\n    new_chunk->contents[i] = h->object_base[i];\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)\n    {\n      new_chunk->prev = old_chunk->prev;\n      CALL_FREEFUN (h, old_chunk);\n    }\n\n  h->object_base = new_chunk->contents;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}\n\n/* Return nonzero if object OBJ has been allocated from obstack H.\n   This is here for debugging.\n   If you use it in a program, you are probably losing.  */\n\nint\n_obstack_allocated_p (h, obj)\n     struct obstack *h;\n     POINTER obj;\n{\n  register struct _obstack_chunk*  lp;\t/* below addr of any objects in this chunk */\n  register struct _obstack_chunk*  plp;\t/* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk. */\n  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}\n\f\n/* Free objects in obstack H, including OBJ and everything allocate\n   more recently than OBJ.  If OBJ is zero, free everything in H.  */\n\n#undef obstack_free\n\n/* This function has two names with identical definitions.\n   This is the first one, called from non-ANSI code.  */\n\nvoid\n_obstack_free (h, obj)\n     struct obstack *h;\n     POINTER obj;\n{\n  register struct _obstack_chunk*  lp;\t/* below addr of any objects in this chunk */\n  register struct _obstack_chunk*  plp;\t/* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))\n    {\n      plp = lp->prev;\n      CALL_FREEFUN (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n\t chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *)(obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}\n\n/* This function is used from ANSI code.  */\n\nvoid\nobstack_free (h, obj)\n     struct obstack *h;\n     POINTER obj;\n{\n  register struct _obstack_chunk*  lp;\t/* below addr of any objects in this chunk */\n  register struct _obstack_chunk*  plp;\t/* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))\n    {\n      plp = lp->prev;\n      CALL_FREEFUN (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n\t chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *)(obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}\n\f\n#if 0\n/* These are now turned off because the applications do not use it\n   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */\n\n/* Now define the functional versions of the obstack macros.\n   Define them to simply use the corresponding macros to do the job.  */\n\n#ifdef __STDC__\n/* These function definitions do not work with non-ANSI preprocessors;\n   they won't pass through the macro names in parentheses.  */\n\n/* The function names appear in parentheses in order to prevent\n   the macro-definitions of the names from being expanded there.  */\n\nPOINTER (obstack_base) (obstack)\n     struct obstack *obstack;\n{\n  return obstack_base (obstack);\n}\n\nPOINTER (obstack_next_free) (obstack)\n     struct obstack *obstack;\n{\n  return obstack_next_free (obstack);\n}\n\nint (obstack_object_size) (obstack)\n     struct obstack *obstack;\n{\n  return obstack_object_size (obstack);\n}\n\nint (obstack_room) (obstack)\n     struct obstack *obstack;\n{\n  return obstack_room (obstack);\n}\n\nvoid (obstack_grow) (obstack, pointer, length)\n     struct obstack *obstack;\n     POINTER pointer;\n     int length;\n{\n  obstack_grow (obstack, pointer, length);\n}\n\nvoid (obstack_grow0) (obstack, pointer, length)\n     struct obstack *obstack;\n     POINTER pointer;\n     int length;\n{\n  obstack_grow0 (obstack, pointer, length);\n}\n\nvoid (obstack_1grow) (obstack, character)\n     struct obstack *obstack;\n     int character;\n{\n  obstack_1grow (obstack, character);\n}\n\nvoid (obstack_blank) (obstack, length)\n     struct obstack *obstack;\n     int length;\n{\n  obstack_blank (obstack, length);\n}\n\nvoid (obstack_1grow_fast) (obstack, character)\n     struct obstack *obstack;\n     int character;\n{\n  obstack_1grow_fast (obstack, character);\n}\n\nvoid (obstack_blank_fast) (obstack, length)\n     struct obstack *obstack;\n     int length;\n{\n  obstack_blank_fast (obstack, length);\n}\n\nPOINTER (obstack_finish) (obstack)\n     struct obstack *obstack;\n{\n  return obstack_finish (obstack);\n}\n\nPOINTER (obstack_alloc) (obstack, length)\n     struct obstack *obstack;\n     int length;\n{\n  return obstack_alloc (obstack, length);\n}\n\nPOINTER (obstack_copy) (obstack, pointer, length)\n     struct obstack *obstack;\n     POINTER pointer;\n     int length;\n{\n  return obstack_copy (obstack, pointer, length);\n}\n\nPOINTER (obstack_copy0) (obstack, pointer, length)\n     struct obstack *obstack;\n     POINTER pointer;\n     int length;\n{\n  return obstack_copy0 (obstack, pointer, length);\n}\n\n#endif /* __STDC__ */\n\n#endif /* 0 */\n\n#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n/* search.c - searching subroutines using dfa, kwset and regex for grep.\n   Copyright (C) 1992 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n   Written August 1992 by Mike Haertel. */\n\n/*#include <ctype.h>*/\n\n#ifdef STDC_HEADERS\n#if flag_limits==0\n#undef RE_DUP_MAX\n#include <limits.h>\n#define flag_limits 1\n#endif\n#if flag_stdlib==0\n#include <stdlib.h>\n#define flag_stdlib 1\n#endif\n#else\n#define UCHAR_MAX 255\n#if flag_systypes==0\n#include <sys/types.h>\n#define flag_systypes 1\n#endif\nextern char *malloc();\n#endif\n\n#ifdef HAVE_MEMCHR\n#if flag_string==0\n#include <string.h>\n#define flag_string 1\n#endif\n#ifdef NEED_MEMORY_H\n#if flag_memory==0\n#include <memory.h>\n#define flag_memory 1\n#endif\n#endif\n#else\n#ifdef __STDC__\nextern void *memchr();\n#else\nextern char *memchr();\n#endif\n#endif\n\n#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)\n#undef bcopy\n#define bcopy(s, d, n) memcpy((d), (s), (n))\n#endif\n\n#ifdef isascii\n#define ISALNUM(C) (isascii(C) && isalnum(C))\n#define ISUPPER(C) (isascii(C) && isupper(C))\n#else\n#define ISALNUM(C) isalnum(C)\n#define ISUPPER(C) isupper(C)\n#endif\n\n#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))\n\n/*#include \"grep.h\"*/\n/*#include \"dfa.h\"*/\n/*#include \"kwset.h\"*/\n/*#include \"regex.h\"*/\n\n#define NCHAR (UCHAR_MAX + 1)\n\n#if __STDC__\nstatic void Gcompile(char *, size_t);\nstatic void Ecompile(char *, size_t);\nstatic char *EGexecute(char *, size_t, char **);\nstatic void Fcompile(char *, size_t);\nstatic char *Fexecute(char *, size_t, char **);\n#else\nstatic void Gcompile();\nstatic void Ecompile();\nstatic char *EGexecute();\nstatic void Fcompile();\nstatic char *Fexecute();\n#endif\n\n/* Here is the matchers vector for the main program. */\nstruct matcher matchers[] = {\n  { \"default\", Gcompile, EGexecute },\n  { \"grep\", Gcompile, EGexecute },\n  { \"ggrep\", Gcompile, EGexecute },\n  { \"egrep\", Ecompile, EGexecute },\n  { \"posix-egrep\", Ecompile, EGexecute },\n  { \"gegrep\", Ecompile, EGexecute },\n  { \"fgrep\", Fcompile, Fexecute },\n  { \"gfgrep\", Fcompile, Fexecute },\n  { 0, 0, 0 },\n};\n\n/* For -w, we also consider _ to be word constituent.  */\n#define WCHAR(C) (ISALNUM(C) || (C) == '_')\n\n/* DFA compiled regexp. */\nstatic struct dfa dfa_1;\n\n/* Regex compiled regexp. */\nstatic struct re_pattern_buffer regex;\n\n/* KWset compiled pattern.  For Ecompile and Gcompile, we compile\n   a list of strings, at least one of which is known to occur in\n   any string matching the regexp. */\nstatic kwset_t kwset;\n\n/* Last compiled fixed string known to exactly match the regexp.\n   If kwsexec() returns < lastexact, then we don't need to\n   call the regexp matcher at all. */\nstatic int lastexact;\n\nvoid\ndfaerror(mesg)\n     char *mesg;\n{\n  fatal(mesg, 0);\n}\n\nstatic void\nkwsinit()\n{\n  static char trans[NCHAR];\n  int i;\n\n  if (match_icase)\n    for (i = 0; i < NCHAR; ++i)\n      trans[i] = TOLOWER(i);\n\n  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))\n    fatal(\"memory exhausted\", 0);\n}  \n\n/* If the DFA turns out to have some set of fixed strings one of\n   which must occur in the match, then we build a kwset matcher\n   to find those strings, and thus quickly filter out impossible\n   matches. */\nstatic void\nkwsmusts()\n{\n  struct dfamust *dm;\n  char *err;\n\n  if (dfa_1.musts)\n    {\n      kwsinit();\n      /* First, we compile in the substrings known to be exact\n\t matches.  The kwset matcher will return the index\n\t of the matching string that it chooses. */\n      for (dm = dfa_1.musts; dm; dm = dm->next)\n\t{\n\t  if (!dm->exact)\n\t    continue;\n\t  ++lastexact;\n\t  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)\n\t    fatal(err, 0);\n\t}\n      /* Now, we compile the substrings that will require\n\t the use of the regexp matcher.  */\n      for (dm = dfa_1.musts; dm; dm = dm->next)\n\t{\n\t  if (dm->exact)\n\t    continue;\n\t  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)\n\t    fatal(err, 0);\n\t}\n      if ((err = kwsprep(kwset)) != 0)\n\tfatal(err, 0);\n    }\n}\n\nstatic void\nGcompile(pattern, size)\n     char *pattern;\n     size_t size;\n{\n#ifdef __STDC__\n  const\n#endif\n  char *err;\n\n  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);\n  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);\n\n  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)\n    fatal(err, 0);\n\n  dfainit(&dfa_1);\n\n  /* In the match_words and match_lines cases, we use a different pattern\n     for the DFA matcher that will quickly throw out cases that won't work.\n     Then if DFA succeeds we do some hairy stuff using the regex matcher\n     to decide whether the match should really count. */\n  if (match_words || match_lines)\n    {\n      /* In the whole-word case, we use the pattern:\n\t (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).\n\t In the whole-line case, we use the pattern:\n\t ^(userpattern)$.\n\t BUG: Using [A-Za-z_] is locale-dependent!  */\n\n      char *n = malloc(size + 50);\n      int i = 0;\n\n      strcpy(n, \"\");\n\n      if (match_lines)\n\tstrcpy(n, \"^\\\\(\");\n      if (match_words)\n\tstrcpy(n, \"\\\\(^\\\\|[^0-9A-Za-z_]\\\\)\\\\(\");\n\n      i = strlen(n);\n      bcopy(pattern, n + i, size);\n      i += size;\n\n      if (match_words)\n\tstrcpy(n + i, \"\\\\)\\\\([^0-9A-Za-z_]\\\\|$\\\\)\");\n      if (match_lines)\n\tstrcpy(n + i, \"\\\\)$\");\n\n      i += strlen(n + i);\n      dfacomp(n, i, &dfa_1, 1);\n    }\n  else\n    dfacomp(pattern, size, &dfa_1, 1);\n\n  kwsmusts();\n}\n\nstatic void\nEcompile(pattern, size)\n     char *pattern;\n     size_t size;\n{\n#ifdef __STDC__\n  const\n#endif\n  char *err;\n\n  if (strcmp(matcher, \"posix-egrep\") == 0)\n    {\n      re_set_syntax(RE_SYNTAX_POSIX_EGREP);\n      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);\n    }\n  else\n    {\n      re_set_syntax(RE_SYNTAX_EGREP);\n      dfasyntax(RE_SYNTAX_EGREP, match_icase);\n    }\n\n  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)\n    fatal(err, 0);\n\n  dfainit(&dfa_1);\n\n  /* In the match_words and match_lines cases, we use a different pattern\n     for the DFA matcher that will quickly throw out cases that won't work.\n     Then if DFA succeeds we do some hairy stuff using the regex matcher\n     to decide whether the match should really count. */\n  if (match_words || match_lines)\n    {\n      /* In the whole-word case, we use the pattern:\n\t (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).\n\t In the whole-line case, we use the pattern:\n\t ^(userpattern)$.\n\t BUG: Using [A-Za-z_] is locale-dependent!  */\n\n      char *n = malloc(size + 50);\n      int i = 0;\n\n      strcpy(n, \"\");\n\n      if (match_lines)\n\tstrcpy(n, \"^(\");\n      if (match_words)\n\tstrcpy(n, \"(^|[^0-9A-Za-z_])(\");\n\n      i = strlen(n);\n      bcopy(pattern, n + i, size);\n      i += size;\n\n      if (match_words)\n\tstrcpy(n + i, \")([^0-9A-Za-z_]|$)\");\n      if (match_lines)\n\tstrcpy(n + i, \")$\");\n\n      i += strlen(n + i);\n      dfacomp(n, i, &dfa_1, 1);\n    }\n  else\n    dfacomp(pattern, size, &dfa_1, 1);\n\n  kwsmusts();\n}\n\nstatic char *\nEGexecute(buf, size, endp)\n     char *buf;\n     size_t size;\n     char **endp;\n{\n  register char *buflim, *beg, *end, save;\n  int backref, start, len;\n  struct kwsmatch kwsm;\n  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD\n\t\t\t\t    Q@#%!# library interface in regex.c.  */\n\n  buflim = buf + size;\n\n  for (beg = end = buf; end < buflim; beg = end + 1)\n    {\n      if (kwset)\n\t{\n\t  /* Find a possible match using the KWset matcher. */\n\t  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);\n\t  if (!beg)\n\t    goto failure;\n\t  /* Narrow down to the line containing the candidate, and\n\t     run it through DFA. */\n\t  end = memchr(beg, '\\n', buflim - beg);\n\t  if (!end)\n\t    end = buflim;\n\t  while (beg > buf && beg[-1] != '\\n')\n\t    --beg;\n\t  save = *end;\n\t  if (kwsm.index < lastexact)\n\t    goto success;\n\t  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))\n\t    {\n\t      *end = save;\n\t      continue;\n\t    }\n\t  *end = save;\n\t  /* Successful, no backreferences encountered. */\n\t  if (!backref)\n\t    goto success;\n\t}\n      else\n\t{\n\t  /* No good fixed strings; start with DFA. */\n\t  save = *buflim;\n\t  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);\n\t  *buflim = save;\n\t  if (!beg)\n\t    goto failure;\n\t  /* Narrow down to the line we've found. */\n\t  end = memchr(beg, '\\n', buflim - beg);\n\t  if (!end)\n\t    end = buflim;\n\t  while (beg > buf && beg[-1] != '\\n')\n\t    --beg;\n\t  /* Successful, no backreferences encountered! */\n\t  if (!backref)\n\t    goto success;\n\t}\n      /* If we've made it to this point, this means DFA has seen\n\t a probable match, and we need to run it through Regex. */\n      regex.not_eol = 0;\n      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)\n\t{\n\t  len = regs.end[0] - start;\n\t  if (!match_lines && !match_words || match_lines && len == end - beg)\n\t    goto success;\n\t  /* If -w, check if the match aligns with word boundaries.\n\t     We do this iteratively because:\n\t     (a) the line may contain more than one occurence of the pattern, and\n\t     (b) Several alternatives in the pattern might be valid at a given\n\t     point, and we may need to consider a shorter one to find a word\n\t     boundary. */\n\t  if (match_words)\n\t    while (start >= 0)\n\t      {\n\t\tif ((start == 0 || !WCHAR(beg[start - 1]))\n\t\t    && (len == end - beg || !WCHAR(beg[start + len])))\n\t\t  goto success;\n\t\tif (len > 0)\n\t\t  {\n\t\t    /* Try a shorter length anchored at the same place. */\n\t\t    --len;\n\t\t    regex.not_eol = 1;\n\t\t    len = re_match(&regex, beg, start + len, start, &regs);\n\t\t  }\n\t\tif (len <= 0)\n\t\t  {\n\t\t    /* Try looking further on. */\n\t\t    if (start == end - beg)\n\t\t      break;\n\t\t    ++start;\n\t\t    regex.not_eol = 0;\n\t\t    start = re_search(&regex, beg, end - beg,\n\t\t\t\t      start, end - beg - start, &regs);\n\t\t    len = regs.end[0] - start;\n\t\t  }\n\t      }\n\t}\n    }\n\n failure:\n  return 0;\n\n success:\n  *endp = end < buflim ? end + 1 : end;\n  return beg;\n}\n\nstatic void\nFcompile(pattern, size)\n     char *pattern;\n     size_t size;\n{\n  char *beg, *lim, *err;\n\n  kwsinit();\n  beg = pattern;\n  do\n    {\n      for (lim = beg; lim < pattern + size && *lim != '\\n'; ++lim)\n\t;\n      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)\n\tfatal(err, 0);\n      if (lim < pattern + size)\n\t++lim;\n      beg = lim;\n    }\n  while (beg < pattern + size);\n\n  if ((err = kwsprep(kwset)) != 0)\n    fatal(err, 0);\n}\n\nstatic char *\nFexecute(buf, size, endp)\n     char *buf;\n     size_t size;\n     char **endp;\n{\n  register char *beg, *try, *end;\n  register size_t len;\n  struct kwsmatch kwsmatch;\n\n  for (beg = buf; beg <= buf + size; ++beg)\n    {\n      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))\n\treturn 0;\n      len = kwsmatch.size[0];\n      if (match_lines)\n\t{\n\t  if (beg > buf && beg[-1] != '\\n')\n\t    continue;\n\t  if (beg + len < buf + size && beg[len] != '\\n')\n\t    continue;\n\t  goto success;\n\t}\n      else if (match_words)\n\tfor (try = beg; len && try;)\n\t  {\n\t    if (try > buf && WCHAR((unsigned char) try[-1]))\n\t      break;\n\t    if (try + len < buf + size && WCHAR((unsigned char) try[len]))\n\t      {\n\t\ttry = kwsexec(kwset, beg, --len, &kwsmatch);\n\t\tlen = kwsmatch.size[0];\n\t      }\n\t    else\n\t      goto success;\n\t  }\n      else\n\tgoto success;\n    }\n\n  return 0;\n\n success:\n  if ((end = memchr(beg + len, '\\n', (buf + size) - (beg + len))) != 0)\n    ++end;\n  else\n    end = buf + size;\n  *endp = end;\n  while (beg > buf && beg[-1] != '\\n')\n    --beg;\n  return beg;\n}\n"}}, "framework": {"brandingInformation": {"homepageUrl": "https://github.com/mull-project/mull"}, "name": "Mull", "version": "0.15.0, LLVM 12.0.0"}, "mutationScore": 100, "schemaVersion": "1.7", "thresholds": {"high": 80, "low": 60}}
